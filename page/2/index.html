<!doctype html>



  


<html class="theme-next muse use-motion">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lee/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lee/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2">






<meta name="description" content="my blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://vernvn.github.io/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="my blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="my blog">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://vernvn.github.io/page/2/">


  <title> Hexo </title>
</head>

<body itemscope="" itemtype="//schema.org/WebPage" lang="zh-CN">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Hexo</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule" rel="section">
            
            Schedule
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/07/everyNote/" itemprop="url">
                  EveryNote
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2018-02-07T11:09:10+08:00" content="2018-02-07">
              2018-02-07
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="记录每天学习中发现的知识点"><a href="#记录每天学习中发现的知识点" class="headerlink" title="记录每天学习中发现的知识点"></a>记录每天学习中发现的知识点</h2><font face="黑体" color="#f00" size="4">总结TemplateRef与ViewContainerRef</font>

<h4 id="TemplateRef-用于表示内嵌的template模板元素，可以创建内嵌视图（createEmbeddedView）-可以访问到封装后的nativeElement-模板经过渲染后会替换成comment元素"><a href="#TemplateRef-用于表示内嵌的template模板元素，可以创建内嵌视图（createEmbeddedView）-可以访问到封装后的nativeElement-模板经过渲染后会替换成comment元素" class="headerlink" title="TemplateRef: 用于表示内嵌的template模板元素，可以创建内嵌视图（createEmbeddedView）,可以访问到封装后的nativeElement,模板经过渲染后会替换成comment元素"></a>TemplateRef: 用于表示内嵌的template模板元素，可以创建内嵌视图（createEmbeddedView）,可以访问到封装后的nativeElement,模板经过渲染后会替换成comment元素</h4><h4 id="ViewContainerRef-用于表示一个视图容器，可添加一或多个视图，通过ViewContainerRef实例，可以基于TemplateRef创建内嵌视图，并指定插入位置，主要创建管理内嵌视图"><a href="#ViewContainerRef-用于表示一个视图容器，可添加一或多个视图，通过ViewContainerRef实例，可以基于TemplateRef创建内嵌视图，并指定插入位置，主要创建管理内嵌视图" class="headerlink" title="ViewContainerRef: 用于表示一个视图容器，可添加一或多个视图，通过ViewContainerRef实例，可以基于TemplateRef创建内嵌视图，并指定插入位置，主要创建管理内嵌视图"></a>ViewContainerRef: 用于表示一个视图容器，可添加一或多个视图，通过ViewContainerRef实例，可以基于TemplateRef创建内嵌视图，并指定插入位置，主要创建管理内嵌视图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template #tpl&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">@ViewChild(&apos;tpl&apos;) tplRef: TemplateRef&lt;any&gt;;</span><br><span class="line">@ViewChild(&apos;tpl&apos;, &#123; read: ViewContainerRef &#125;) tplVcRef: ViewContainerRef;</span><br><span class="line">ngAfterViewInit()&#123;</span><br><span class="line">    this.tplVcRef.createEmbeddedView(this.tplRef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意：-ViewChild属性装饰器若未设置read属性，默认返回ElementRef对象实例"><a href="#注意：-ViewChild属性装饰器若未设置read属性，默认返回ElementRef对象实例" class="headerlink" title="注意：@ViewChild属性装饰器若未设置read属性，默认返回ElementRef对象实例"></a>注意：@ViewChild属性装饰器若未设置read属性，默认返回ElementRef对象实例</h3><font face="黑体" color="#f00" size="4">指令的一般应用场景</font>

<h4 id="分类：内置指令，-自定义指令"><a href="#分类：内置指令，-自定义指令" class="headerlink" title="分类：内置指令， 自定义指令"></a>分类：内置指令， 自定义指令</h4><h4 id="主要考虑自定义指令的属性指令与结构指令"><a href="#主要考虑自定义指令的属性指令与结构指令" class="headerlink" title="主要考虑自定义指令的属性指令与结构指令"></a>主要考虑自定义指令的属性指令与结构指令</h4><h3 id="自定义属性指令实现简写"><a href="#自定义属性指令实现简写" class="headerlink" title="自定义属性指令实现简写"></a>自定义属性指令实现简写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Directive(&#123;</span><br><span class="line">    selector: &apos;[directivename]&apos;  // 这里定义的selector为什么使用中括号，是为了结合input装饰器获取属性值</span><br><span class="line">&#125;)</span><br><span class="line">export class SomeDirective &#123;</span><br><span class="line">    private _default = &apos;[someValue]&apos; // 旨在指令类内部定义默认值</span><br><span class="line">    @Input(directivename) directiveAnotherName;  // 输入属性</span><br><span class="line">    constructor(private el: ElementRef, private renderer: Renderer)&#123; // 引用类实例化，其中renderer对象提供许多api供渲染元素</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @HostListener(eventName) eventName()&#123;  // 监听宿主元素事件</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &lt;h1 [changeColor]=&quot;&apos;red&apos;&quot;&gt;&lt;/h1&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义结构指令是实现简写"><a href="#自定义结构指令是实现简写" class="headerlink" title="自定义结构指令是实现简写"></a>自定义结构指令是实现简写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Directive(&#123;</span><br><span class="line">    selector: &apos;[directivename]&apos;  // 这里定义的selector为什么使用中括号，是为了结合input装饰器获取属性值</span><br><span class="line">&#125;)</span><br><span class="line">export class SomeDirective &#123;</span><br><span class="line">    @Input(directivename)  </span><br><span class="line">    set condition(newCondition: boolean) &#123;  // 这里用了getter、setter存取器, 进行属性值的动态监听</span><br><span class="line">        if(newCondition)&#123;</span><br><span class="line">            this.tplVc.createEmbeddedView(this.tpl); // 创建内嵌视图,可以设置第二个参数&#123;$implicit: somevalue&#125;, 则angular提供了let模板语法，允许在生成的上下文是定义和传递</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            this.tplVc.clear();  // 清除内嵌视图</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(private tpf: TemplateRef, private tplVc: VireContainerRef)&#123; // 引用类实例化，用于创建内嵌视图</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &lt;h1 *structureDirective = true&gt;&lt;/h1&gt; // 这里用了angular结构性指令的语法糖，原理同*ngIf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结以上属性指令与结构指令"><a href="#总结以上属性指令与结构指令" class="headerlink" title="总结以上属性指令与结构指令"></a>总结以上属性指令与结构指令</h3><p><em>1 ElementRef与Renderer等的作用：支持跨平台，从底层封住，统一了api接口;
</em>2 TemplateRef与ViewContainerRef的作用： 前面有总结过他俩的作用;<br>*3 angular2中指令与组件的关系：组件继承与指令，并扩展了与视图的关系</p>
<h3 id="自定义debounceClick指令"><a href="#自定义debounceClick指令" class="headerlink" title="自定义debounceClick指令"></a>自定义debounceClick指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Directive(&#123;</span><br><span class="line">    selector: &apos;[directiveDebounceClick]&apos;</span><br><span class="line">&#125;)</span><br><span class="line">export class SomeDirective &#123;</span><br><span class="line">    @Input(&apos;debounceTime&apos;) debounceTime: string;</span><br><span class="line">    @Output(&apos;debounceClick&apos;)  debounceClick = new EventEmitter();</span><br><span class="line">    private clicks = new Subject&lt;any&gt;();  // 定义subject处理点击事件</span><br><span class="line">    constructor()&#123; &#125;</span><br><span class="line">    @HostListener(&apos;click&apos;,[&apos;$event&apos;])  // 监听宿主元素上的点击事件，第二个参数用于将事件传递给eventClick方法</span><br><span class="line">    eventClick(event)&#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">        event.stopPropagation();  // 阻止事件默认行为与事件冒泡</span><br><span class="line">        this.clicks.next(event);  // 发送新值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngOnInit()&#123;</span><br><span class="line">        this.clicks.debounceTime(this.debounceTime) // 去抖动,时间自定义</span><br><span class="line">        .subscribe(x =&gt; this.debounceClick.emit(x)); // 调用emit方法发出事件</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &lt;button directiveDebounceClick [debounceTime] =&apos;300&apos; (debounceClick)=&quot;log($event)&quot;&gt;&lt;/button&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font face="黑体" color="#f00" size="4">ng-content包装器</font>

<h4 id="如果你尝试在-Angular-中编写可重复使用的组件，则可能会接触到内容投射的概念"><a href="#如果你尝试在-Angular-中编写可重复使用的组件，则可能会接触到内容投射的概念" class="headerlink" title="如果你尝试在 Angular 中编写可重复使用的组件，则可能会接触到内容投射的概念:"></a>如果你尝试在 Angular 中编写可重复使用的组件，则可能会接触到内容投射的概念:<ng-content></ng-content></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;wrapper&apos;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">      &lt;ng-content&gt;&lt;/ng-content&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line">class Wrapper &#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;wrapper&apos;,</span><br><span class="line">  template: `</span><br><span class="line">  &lt;div class=&quot;box red&quot;&gt;</span><br><span class="line">    &lt;ng-content&gt;&lt;/ng-content&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;box blue&quot;&gt;</span><br><span class="line">    &lt;ng-content select=&quot;counter&quot;&gt;&lt;/ng-content&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  `,</span><br><span class="line">  styles: [`</span><br><span class="line">    .red &#123;background: red;&#125;</span><br><span class="line">    .blue &#123;background: blue;&#125;</span><br><span class="line">  `]</span><br><span class="line">&#125;)</span><br><span class="line">export class Wrapper &#123; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="将包装器的不同子项投影到模板的不同部分。-支持一个-select-属性，可以让你在特定的地方投射具体的内容。该属性支持-CSS-选择器（my-element，-my-class，-my-attribute-，…）来匹配你想要的内容。如果-ng-content-上没有设置-select-属性，它将接收全部内容，或接收不匹配任何其他-ng-content-元素的内容。"><a href="#将包装器的不同子项投影到模板的不同部分。-支持一个-select-属性，可以让你在特定的地方投射具体的内容。该属性支持-CSS-选择器（my-element，-my-class，-my-attribute-，…）来匹配你想要的内容。如果-ng-content-上没有设置-select-属性，它将接收全部内容，或接收不匹配任何其他-ng-content-元素的内容。" class="headerlink" title="将包装器的不同子项投影到模板的不同部分。 支持一个 select 属性，可以让你在特定的地方投射具体的内容。该属性支持 CSS 选择器（my-element，.my-class，[my-attribute]，…）来匹配你想要的内容。如果 ng-content 上没有设置 select 属性，它将接收全部内容，或接收不匹配任何其他 ng-content 元素的内容。"></a>将包装器的不同子项投影到模板的不同部分。<ng-content> 支持一个 select 属性，可以让你在特定的地方投射具体的内容。该属性支持 CSS 选择器（my-element，.my-class，[my-attribute]，…）来匹配你想要的内容。如果 ng-content 上没有设置 select 属性，它将接收全部内容，或接收不匹配任何其他 ng-content 元素的内容。</ng-content></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;wrapper&gt;</span><br><span class="line">  &lt;span&gt;This is not a counter&lt;/span&gt;</span><br><span class="line">  &lt;counter&gt;&lt;/counter&gt;</span><br><span class="line">&lt;/wrapper&gt;</span><br></pre></td></tr></table></figure>
<h4 id="counter组件被正确投影到第二个蓝色框中，而-span-元素最终会在全部红色框中。"><a href="#counter组件被正确投影到第二个蓝色框中，而-span-元素最终会在全部红色框中。" class="headerlink" title="counter组件被正确投影到第二个蓝色框中，而 span 元素最终会在全部红色框中。"></a>counter组件被正确投影到第二个蓝色框中，而 span 元素最终会在全部红色框中。</h4><h2 id="ngProjectAs"><a href="#ngProjectAs" class="headerlink" title="ngProjectAs"></a>ngProjectAs</h2><h4 id="内部组件会被隐藏在另一个更大的组件中。你只需要将其包装在额外的容器中即可应用-ngIf-或-ngSwitch。无论什么原因，通常情况下，你的内部组件不是包装器的直接子节点。所以需要使用ngProjectAs属性，将它用于指定的元素上。"><a href="#内部组件会被隐藏在另一个更大的组件中。你只需要将其包装在额外的容器中即可应用-ngIf-或-ngSwitch。无论什么原因，通常情况下，你的内部组件不是包装器的直接子节点。所以需要使用ngProjectAs属性，将它用于指定的元素上。" class="headerlink" title="内部组件会被隐藏在另一个更大的组件中。你只需要将其包装在额外的容器中即可应用 ngIf 或 ngSwitch。无论什么原因，通常情况下，你的内部组件不是包装器的直接子节点。所以需要使用ngProjectAs属性，将它用于指定的元素上。"></a>内部组件会被隐藏在另一个更大的组件中。你只需要将其包装在额外的容器中即可应用 ngIf 或 ngSwitch。无论什么原因，通常情况下，你的内部组件不是包装器的直接子节点。所以需要使用ngProjectAs属性，将它用于指定的元素上。</h4><font face="黑体" color="#f00" size="3">表单自定义验证规则</font>

<h4 id="举例：邮件匹配"><a href="#举例：邮件匹配" class="headerlink" title="举例：邮件匹配"></a>举例：邮件匹配</h4><p>定义用户类型接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export interface User &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    account: &#123;</span><br><span class="line">        email: string;</span><br><span class="line">        confirm: string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>邮件匹配规则函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export const emailMatcher = (control: AbstractControl): &#123;[key: string]: boolean&#125; =&gt; &#123;</span><br><span class="line">   const email = control.get(&apos;email&apos;);</span><br><span class="line">   const confirm = control.get(&apos;confirm&apos;);</span><br><span class="line">   if (!email || !confirm)&#123;</span><br><span class="line">       return;</span><br><span class="line">   &#125;</span><br><span class="line">   return email.value === confirm.value ? null : &#123; nomatch: true &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>表单模版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, OnInit&#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; FormBuilder, FormGroup, Validators &#125; from &apos;@angular/forms&apos;;</span><br><span class="line">import &#123; emailMatcher &#125; from &apos;./email-matcher&apos;;</span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;signup=form&apos;,</span><br><span class="line">    template: `</span><br><span class="line">        &lt;form novalidate (ngSubmit)=&quot;onSubmit(user)&quot; [formGroup]=&quot;user&quot;&gt;</span><br><span class="line">            &lt;label&gt;</span><br><span class="line">               name...</span><br><span class="line">            &lt;/label&gt;</span><br><span class="line">            &lt;div *ngIf=&quot;user.get(&apos;name&apos;).touched &amp;&amp; user.get(&apos;name&apos;).hasError(&apos;required&apos;)&quot;&gt;</span><br><span class="line">                name is required</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div formGroupName = &quot;account&quot;&gt;</span><br><span class="line">                &lt;label&gt;</span><br><span class="line">                    &lt;span&gt;Email address&lt;/span&gt;</span><br><span class="line">                    &lt;input type=&quot;email&quot; placeholder=&quot;Your email address&quot; formControlName=&quot;email&quot;&gt;</span><br><span class="line">                &lt;/label&gt;</span><br><span class="line">                &lt;label&gt;</span><br><span class="line">                    &lt;span&gt;Confirm address&lt;/span&gt;</span><br><span class="line">                    &lt;input type=&quot;email&quot; placeholder=&quot;Confirm your email address&quot; formControlName=&quot;confirm&quot;&gt;</span><br><span class="line">                &lt;/label&gt;</span><br><span class="line">                &lt;div *ngIf=&quot;user.get(&apos;account&apos;).touched &amp;&amp; user.get(&apos;name&apos;).hasError(&apos;nomatch&apos;)&quot;&gt;</span><br><span class="line">                    name is required</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;button type=&quot;submit&quot; [disabled]=&quot;user.invalid&quot;&gt;Sign up&lt;/button&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br><span class="line">export class SignUpFormCOmponent implements OnInit &#123;</span><br><span class="line">    user: FormGroup;</span><br><span class="line">    constructor(private fb: FormBuilder)&#123;&#125;</span><br><span class="line">    ngOnInit() &#123;</span><br><span class="line">        this.user = this.fb.group(&#123;</span><br><span class="line">            name: [&apos;&apos;, Validators.required],</span><br><span class="line">            account: this.fb.group(&#123;</span><br><span class="line">                email: [&apos;&apos;, Validators.required],</span><br><span class="line">                confirm: [&apos;&apos;, Validators.rquired],</span><br><span class="line">            &#125;, &#123;validator: emailMatcher&#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<font face="黑体" color="#f00" size="3">对比创建表单自定义验证指令</font>

<p>模版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name=&quot;password&quot; formControlName=&quot;password&quot; validateEqual=&quot;password&quot;&gt;</span><br><span class="line">&lt;input name=&quot;confirmpassword&quot; formControlName=&quot;confirmpassword&quot; validateEqual=&quot;password&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>validateEqual指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Directive, forwardRef, Attribute &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; Validator, AbstractControl, NG_VALIDATORS &#125; from &apos;@angular/forms&apos;;</span><br><span class="line">@DIrective(&#123;</span><br><span class="line">    selector: &apos;[validateEqual][formControlName], [validateEqual][formControl],[validateEqual][ngModel]&apos; ,</span><br><span class="line">    providers: [&#123;</span><br><span class="line">        provide: NG_VALIDATORS,</span><br><span class="line">        useExisting: forward(() =&gt; EqualValidator),</span><br><span class="line">        multi: true</span><br><span class="line">    &#125;]</span><br><span class="line">    扩展</span><br><span class="line">&#125;)</span><br><span class="line">export class EqualValidator implements Validator &#123;</span><br><span class="line">    constructor(@Attribute(&apos;validateEqual&apos;) public validateEqual: string)&#123;&#125;</span><br><span class="line">    validate(control: AbstractControl): &#123; [key:string]: boolean &#125; &#123;</span><br><span class="line">        let v  = control.value;  使用指令的控件自身值: confirmpassword</span><br><span class="line">        let e  = control.root.get(this.validateEqual);  指令指定的控件: passwordControl;</span><br><span class="line">        if (e &amp;&amp; v !== e.value) &#123;</span><br><span class="line">            return &#123; validateEqual: false&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="验证器添加到指定控件，造成只有该控件数值变化才会进行验证，先输入confirmPassword造成验证器失效，需要给验证器添加reverse属性"><a href="#验证器添加到指定控件，造成只有该控件数值变化才会进行验证，先输入confirmPassword造成验证器失效，需要给验证器添加reverse属性" class="headerlink" title="验证器添加到指定控件，造成只有该控件数值变化才会进行验证，先输入confirmPassword造成验证器失效，需要给验证器添加reverse属性"></a>验证器添加到指定控件，造成只有该控件数值变化才会进行验证，先输入confirmPassword造成验证器失效，需要给验证器添加reverse属性</h4><h3 id="Forward-Reference"><a href="#Forward-Reference" class="headerlink" title="Forward Reference"></a>Forward Reference</h3><h4 id="不论es6、es7、还是ts作为开发语言，现阶段最终都会编译为es5的代码。es5中只有function并没有class。造成js代码编译阶段只有变量声明和函数声明会自动提升，而函数表达式并不会自动提升。所以要解决此问题可以使用Angular2提供的forward-reference特性进行解决-Buffer顺序在Socket之前声明也可以，但是angular项目中模块组件化开发确认注入依赖的顺序性会带来更大负担-。"><a href="#不论es6、es7、还是ts作为开发语言，现阶段最终都会编译为es5的代码。es5中只有function并没有class。造成js代码编译阶段只有变量声明和函数声明会自动提升，而函数表达式并不会自动提升。所以要解决此问题可以使用Angular2提供的forward-reference特性进行解决-Buffer顺序在Socket之前声明也可以，但是angular项目中模块组件化开发确认注入依赖的顺序性会带来更大负担-。" class="headerlink" title="不论es6、es7、还是ts作为开发语言，现阶段最终都会编译为es5的代码。es5中只有function并没有class。造成js代码编译阶段只有变量声明和函数声明会自动提升，而函数表达式并不会自动提升。所以要解决此问题可以使用Angular2提供的forward reference特性进行解决(Buffer顺序在Socket之前声明也可以，但是angular项目中模块组件化开发确认注入依赖的顺序性会带来更大负担)。"></a>不论es6、es7、还是ts作为开发语言，现阶段最终都会编译为es5的代码。es5中只有function并没有class。造成js代码编译阶段只有变量声明和函数声明会自动提升，而函数表达式并不会自动提升。所以要解决此问题可以使用Angular2提供的forward reference特性进行解决(Buffer顺序在Socket之前声明也可以，但是angular项目中模块组件化开发确认注入依赖的顺序性会带来更大负担)。</h4><font face="黑体" color="#f00" size="3">es6+中的class不进行自动提升主要为了解决继承父类时，父类不可用的问题</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; forwardRef, Injectable &#125; from &apos;@angular2/core&apos;</span><br><span class="line">@Injectable()</span><br><span class="line">class Socket &#123;</span><br><span class="line">    constructor(@Inject(forwardRef(() =&gt; Buffer)) private buffer) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Buffer &#123;</span><br><span class="line">    constructor(@Inject(BUFFER_SIZE) private size: Number) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="OpaqueToken"><a href="#OpaqueToken" class="headerlink" title="OpaqueToken"></a>OpaqueToken</h3><h4 id="OpaqueToken允许创建基于字符串的Token类-在Provider中使用。只需导入Opaque类。"><a href="#OpaqueToken允许创建基于字符串的Token类-在Provider中使用。只需导入Opaque类。" class="headerlink" title="OpaqueToken允许创建基于字符串的Token类,在Provider中使用。只需导入Opaque类。"></a>OpaqueToken允许创建基于字符串的Token类,在Provider中使用。只需导入Opaque类。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; OpaqueToken &#125; from &apos;@angular/core&apos;;</span><br><span class="line">const CONFIG_TOKEN = new OpaqueToken(&apos;config&apos;);</span><br><span class="line">export const THIRDPARTYLIBPROVIDERS = [</span><br><span class="line">    &#123;</span><br><span class="line">        provide: CONFIG_TOKEN, useClass: ThirdPartyConfig</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>OpaqueToken类的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export class OpaqueToken &#123;</span><br><span class="line">    constructor(protected _desc: string) &#123;&#125;</span><br><span class="line">    toString() : string &#123;</span><br><span class="line">        return `Token$&#123;this._desc&#125;`</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>OpaqueToken类的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ReflectiveInjector, OpaquToken &#125; from &apos;@angular/core&apos;;</span><br><span class="line">const t = new OpaquToken(&apos;value&apos;);</span><br><span class="line">const injector = ReflectiveInjector.resolveAndCreate([</span><br><span class="line">    &#123;</span><br><span class="line">        provide: t,</span><br><span class="line">        useValue: &apos;bindingValue&apos;</span><br><span class="line">    &#125;</span><br><span class="line">]);</span><br><span class="line">injector.get(t)  // &apos;bindingValue&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="InjectionToken-Angular4"><a href="#InjectionToken-Angular4" class="headerlink" title="InjectionToken (Angular4+)"></a>InjectionToken (Angular4+)</h3><h4 id="使用ValueProvider"><a href="#使用ValueProvider" class="headerlink" title="使用ValueProvider"></a>使用ValueProvider</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@NgModule(&#123;</span><br><span class="line">    ...,</span><br><span class="line">    providers: [</span><br><span class="line">        &#123;</span><br><span class="line">            provide: &apos;apiUrl&apos;,</span><br><span class="line">            userValue: &apos;http://localhost:4200/heroes&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注入ProviderValue"><a href="#注入ProviderValue" class="headerlink" title="注入ProviderValue"></a>注入ProviderValue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Injectable()</span><br><span class="line">export class HeroService &#123;</span><br><span class="line">    constructor(</span><br><span class="line">        private loggerService: LoggerService,</span><br><span class="line">        @Inject(&apos;apiUrl&apos;) private apiUrl: String</span><br><span class="line">    )&#123;</span><br><span class="line">        console.log(apiUrl)  //  http://localhost:4200/heroes</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果引入了第三方库且名称相同就产生了问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export const THIRD_PARTY_PROVIDERS = [</span><br><span class="line">    &#123;</span><br><span class="line">        provide: &apos;apiUrl&apos;,   //  与localhost:4200相同</span><br><span class="line">        userValue: &apos;http://192.168.18.59:4200&apos;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>更新Provider配置信息则如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; THIRD_PARTY_PROVIDERS &#125; from &apos;./third-party&apos;;</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">    ...,</span><br><span class="line">    providers: [</span><br><span class="line">        &#123;</span><br><span class="line">        provide: &apos;apiUrl&apos;,</span><br><span class="line">        useValue: &apos;http://localhost:4200/heros&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        THIRD_PARTY_PROVIDERS</span><br><span class="line">    ],</span><br><span class="line">    bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<font face="黑体" color="#f00" size="3">localhost:4200被覆盖</font>

<h4 id="使用字符串作为Token起冲突了。所以利用InjectionToken-Angular4-统一管理Token信息。"><a href="#使用字符串作为Token起冲突了。所以利用InjectionToken-Angular4-统一管理Token信息。" class="headerlink" title="使用字符串作为Token起冲突了。所以利用InjectionToken(Angular4+)统一管理Token信息。"></a>使用字符串作为Token起冲突了。所以利用InjectionToken(Angular4+)统一管理Token信息。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; InjectionToken &#125; from &apos;@angular/core&apos;;</span><br><span class="line">export const API_URL = new InjectionToken&lt;string&gt;(&apos;apiUrl&apos;);</span><br></pre></td></tr></table></figure>
<h4 id="OpaqueToken-与-InjectionToken-异同点"><a href="#OpaqueToken-与-InjectionToken-异同点" class="headerlink" title="OpaqueToken 与 InjectionToken 异同点"></a>OpaqueToken 与 InjectionToken 异同点</h4><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ul>
<li>创建可在Provider中使用的Token</li>
</ul>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul>
<li>前者ng2的类，后者ng4+引入的类，继承自OpaqueToken，且引入了泛型用于定义所关联的依赖对象的类型</li>
</ul>
<h2 id="Es6-Set-Map"><a href="#Es6-Set-Map" class="headerlink" title="Es6 Set Map"></a>Es6 Set Map</h2><h3 id="Es6提供了新的数据结构Set。类似于数组，但是成员都是唯一的，没有重复的值。接受一个数组或类数组对象作为参数"><a href="#Es6提供了新的数据结构Set。类似于数组，但是成员都是唯一的，没有重复的值。接受一个数组或类数组对象作为参数" class="headerlink" title="Es6提供了新的数据结构Set。类似于数组，但是成员都是唯一的，没有重复的值。接受一个数组或类数组对象作为参数"></a>Es6提供了新的数据结构Set。类似于数组，但是成员都是唯一的，没有重复的值。接受一个数组或类数组对象作为参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set([1,2,3,4,2]);</span><br><span class="line">[...set]    // [1,2,3,4]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set();</span><br><span class="line">[1,2,2,2,3,4].map(x =&gt; set.add(x));</span><br><span class="line">set   // [1,2,3,4]</span><br></pre></td></tr></table></figure>
<h4 id="Set内部，两个对象不相等，两个NaN相等，用length检测-可以用for…of遍历"><a href="#Set内部，两个对象不相等，两个NaN相等，用length检测-可以用for…of遍历" class="headerlink" title="Set内部，两个对象不相等，两个NaN相等，用length检测,可以用for…of遍历"></a>Set内部，两个对象不相等，两个NaN相等，用length检测,可以用for…of遍历</h4><ul>
<li><p>add(value)</p>
</li>
<li><p>delete(value) </p>
</li>
<li><p>has(value)</p>
</li>
<li><p>clear()</p>
</li>
</ul>
<h3 id="Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键-初始化Map需要一个二维数组，或者直接初始化一个空Map"><a href="#Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键-初始化Map需要一个二维数组，或者直接初始化一个空Map" class="headerlink" title="Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键, 初始化Map需要一个二维数组，或者直接初始化一个空Map"></a>Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键, 初始化Map需要一个二维数组，或者直接初始化一个空Map</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);</span><br><span class="line">m.get(&apos;Michael&apos;); // 95</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map();</span><br><span class="line">var o = &#123;p: &quot;Hello World&quot;&#125;;</span><br><span class="line">m.set(o, &quot;content&quot;)</span><br><span class="line">m.get(o)    // &quot;content&quot;</span><br><span class="line">m.has(o)    // true</span><br><span class="line">m.delete(o) // true</span><br><span class="line">m.has(o)    // false</span><br></pre></td></tr></table></figure>
<font face="黑体" color="#f00" size="3">只有对同一个对象的引用，Map结构才视为同一个键</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var map = new Map();</span><br><span class="line">map.set([&apos;a&apos;], 555);</span><br><span class="line">map.get([&apos;a&apos;])   // undefined</span><br><span class="line">上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。</span><br></pre></td></tr></table></figure>
<h3 id="ModuleWithProviders"><a href="#ModuleWithProviders" class="headerlink" title="ModuleWithProviders"></a>ModuleWithProviders</h3><p>创建一个共享模块，包含部分功能性模块、管道、指令、和服务。对于服务，通常作为单例的服务可能被多次提供，可以通过在共享模块内部返回ModuleWithProviders对象的静态方法forRoot解决这类问题, (相对于将service注入在NgModule,通过forRoot方法返回具有NgModule属性的ModuleWithProviders对象，可以解决service多次提供的情况)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NgModule, ModuleWithProviders &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; someDirective, somePipe, someService &#125; from &apos;./functions&apos;;</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">    declarations: [</span><br><span class="line">        somePipe,</span><br><span class="line">        someDirective</span><br><span class="line">    ],</span><br><span class="line">    exports: [</span><br><span class="line">        somePipe,</span><br><span class="line">        someDirective </span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line">export class SharedModule &#123;</span><br><span class="line">    static forRoot() : ModuleWithProviders &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            ngModule: SharedModule,</span><br><span class="line">            providers: [ someService ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NgModule中并不提供服务，在模块类中定义forRoot静态方法，返回ModuleWithProviders接口对象，在应用模块中导入共享模块并调用静态方法forRoot来提供服务和其他指令管道等,这样根模块会把他得providers添加到根模块的服务提供商中，确切的说是angular会先累加所有的显式注入的提供商，然后进一步追加其他模块的提供商到@NgModule.providers中，可以确保显式添加的提供商优先级大于从其他模块导入的；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; SharedModule &#125; from &apos;./shared&apos;</span><br><span class="line">//:...</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">    imports: [</span><br><span class="line">        SharedModule.forRoot()</span><br><span class="line">    ],</span><br><span class="line">    //:...</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>不调用forRoot方法则会只访问共享的管道和指令，不在提供服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; SharedModule &#125; from &apos;./shared&apos;</span><br><span class="line">//:...</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">    imports: [</span><br><span class="line">        SharedModule、</span><br><span class="line">    ],</span><br><span class="line">    //:...</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123;&#125;</span><br></pre></td></tr></table></figure>
<font face="黑体" color="#f00" size="3">Angular2中没有模块级别的service,所有在NgModule中声明的Provider都是注册在跟级别的DI中</font>

<h3 id="shadow-DOM-选择器"><a href="#shadow-DOM-选择器" class="headerlink" title="shadow DOM 选择器"></a>shadow DOM 选择器</h3><p>使用emulated进行样式隔离时，可以访问适用于shadow DOM的css选择器</p>
<h4 id="宿主"><a href="#宿主" class="headerlink" title="宿主"></a>宿主</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:host &#123;</span><br><span class="line">    color: red;    // &lt;song-track&gt;</span><br><span class="line">&#125;</span><br><span class="line">:host(.selected) &#123;</span><br><span class="line">    color: red;    // &lt;song-track class=&quot;selected&quot;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="样式依赖于祖先元素"><a href="#样式依赖于祖先元素" class="headerlink" title="样式依赖于祖先元素"></a>样式依赖于祖先元素</h4><p>它会在组件的宿主元素的祖先元素中查找汽配的祖先元素直到文档的根</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:host-content(.selected) &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">:host-content(#selected) &#123;</span><br><span class="line">    color: red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="宿主元素或后代元素-跨边界"><a href="#宿主元素或后代元素-跨边界" class="headerlink" title="宿主元素或后代元素(跨边界)"></a>宿主元素或后代元素(跨边界)</h4><p>它会覆盖任何封装的宿主元素或者其子元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:host /deep/ .selected&#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">:host &gt;&gt;&gt; .selected&#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font face="黑体" color="#f00" size="3">angular-cli 启动的项目使用deep而不是&gt;&gt;&gt;</font>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/28/自定义表单/" itemprop="url">
                  自定义表单
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-12-28T13:47:16+08:00" content="2017-12-28">
              2017-12-28
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ControlValueAccessor"><a href="#ControlValueAccessor" class="headerlink" title="ControlValueAccessor"></a>ControlValueAccessor</h2><h3 id="它是一个接口用于连接表单模型和视图，自定义表单必须实现这个接口，来实现模型与视图的映射关系"><a href="#它是一个接口用于连接表单模型和视图，自定义表单必须实现这个接口，来实现模型与视图的映射关系" class="headerlink" title="它是一个接口用于连接表单模型和视图，自定义表单必须实现这个接口，来实现模型与视图的映射关系"></a>它是一个接口用于连接表单模型和视图，自定义表单必须实现这个接口，来实现模型与视图的映射关系</h3><p>Angular引入它的原因在于不同的输入控件更新数据方式不同，input或checkbox,但是可以通过ControlValueAccessor统一</p>
<ul>
<li><p>DefaultValueAccessor - text/textarea类型</p>
</li>
<li><p>SelectControlValueAccessor - selec类型</p>
</li>
<li><p>CheckboxControlValueAccessor - checkbox类型</p>
</li>
</ul>
<h2 id="实现ControlValueAccessor接口"><a href="#实现ControlValueAccessor接口" class="headerlink" title="实现ControlValueAccessor接口"></a>实现ControlValueAccessor接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export interface ControlValueAccessor &#123;</span><br><span class="line">    writeValue(obj: any): void;     // 将模型中的新值写入视图</span><br><span class="line">    registerOnChange(fn: any): void;    // 当控件接收到change事件后，调用的函数，通知外部组件发生变化</span><br><span class="line">    registerOnTouched(fn: any): void;    // 接收到touched事件后调用的函数</span><br><span class="line">    setDisabledState?(isDisabled: boolean): void;    // 当控件状态变成DISABLED或ENABLE时，调用该函数启用或禁用dom</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component(...)</span><br><span class="line">class CounterComponent implements ControlValueAccessor &#123;</span><br><span class="line">    ...</span><br><span class="line">    propagateChange = (_: any) =&gt; &#123;&#125;;</span><br><span class="line">    registerOnChange(fn: any) &#123;</span><br><span class="line">        this.propagateChange = fn;   //  view层的值发生改变，通知外部</span><br><span class="line">    &#125;</span><br><span class="line">    registerOnTouched...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注册成为表单控件"><a href="#注册成为表单控件" class="headerlink" title="注册成为表单控件"></a>注册成为表单控件</h2><ul>
<li><p>NG_VALUE_ACCESSOR: token类型为ControlValueAccessor,将控件本身注册到DI框架，使其可以被表单访问</p>
</li>
<li><p>NG_VALIDTORS: 将控件注册成为一个可以让表单得到其验证状态的控件，token为function或Validator,配合useExisting可以让控件只暴露出对应的function或Validator的validate方法</p>
</li>
<li><p>forwardRef: 向前引用，允许我们引用一个尚未定义的对象</p>
</li>
<li><p>multi: 设置为true,该token对应多个依赖项，使用相同的token获取依赖项的时候，获取的是已注册的依赖对象列表。如果不是true,那么对于相同的token的提供商来说，后定义的提供商会覆盖前面定义的</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;exe-demo&apos;,</span><br><span class="line">    ...</span><br><span class="line">    provides: [</span><br><span class="line">             // 创建Token为NG_VALUE_ACCESSOR的提供商</span><br><span class="line">        &#123;</span><br><span class="line">            provide: NG_VALUE_ACCESSOR,</span><br><span class="line">            useExisting: forwardRef(() =&gt; SomeComponent),</span><br><span class="line">            multi: true</span><br><span class="line">        &#125;,</span><br><span class="line">             // 创建Token为NG_VALIDATORS的表单验证验证器</span><br><span class="line">        &#123;</span><br><span class="line">            provide: NG_VALIDATORS,</span><br><span class="line">            useValue: validateCounterRange,</span><br><span class="line">            multi: true</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, forwardRef , Input &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; ControlValueAccessor, NG_VALUE_ACCESSOR, NG_VALIDATORS, </span><br><span class="line">FormControl, ValidatorFn, ValidationErrors, AbstractControl &#125; from &apos;@angular/forms&apos;;</span><br><span class="line">export const EXE_COUNTER_VALUE_ACCESSOR: any = &#123;</span><br><span class="line">    provide: NG_VALUE_ACCESSOR,</span><br><span class="line">    useExisting: forwardRef(() =&gt; CounterComponent),</span><br><span class="line">    multi: true</span><br><span class="line">&#125;</span><br><span class="line">export const validateCounterRange: ValidatorFn = (control: AbstractControl) : ValidationErrors =&gt; &#123;</span><br><span class="line">   return ( control.value &gt; 10 || control.value &lt; 0 ) ? </span><br><span class="line">   &#123;</span><br><span class="line">       &apos;rangeError&apos;: &#123; current: control.value, max: 10, min: 0&#125;</span><br><span class="line">   &#125; : null</span><br><span class="line">&#125;</span><br><span class="line">export const EXE_COUNTER_VALIDATOR = &#123;</span><br><span class="line">    provide: NG_VALIDATORS,</span><br><span class="line">    useValue: validateCounterRange,  </span><br><span class="line">    multi: true</span><br><span class="line">&#125;</span><br><span class="line">@Component(&#123;</span><br><span class="line">    ...</span><br><span class="line">    provides: [</span><br><span class="line">        EXE_COUNTER_VALUE_ACCESSOR,</span><br><span class="line">        EXE_COUNTER_VALIDATOR</span><br><span class="line">    ],</span><br><span class="line">    changeDetection: ChangeDetectionStrategy.OnPush</span><br><span class="line">&#125;)</span><br><span class="line">export class CounterComponent implements ControlValueAccessor &#123;</span><br><span class="line">    @Input() _count: number = 0;</span><br><span class="line">    get count() &#123;</span><br><span class="line">        return this._count;</span><br><span class="line">    &#125;</span><br><span class="line">    set count(value: number) &#123;</span><br><span class="line">        this._count = value;</span><br><span class="line">        this.propagateChange(this._count);</span><br><span class="line">    &#125;</span><br><span class="line">    propagateChange = (_: any) =&gt; &#123;&#125;;</span><br><span class="line">    writeValue(value: any) &#123;</span><br><span class="line">        if (value) &#123;</span><br><span class="line">            this.count = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    registerOnchange(fn: any) &#123;</span><br><span class="line">        this.propagateChange = fn;</span><br><span class="line">    &#125;</span><br><span class="line">    registerOnTouched(fn: any) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    increment() &#123;</span><br><span class="line">        this.count++;</span><br><span class="line">    &#125;</span><br><span class="line">    decrement() &#123;</span><br><span class="line">        this.count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在Angular中通过Provider来描述与Token相关联的依赖对象的创建方式，分为以下四种"><a href="#在Angular中通过Provider来描述与Token相关联的依赖对象的创建方式，分为以下四种" class="headerlink" title="在Angular中通过Provider来描述与Token相关联的依赖对象的创建方式，分为以下四种"></a>在Angular中通过Provider来描述与Token相关联的依赖对象的创建方式，分为以下四种</h3><ul>
<li><p>useClass</p>
</li>
<li><p>useValue</p>
</li>
<li><p>useExisting</p>
</li>
<li><p>useFactory</p>
</li>
</ul>
<p><img src="https://sfault-image.b0.upaiyun.com/299/404/2994048125-58cc9e6c17087_articlex" alt="relation"></p>
<font color="#f00">useClass</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">providers: [ </span><br><span class="line">    &#123; provide: ApiService, useClass: ApiService &#125;  // 简介写法直接 ApiService</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<font color="#f00">useValue</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">providers: [ </span><br><span class="line">    &#123; provide: API_URL, useValue: &apos;http://my.api.com/v1&apos; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<font color="#f00">useExisting</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">providers: [ </span><br><span class="line">    &#123; provide: &apos;ApiServiceAlias&apos;, useValue: ApiService &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<font color="#f00">useFactory</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export function configFactory(config: AppConfig) &#123;</span><br><span class="line">    return () =&gt; config.load();</span><br><span class="line">&#125;</span><br><span class="line">providers: [ </span><br><span class="line">    &#123; provide: APP_INITIALIZER, useFactory: configFactory,</span><br><span class="line">    deps: [AppConfig, multi: true] &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/15/12-15  日常笔记/" itemprop="url">
                  12-15  日常笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-12-15T10:30:16+08:00" content="2017-12-15">
              2017-12-15
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="日常遗忘知识点总结"><a href="#日常遗忘知识点总结" class="headerlink" title="日常遗忘知识点总结"></a>日常遗忘知识点总结</h2><h3 id="利用伪类实现自定义title"><a href="#利用伪类实现自定义title" class="headerlink" title="利用伪类实现自定义title"></a>利用伪类实现自定义title</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span mytitle=&quot;hello world&quot;&gt;Today is Friday&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">span[mytitle]:hover::after&#123;</span><br><span class="line">    content: attr(mytitle);</span><br><span class="line">    position: absolute;</span><br><span class="line">    right:0</span><br><span class="line">    color: #ff0;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="伪类清除浮动"><a href="#伪类清除浮动" class="headerlink" title="伪类清除浮动"></a>伪类清除浮动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;child1&quot; style=&quot;float:left;width:25%;&quot;&gt;&lt;/div&gt; </span><br><span class="line">    &lt;div class=&quot;child2&quot; style=&quot;float:right;width:25%;&quot;&gt;&lt;/div&gt; </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.parent::after&#123;</span><br><span class="line">    content: &apos;\0020&apos;;</span><br><span class="line">    height: 0;</span><br><span class="line">    display: block;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h3><blockquote>
<p>引自 <font color="#f00" size="3">大漠老师的文章，进行flex布局的学习与记录总结</font>  <a href="https://www.w3cplus.com/css3/understanding-flexbox-everything-you-need-to-know.html" target="_blank" rel="noopener">原文地址</a></p>
</blockquote>
<p>显式声明flex容器后，启动了一个flexbox格式化上下文。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ul&#123;</span><br><span class="line">    display: flex;   //或者inline-flex;</span><br><span class="line">    li &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        margin: 8px;</span><br><span class="line">        background-color: #8cacea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-6.png" alt="flex"></p>
<p>display显示设置了flex属性后，自身变为flex容器，子元素变为了flex项目。</p>
<font color="#f00">容器属性: flex-direction || flex-wrap || flex-flow || justify-content || align-items || align-content</font>

<h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ul&#123;</span><br><span class="line">    flex-direction: row || column || row-reverse || column-reverse;   // default: row</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>row: 从左向右水平<br>…</p>
<h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ul&#123;</span><br><span class="line">    flex-wrap: wrap || norwrap || wrap-reverse;   // default: nowrap(不换行)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果拥有大量子元素，会自适应每个元素的大小，全部注入到一行内，即使宽度大于视窗宽度出现滚动条（nowrap）</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-15.png" alt="nowrap"></p>
<p>显示默认宽度都行排列，不会强迫一行有多少个flex项目（wrap）</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-16.png" alt="wrap"></p>
<h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p>是flex-direction和flex-wrap属性的速记属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ul&#123;</span><br><span class="line">    flex-flow: row wrap;</span><br><span class="line">    相当于  // flex-direction: row; flex-wrap: wrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><font color="#f00">接受属性值: flex-start || flex-end || center || space-between || space-around</font>


<p>flex-start: 左对齐 （default）</p>
<p>flex-end: 右对齐</p>
<p>center: 居中对齐</p>
<p>space-between: 两端对齐(除了第一个和最后一个部分，间距相等)</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-24.jpeg" alt="space-between"></p>
<p>space-around: 让每个flex元素都具有相同的空间</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-26.jpeg" alt="space-between"></p>
<h4 id="align-items-（不同于justify-content，它处理的是容器的纵向排列）"><a href="#align-items-（不同于justify-content，它处理的是容器的纵向排列）" class="headerlink" title="align-items （不同于justify-content，它处理的是容器的纵向排列）"></a>align-items （不同于justify-content，它处理的是容器的纵向排列）</h4><font color="#f00">接受属性值: flex-start || flex-end || center || stretch || baseline</font>


<p>stretch: 所有flex元素高度和容器高度一样 （default）</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-27.png" alt="stretch"></p>
<p>flex-start: 顶部对齐</p>
<p>flex-end: 底部对齐</p>
<p>center: 居中对齐</p>
<p>baseline: 沿着自身的基线对齐</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-32.jpeg" alt="baseline"></p>
<h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p>添加大量子元素，让其多行排列，该属性用于控制多行排列的flex容器的排列方式，效果类似align-items，expect baseline</p>
<font color="#f00">接受属性值: flex-start || flex-end || center || stretch</font>


<p>stretch: 纵向适应可用空间 （default）</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-33.png" alt="stretch"></p>
<p>flex-start: 沿着顶部到底部排列</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-34.png" alt="flex-start"></p>
<p>flex-end: 沿着低部到顶部排列</p>
<p>center: 居中</p>
<h2 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="未完待续。。。"></a>未完待续。。。</h2><h2 id="12-18-继续flex布局要点学习"><a href="#12-18-继续flex布局要点学习" class="headerlink" title="12.18 继续flex布局要点学习"></a>12.18 继续flex布局要点学习</h2><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p>允许flex项目在flex容器内重新排序，默认值为0，可以接受负值</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-38.png" alt="order=0"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li:nth-child(1)&#123; </span><br><span class="line">    order: 1; /*设置一个比0更大的值*/ </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从低到高拍下</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-39.png" alt="order=1"></p>
<h4 id="flex-grow-flex-shrink"><a href="#flex-grow-flex-shrink" class="headerlink" title="flex-grow | flex-shrink"></a>flex-grow | flex-shrink</h4><p>控制flex项目在容器的空间上进行扩展; 接受0或者大于0的任何正数，默认为0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&lt;ul&gt; </span><br><span class="line">    &lt;li&gt;I am a simple list&lt;/li&gt; </span><br><span class="line">&lt;/ul&gt; </span><br><span class="line"></span><br><span class="line">ul &#123; </span><br><span class="line">    display: flex; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当把flex-grow设置为1的时候，填充多余空间</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-43.png" alt="flex-grow"></p>
<p>当有多个flex项目需要进行扩展比设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#main div:nth-of-type(1) &#123;flex-grow: 1;&#125;</span><br><span class="line">#main div:nth-of-type(2) &#123;flex-grow: 3;&#125;</span><br><span class="line">#main div:nth-of-type(3) &#123;flex-grow: 1;&#125;</span><br><span class="line">#main div:nth-of-type(4) &#123;flex-grow: 1;&#125;</span><br><span class="line">#main div:nth-of-type(5) &#123;flex-grow: 1;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/vernvn/hexoBlog/blob/master/decImg/222.png?raw=true" alt="flex-grow"></p>
<p>当把flex-shrink设置为大于1的时候，缩小flex项目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=&quot;flex&quot;&gt;</span><br><span class="line">    &lt;li&gt;a&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;b&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;c&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">flex &#123;display:flex;width:400px;margin:0;padding:0;list-style:none;&#125;</span><br><span class="line">flex li&#123;width:200px;&#125;</span><br><span class="line">flex li:nth-child(3)&#123;flex-shrink:3;&#125;</span><br></pre></td></tr></table></figure>
<p>flex-shrink默认值为1，接受正整数，压缩空间比,c显式的定义了flex-shrink，a,b没有显式定义，但将根据默认值1来计算，可以看到总共将剩余空间分成了5份，其中a占1份，b占1份，c占3分，即1:1:3<br>我们可以看到父容器定义为400px，子项被定义为200px，相加之后即为600px，超出父容器200px。那么这么超出的200px需要被a,b,c消化<br>通过收缩因子，所以加权综合可得200 <em> 1+200 </em> 1+200 <em> 3=1000px；<br>于是我们可以计算a,b,c将被移除的溢出量是多少：<br>a被移除溢出量：(200</em>1/1000)<em>200，即约等于40px<br>b被移除溢出量：(200</em>1/1000)<em>200，即约等于40px<br>c被移除溢出量：(200</em>3/1000)*200，即约等于120px<br>最后a,b,c的实际宽度分别为：200-40=160px, 200-40=160px, 200-120=80px</p>
<h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>初始化flex项目的大小。默认值auto.接受任何用于width的值。px | % | rem | em; 如果为0也需要加单位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li &#123;</span><br><span class="line">    flex-basis: 150px;   // 初始固定大小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="flex速记"><a href="#flex速记" class="headerlink" title="flex速记"></a>flex速记</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li&#123;</span><br><span class="line">    flex: 0 1 auto;  // flex-grow、flex-shrink、flex-basis </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p>改变一个弹性项目沿着侧轴的位置而不影响弹性项目</p>
<font color="#f0f">接受属性值: auto || flex-start || flex-end || center || stretch || baseline</font>

<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-55.png" alt="stretch"></p>
<font color="#f0f">auto为设置为父元素的align-items的值，若没有父元的话，设置为stretch</font>

<h3 id="绝对和相对flex项目"><a href="#绝对和相对flex项目" class="headerlink" title="绝对和相对flex项目"></a>绝对和相对flex项目</h3><p>二者区别在于间距的计算，相对flex项目的间距根据内容大小计算，绝对flex项目的间距根据flex属性计算，而不是内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li&#123;</span><br><span class="line">    flex: 1 1 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-59.png" alt="relative"></p>
<p>flex-basis: auto; 宽度自动计算; 此时为相对flex项目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li&#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex项目变为绝对的了，<font color="#f0f">宽度计算依据flex属性</font></p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-61.png" alt="relative"></p>
<p>flex-basis: 0;  基于flex-grow共享可用空间</p>
<font color="#f00" size="3">所有Flexbox属性都是基于合适的flex-direction起作用。</font>


<font color="#f0f" size="3">当在Flex项目上使用 margin: auto 时，值为 auto 的方向（左、右或者二者都是）会占据所有剩余空间</font>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/11/路由守卫及加载策略/" itemprop="url">
                  路由守卫及加载策略
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-12-11T17:18:16+08:00" content="2017-12-11">
              2017-12-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><p>任何时候导航到任何地方往往不能满足业务需求，需要授权守护。返回值是boolean的三种形式</p>
<ul>
<li>Observable<boolean></boolean></li>
<li>Promise<boolean></boolean></li>
<li>boolean</li>
</ul>
<p>往往同步守卫不是一个好的选择，阻塞的情况时常发生。如果返回true，导航继续，否则，导航终止，停留原地</p>
<h4 id="The-router-supports-multiple-guard-interfaces"><a href="#The-router-supports-multiple-guard-interfaces" class="headerlink" title="The router supports multiple guard interfaces:"></a>The router supports multiple guard interfaces:</h4><ul>
<li><a href="https://www.angular.cn/api/router/CanActivate" target="_blank" rel="noopener">CanActivate</a>: 导航到某路由</li>
<li><a href="https://www.angular.cn/api/router/CanActivateChild" target="_blank" rel="noopener">CanActivateChild</a>: 导航到某子路由</li>
<li><a href="https://www.angular.cn/api/router/CanDeactivate" target="_blank" rel="noopener">CanDeactivate</a>: 处理当前路由离开情况</li>
<li><a href="https://www.angular.cn/api/router/Resolve" target="_blank" rel="noopener">Resolve</a>: 激活前获取路由数据</li>
<li><a href="https://www.angular.cn/api/router/CanLoad" target="_blank" rel="noopener">Canload</a>: 异步导航特性模块</li>
</ul>
<h4 id="在分层路由的每个级别上，我们都可以设置多个守卫。-路由器会先按照从最深的子路由由下往上检查的顺序来检查CanDeactivate-和CanActivateChild-守卫。-然后它会按照从上到下的顺序检查CanActivate-守卫。-如果特性模块是异步加载的，在加载它之前还会检查CanLoad-守卫。-如果任何一个守卫返回false，其它尚未完成的守卫会被取消，这样整个导航就被取消了。"><a href="#在分层路由的每个级别上，我们都可以设置多个守卫。-路由器会先按照从最深的子路由由下往上检查的顺序来检查CanDeactivate-和CanActivateChild-守卫。-然后它会按照从上到下的顺序检查CanActivate-守卫。-如果特性模块是异步加载的，在加载它之前还会检查CanLoad-守卫。-如果任何一个守卫返回false，其它尚未完成的守卫会被取消，这样整个导航就被取消了。" class="headerlink" title="在分层路由的每个级别上，我们都可以设置多个守卫。 路由器会先按照从最深的子路由由下往上检查的顺序来检查CanDeactivate()和CanActivateChild()守卫。 然后它会按照从上到下的顺序检查CanActivate()守卫。 如果特性模块是异步加载的，在加载它之前还会检查CanLoad()守卫。 如果任何一个守卫返回false，其它尚未完成的守卫会被取消，这样整个导航就被取消了。"></a>在分层路由的每个级别上，我们都可以设置多个守卫。 路由器会先按照从最深的子路由由下往上检查的顺序来检查CanDeactivate()和CanActivateChild()守卫。 然后它会按照从上到下的顺序检查CanActivate()守卫。 如果特性模块是异步加载的，在加载它之前还会检查CanLoad()守卫。 如果任何一个守卫返回false，其它尚未完成的守卫会被取消，这样整个导航就被取消了。</h4><h3 id="特性模块的授权验证"><a href="#特性模块的授权验证" class="headerlink" title="特性模块的授权验证"></a>特性模块的授权验证</h3><p>匿名用户会重定向到登录页，因为区分用户是否授权，所以创建在根目录下(auth-guard.ts)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Injectable &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; CanActivate, Router, ActivatedRouteSnapshot, RouterStateSnapshot &#125; from &apos;@angular/rotuer&apos;;</span><br><span class="line">@Injectable()</span><br><span class="line">export class AuthGuard implements CanActivate &#123;</span><br><span class="line">   constructor(private router: Router) &#123;&#125;</span><br><span class="line">   canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) &#123;</span><br><span class="line">        let url = state.url;</span><br><span class="line">        return this.checkLogin(url);</span><br><span class="line">   &#125;</span><br><span class="line">   checkLogin(url: string): boolean &#123;</span><br><span class="line">       if (&apos;登录成功标识&apos;) &#123;</span><br><span class="line">           reutrn true;</span><br><span class="line">       &#125;</span><br><span class="line">       this.router.navigate([&apos;/login&apos;]);</span><br><span class="line">       return false</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="#f00" size="3">ActivatedRouteSnapshot包含即将被激活的路由，RouterStateSnapshot包含即将到达的状态</font>   

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; AuthGuard &#125; from &apos;../aut-guard.service&apos;;</span><br><span class="line">const routes : Routes = [</span><br><span class="line">    path: &apos;admin&apos;,</span><br><span class="line">    component: AdminComponent,</span><br><span class="line">    canActive: [AuthGuard],</span><br><span class="line">    ...</span><br><span class="line">]</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">    providers: [</span><br><span class="line">        AuthGuard</span><br><span class="line">    ],</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="CanActivateChild区别在于子路由被激活前的守卫"><a href="#CanActivateChild区别在于子路由被激活前的守卫" class="headerlink" title="CanActivateChild区别在于子路由被激活前的守卫"></a>CanActivateChild区别在于子路由被激活前的守卫</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; CanActivateChild &#125; from &apos;@angular/router&apos;;</span><br><span class="line">canActivateChild(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean &#123;</span><br><span class="line">    return this.canActivate(route, state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const routes : Routes = [</span><br><span class="line">    path: &apos;admin&apos;,</span><br><span class="line">    component: AdminComponent,</span><br><span class="line">    canActive: [AuthGuard],</span><br><span class="line">    children: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: &apos;&apos;,</span><br><span class="line">            canActivateChild: [AuthGuard],</span><br><span class="line">            children: [</span><br><span class="line">                ...</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="CanDeactivate-处理未保存的更改-不保存并离开-true-保留更改并留下-false"><a href="#CanDeactivate-处理未保存的更改-不保存并离开-true-保留更改并留下-false" class="headerlink" title="CanDeactivate 处理未保存的更改;不保存并离开(true),保留更改并留下(false)"></a>CanDeactivate 处理未保存的更改;不保存并离开(true),保留更改并留下(false)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">canDeactivate(): Observable&lt;boolean&gt; | promise&lt;boolean&gt; | boolean &#123;</span><br><span class="line">    if (!this.changeStatus) &#123; </span><br><span class="line">        return true;   //如果没有改变直接导航，否则弹框</span><br><span class="line">    &#125;</span><br><span class="line">    return this.someService.confirm(&apos;discard changes?&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &apos;:id&apos;,</span><br><span class="line">    component: CrisisDetailComponent,</span><br><span class="line">    canDeactivate: [CanDeactivateGuard]</span><br><span class="line">&#125;</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">    providers: [</span><br><span class="line">        CanDeactivateGuard</span><br><span class="line">    ],</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Resolve-预先获取数据"><a href="#Resolve-预先获取数据" class="headerlink" title="Resolve 预先获取数据"></a>Resolve 预先获取数据</h3><p>如果响应时间够长，就需要预先从服务器上获取数据，路由激活瞬间数据渲染完毕，此处需要Resolve守卫。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">resolve(route: activatedRouteSnapshot, state: RouterStateSnapshot):Observable&lt;any&gt;&#123;</span><br><span class="line">   const id = route.paramMap.get(&apos;id&apos;);</span><br><span class="line">   return this.someService.getDate(id).map(x =&gt; &#123;</span><br><span class="line">       if (x) &#123;</span><br><span class="line">           return x;</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           this.router.naviagte([&apos;./someWhere&apos;]);</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// 此处可以阻止路由被加载，直到数据获取完毕,如果没有数据获取则导航回指定路由，并且NgModule的providers中需要注册</span><br></pre></td></tr></table></figure>
<h3 id="异步路由"><a href="#异步路由" class="headerlink" title="异步路由"></a>异步路由</h3><p>异步路由可以在获取请求时惰性加载特性模块，并且带来了一下好处</p>
<ul>
<li>对于体积庞大的特性模块可以在用户请求时进行加载</li>
<li>持续扩充特性模块的功能，不用增加初始加载的体积及速度</li>
<li>模块化开发提升开发效率，结构分明</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &apos;admin&apos;,</span><br><span class="line">    loadChildren: &apos;app/admin/admin.module#AdminModule&apos;   // 相对于app目录</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="#f00" size="3">惰性加载只会发生一次，在该路由首次被请求时，后续的请求是立即可用的</font>

<h3 id="Canload守卫-保护对特性模块的未授权加载"><a href="#Canload守卫-保护对特性模块的未授权加载" class="headerlink" title="Canload守卫 保护对特性模块的未授权加载"></a>Canload守卫 保护对特性模块的未授权加载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">canload(route: Route): boolean &#123;</span><br><span class="line">    let url = `$&#123;route.path&#125;`;   // route为准备访问的目标地址</span><br><span class="line">    return this.checkLogin(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &apos;admin&apos;,</span><br><span class="line">    loadChildren: &apos;app/admin/admin.module#AdminModule&apos;,</span><br><span class="line">    canLoad: [AuthGuard]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="#f00" size="3">路由加载形式:立即加载、惰性加载、预加载</font>

<h4 id="预加载好比后台加载，在保证了尽可能小的初始加载体积和首屏加载速度的同时，同样满足了特性模块的按需加载-理想情况下，首屏加载完毕后会有一个短暂的空档期，如果此时完成了接下来将要访问的模块的加载成功，体验会有很大提高。此时的加载就是预加载。"><a href="#预加载好比后台加载，在保证了尽可能小的初始加载体积和首屏加载速度的同时，同样满足了特性模块的按需加载-理想情况下，首屏加载完毕后会有一个短暂的空档期，如果此时完成了接下来将要访问的模块的加载成功，体验会有很大提高。此时的加载就是预加载。" class="headerlink" title="预加载好比后台加载，在保证了尽可能小的初始加载体积和首屏加载速度的同时，同样满足了特性模块的按需加载;理想情况下，首屏加载完毕后会有一个短暂的空档期，如果此时完成了接下来将要访问的模块的加载成功，体验会有很大提高。此时的加载就是预加载。"></a>预加载好比后台加载，在保证了尽可能小的初始加载体积和首屏加载速度的同时，同样满足了特性模块的按需加载;理想情况下，首屏加载完毕后会有一个短暂的空档期，如果此时完成了接下来将要访问的模块的加载成功，体验会有很大提高。此时的加载就是预加载。</h4><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>导航完成后，路由器会查找没有加载但是可以加载的模块，此时预加载策略决定了是否加载以及加载哪些模块。</p>
<h4 id="Router内置了两种预加载策略"><a href="#Router内置了两种预加载策略" class="headerlink" title="Router内置了两种预加载策略"></a>Router内置了两种预加载策略</h4><ul>
<li>完全不预加载，默认</li>
<li>预加载所有特性模块: PreloadAllModules</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; PreloadAllModules, RouterModule &#125; from &apos;@angular/router&apos;</span><br><span class="line">RouterModule.forRoot(appRoutes, &#123;</span><br><span class="line">    preloadingStrategy: PreloadAllModules</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<font color="#f00" size="3">CanLoad守卫会阻塞预加载策略，优先级高于预加载策略</font>

<h3 id="自定义预加载策略"><a href="#自定义预加载策略" class="headerlink" title="自定义预加载策略"></a>自定义预加载策略</h3><p>结合路由定义时的data属性，只预加载preload为true的路由</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &apos;admin&apos;,</span><br><span class="line">    loadChildren: &apos;app/admin/admin.module#AdminModule&apos;,</span><br><span class="line">    data: &#123; preload: true &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加selective-preloading-strategy.ts,实现自定义预加载策略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; PreloadingStrategy , Route &#125; from &apos;@angular/router&apos;;</span><br><span class="line">@Injectable()</span><br><span class="line">export class SelectivePreloadingStrategy implements PreloadingStrategy &#123;</span><br><span class="line">    preloadModules: string[] = [];</span><br><span class="line">    preload(route: Route, load: () =&gt; Observable&lt;any&gt;) : Observable&lt;any&gt; &#123;</span><br><span class="line">        if (route.data &amp;&amp; route.data[&apos;preload&apos;]) &#123;</span><br><span class="line">            this.preloadModules.push(route.path);</span><br><span class="line">            return load();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Observable.of(null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如果要进行预加载，返回一个靠用加载器的Observable，否则返回一个null值的Observable对象。"><a href="#如果要进行预加载，返回一个靠用加载器的Observable，否则返回一个null值的Observable对象。" class="headerlink" title="如果要进行预加载，返回一个靠用加载器的Observable，否则返回一个null值的Observable对象。"></a>如果要进行预加载，返回一个靠用加载器的Observable，否则返回一个null值的Observable对象。</h4><h3 id="重定向迁移URL"><a href="#重定向迁移URL" class="headerlink" title="重定向迁移URL"></a>重定向迁移URL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; path: &apos;heroe/:id&apos;, redirectTo: &apos;/superHero/:id&apos;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RouterModule.forRoot(rotues, &#123; useHash: true &#125;) // 基于HashLocationStrategy</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/29/装饰器、泛型/" itemprop="url">
                  装饰器、泛型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-10-29T10:00:16+08:00" content="2017-10-29">
              2017-10-29
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><h3 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h3><p>LogComponent组件只为负责打印日志，通过log装饰器修饰printLog方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export class LogComponent &#123;</span><br><span class="line">    @log</span><br><span class="line">    printLog(str) &#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function log(target: Object, propertyKey: string, descriptor: TypedPropertyDescriptor&lt;any&gt;) &#123;</span><br><span class="line">    // descriptor is a object contains writable, enumberable, configurable, setter, getter, value;</span><br><span class="line">    let origin = descriptor.value;</span><br><span class="line">    descriptor.value = function (...args) &#123;  // apply方法</span><br><span class="line">        console.log(this); // LogComponent</span><br><span class="line">        let result = origin.apply(this, args);</span><br><span class="line">        console.log(&apos;Log is - &apos; + result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    return descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用场景： 可以在其他组件内继承LogComponent，也可以封装为一个service,服务于各个组件，职责单一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export class AppComponent extends LogComponent  implements OnInit &#123;</span><br><span class="line">    constructor(</span><br><span class="line">        private viewContainerRef: ViewContainerRef,</span><br><span class="line">        private renderer: Renderer2,</span><br><span class="line">        private elementRef: ElementRef,</span><br><span class="line">    ) &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line">    ngOnInit(): void &#123;</span><br><span class="line">        this.setupMenus();</span><br><span class="line">        this.printLog(&apos;test&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    printLog(str) &#123;</span><br><span class="line">        super.printLog(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Injectable()</span><br><span class="line">export class AppService &#123;</span><br><span class="line">    login( @Inject name: string) &#123; &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Inject(target: Object, propertyKey: string, parameterIndex: number) &#123;</span><br><span class="line">    console.log(propertyKey); // login 参数名称，注意是方法名</span><br><span class="line">    console.log(parameterIndex); // 0 参数索引</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型（Generic）"><a href="#泛型（Generic）" class="headerlink" title="泛型（Generic）"></a>泛型（Generic）</h2><p>集合类型如果设置为any可以实现同时支持多种类型，但是放弃了原本支持的类型检查，泛型则是为了解决这一点；帮助进行后面的类型检查</p>
<pre><code>class Name&lt;T&gt;{
    sayName(name:T): void{
        console.log(&apos; hello, i&apos;m &apos; + name);
    }
}
let user1 = new Name&lt;string&gt;();
user1.sayName(&apos;lee&apos;);

let user2 = new Name&lt;number&gt;();
user2.sayName(3);
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/12/常规面试总结2017/" itemprop="url">
                  常规面试总结2017
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-09-12T09:59:19+08:00" content="2017-09-12">
              2017-09-12
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常规面试总结2017"><a href="#常规面试总结2017" class="headerlink" title="常规面试总结2017"></a>常规面试总结2017</h1><h4 id="导语："><a href="#导语：" class="headerlink" title="导语："></a>导语：</h4><blockquote>
<p>在2017年对前端领域内的常见的问题进行系统性的总结，说法可能会有所不妥，会综合网上资源发表自己的见解</p>
</blockquote>
<h2 id="1-前端安全的理解与防范"><a href="#1-前端安全的理解与防范" class="headerlink" title="1.前端安全的理解与防范"></a>1.前端安全的理解与防范</h2><p>开发过程中不可避免的会出现漏洞，黑客会抓住漏洞去攻击它获取利益，所以我们需要让我们的应用变的更加安全。</p>
<h3 id="前端攻击有哪些形式，如何防范"><a href="#前端攻击有哪些形式，如何防范" class="headerlink" title="前端攻击有哪些形式，如何防范"></a>前端攻击有哪些形式，如何防范</h3><h4 id="XSS攻击："><a href="#XSS攻击：" class="headerlink" title="XSS攻击："></a>XSS攻击：</h4><p>一种安全漏洞，允许代码植入到其他页面中，通过插入script标签获取用户信息</p>
<p>如何防范： 将前端输入输出数据进行转义，避免使用eval执行个人重要信息，使用httpOnly提升cookie的安全性，限制web页面浏览器端script程序读取cookie。当使用append的时候，Jquery会将元素变为fragment,接着查找其中的script标签，使用eval去执行，会造成之前的问题，所以将输入输出部分进行转义，同样使用img标签时当加载失败时会调用onError方法，此时插入攻击代码同样需要转义进行防范</p>
<h4 id="CSRF攻击："><a href="#CSRF攻击：" class="headerlink" title="CSRF攻击："></a>CSRF攻击：</h4><p>跨站请求伪造，利用一些提交行为转换到操作其他网站（在网站支付时打款被转义到黑客账户）；</p>
<p>如何防范： 遵循http协议，token即时验证，添加验证码阻止信息外泄</p>
<h4 id="控制台注入代码："><a href="#控制台注入代码：" class="headerlink" title="控制台注入代码："></a>控制台注入代码：</h4><p>不懂的人会被欺骗到某个网站在控制台通过执行某段代码暴漏个人信息从而被黑客截取。</p>
<h1 id="2-this指向与箭头函数"><a href="#2-this指向与箭头函数" class="headerlink" title="2.this指向与箭头函数"></a>2.this指向与箭头函数</h1><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p>this在函数执行时被绑定，指向为调用该函数的对象。函数调用模式的不同造就了this指向问题上的差异。<br>函数作为一个对象的方法时，this指向该对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;window&apos;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name: &apos;lee&apos;,</span><br><span class="line">    say: function()&#123;</span><br><span class="line">        console.log(this.name); // lee</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数暴漏在全局作用域下，this指向为window<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;window&apos;;</span><br><span class="line">function say()&#123;</span><br><span class="line">    console.log(this.name) // lee</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造函数内部this指向为构造函数实例对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Obj()&#123;</span><br><span class="line">    this.name = &apos;lee&apos;;</span><br><span class="line">&#125;</span><br><span class="line">var obj = new Obj();</span><br><span class="line">obj.name // lee;</span><br></pre></td></tr></table></figure></p>
<p>改变this指向的方法： apply、call、bind, call与apply的区别在于第二部分参数前者为多个参数，后者为一个参数数组，bind与它们的差异在于只是返回一个改变了this指向的新函数，需要调用，而apply与call在改变了this指向后立即执行了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;lee&quot;</span><br><span class="line">&#125;;</span><br><span class="line">function say() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">say();    //window</span><br><span class="line">say.apply(person);   //lee</span><br><span class="line">say.call(person);   //lee</span><br><span class="line">say.bind(person)();   //lee</span><br><span class="line">say.apply();    //window</span><br></pre></td></tr></table></figure></p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>es6新增的特性之一，简化了函数定义.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; (&#123;</span><br><span class="line">    foo: x    // 单纯的返回一个表达式对象，注意需要加（）</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>箭头函数内部this是词法作用域，由上下文确定；而函数中的this指向则在函数执行时根据调用模式确定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    birth: 1990,</span><br><span class="line">    getAge: function () &#123;</span><br><span class="line">        var b = this.birth; // 1990</span><br><span class="line">        var fn = function () &#123;</span><br><span class="line">            return new Date().getFullYear() - this.birth; // 匿名函数this指向window</span><br><span class="line">        &#125;;</span><br><span class="line">        var fn = () =&gt;  new Date().getFullYear() - this.birth; // this指向obj对象</span><br><span class="line">        </span><br><span class="line">        return fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="3-var-let-const-之间的区别"><a href="#3-var-let-const-之间的区别" class="headerlink" title="3.var let const 之间的区别"></a>3.var let const 之间的区别</h1><p>var定义的变量是该变量作用域的局部变量，可以定义全局变量，但是会污染全局环境不容易维护，不推荐。<br>const定义常量，且不可重新赋值，但是如果定义的变量是一个对象的话，对象内部变量是可以改变的。<br>let声明块级作用域，块作用域内的变量在包含它们的块或for循环之外是不能访问的，否定变量声明提升，对var的一种增强。<br>es6里面不建议使用var，因为其没有块级作用域，非严格模式下会有变量声明提升的情况，会产生意想不到的错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt;5; i++)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;,10)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果会是 5 5 5 5 5; 为什么呢，怎么能打印出想要的 0，1,2,3,4,呢？</p>
<p>setTimeout事件在for循环结束后触发，此时i的值为5，解决方法；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i&lt;5; i++)&#123;</span><br><span class="line">    (function(i)&#123;</span><br><span class="line">        setTimeout(function() &#123; console.log(i); &#125;, 10);</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>利用立即执行函数迭代i的值；如果利用块级作用域呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0; i &lt;5; i++)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;,10)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每次for循环都会产生对应的作用域</p>
<h1 id="4-深拷贝与浅拷贝"><a href="#4-深拷贝与浅拷贝" class="headerlink" title="4.深拷贝与浅拷贝"></a>4.深拷贝与浅拷贝</h1><p>浅拷贝只是复制了对象的指针，不会赋值对象本身，公用一块内存，所以改变一个对象的属性值都会变化，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">    name: &apos;john&apos;</span><br><span class="line">&#125;</span><br><span class="line">var b = a;</span><br><span class="line">b.name = &apos;jeff&apos;;</span><br><span class="line"></span><br><span class="line">a // &#123; name: &apos;jeff&#125;;</span><br><span class="line">b // &#123; name: &apos;jeff&#125;;</span><br></pre></td></tr></table></figure></p>
<p>深拷贝则复制了对象，不会共享内存与指针，修改一个不会影响到另一个；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">    name: &apos;john&apos;</span><br><span class="line">&#125;</span><br><span class="line">var b = Object.assign(&#123;&#125;, a);</span><br><span class="line">b.name = &apos;jeff&apos;;</span><br><span class="line"></span><br><span class="line">a // &#123; name: &apos;john&#125;;</span><br><span class="line">b // &#123; name: &apos;jeff&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但是由于javascript中存储对象都是存地址的，Object.assign的局限性存在于它只是相对浅拷贝深入了一层，换句话就是如果对象的属性值是一个指向对象的引用，它只拷贝那个引用值，可以利用对象字符串的转换（JSON.parse(JSON.stringify(obj)）与递归实现真正的深拷贝。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; a:1, arr: [2,3] &#125;;</span><br><span class="line">var shadowObj = Object.assign(&#123;&#125;, obj);</span><br><span class="line">obj.arr[0] = 22;</span><br><span class="line">obj.a = 11;</span><br><span class="line">// obj      &#123; a: 11, arr: [22,3]&#125;</span><br><span class="line">// shadObj  &#123; a: 1,  arr: [22,3]&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/13/Subject/" itemprop="url">
                  Subject
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-04-13T15:28:16+08:00" content="2017-04-13">
              2017-04-13
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Rxjs-Subject-源码片段"><a href="#Rxjs-Subject-源码片段" class="headerlink" title="Rxjs Subject 源码片段"></a>Rxjs Subject 源码片段</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Subject继承于Observable </span><br><span class="line"> */</span><br><span class="line">export class Subject extends Observable &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.observers = []; // 观察者列表  </span><br><span class="line">        this.closed = false;</span><br><span class="line">        this.isStopped = false;</span><br><span class="line">        this.hasError = false;</span><br><span class="line">        this.thrownError = null;</span><br><span class="line">    &#125;</span><br><span class="line">    next(value) &#123;</span><br><span class="line">        if (this.closed) &#123;</span><br><span class="line">            throw new ObjectUnsubscribedError();</span><br><span class="line">        &#125;</span><br><span class="line">        if (!this.isStopped) &#123;</span><br><span class="line">            const &#123; observers &#125; = this;</span><br><span class="line">            const len = observers.length;</span><br><span class="line">            const copy = observers.slice();</span><br><span class="line">            for (let i = 0; i &lt; len; i++) &#123; // 循环调用观察者next方法，通知观察者</span><br><span class="line">                copy[i].next(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    error(err) &#123;</span><br><span class="line">        if (this.closed) &#123;</span><br><span class="line">            throw new ObjectUnsubscribedError();</span><br><span class="line">        &#125;</span><br><span class="line">        this.hasError = true;</span><br><span class="line">        this.thrownError = err;</span><br><span class="line">        this.isStopped = true;</span><br><span class="line">        const &#123; observers &#125; = this;</span><br><span class="line">        const len = observers.length;</span><br><span class="line">        const copy = observers.slice();</span><br><span class="line">        for (let i = 0; i &lt; len; i++) &#123; // 循环调用观察者error方法</span><br><span class="line">            copy[i].error(err);</span><br><span class="line">        &#125;</span><br><span class="line">        this.observers.length = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    complete() &#123;</span><br><span class="line">        if (this.closed) &#123;</span><br><span class="line">            throw new ObjectUnsubscribedError();</span><br><span class="line">        &#125;</span><br><span class="line">        this.isStopped = true;</span><br><span class="line">        const &#123; observers &#125; = this;</span><br><span class="line">        const len = observers.length;</span><br><span class="line">        const copy = observers.slice();</span><br><span class="line">        for (let i = 0; i &lt; len; i++) &#123; // 循环调用观察者complete方法</span><br><span class="line">            copy[i].complete();</span><br><span class="line">        &#125;</span><br><span class="line">        this.observers.length = 0; // 清空内部观察者列表</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="因为-Subject-在订阅时，是把-observer-存放到观察者列表中，并在接收到新值的时候，遍历观察者列表并调用观察者上的-next-方法"><a href="#因为-Subject-在订阅时，是把-observer-存放到观察者列表中，并在接收到新值的时候，遍历观察者列表并调用观察者上的-next-方法" class="headerlink" title="因为 Subject 在订阅时，是把 observer 存放到观察者列表中，并在接收到新值的时候，遍历观察者列表并调用观察者上的 next 方法"></a>因为 Subject 在订阅时，是把 observer 存放到观察者列表中，并在接收到新值的时候，遍历观察者列表并调用观察者上的 next 方法</h3><h3 id="Subject继承自Observable-将Observable的单路推送转换为多路推送。它就是讲单路Observable转变为多路Observable的桥梁。"><a href="#Subject继承自Observable-将Observable的单路推送转换为多路推送。它就是讲单路Observable转变为多路Observable的桥梁。" class="headerlink" title="Subject继承自Observable,将Observable的单路推送转换为多路推送。它就是讲单路Observable转变为多路Observable的桥梁。"></a>Subject继承自Observable,将Observable的单路推送转换为多路推送。它就是讲单路Observable转变为多路Observable的桥梁。</h3><h2 id="Subject的几个衍生类：BehaviorSubject-ReplaySubject-AsyncSubject"><a href="#Subject的几个衍生类：BehaviorSubject-ReplaySubject-AsyncSubject" class="headerlink" title="Subject的几个衍生类：BehaviorSubject,ReplaySubject,AsyncSubject;"></a>Subject的几个衍生类：BehaviorSubject,ReplaySubject,AsyncSubject;</h2><h3 id="BehaviorSubject：保存最近向数据消费者发送的值，当一个Observer订阅后，他会立即收到最新的值；它非常适合表示随时间推移的值；BehaviorSubject-形容一个人的生日，随时间不断更新；"><a href="#BehaviorSubject：保存最近向数据消费者发送的值，当一个Observer订阅后，他会立即收到最新的值；它非常适合表示随时间推移的值；BehaviorSubject-形容一个人的生日，随时间不断更新；" class="headerlink" title="BehaviorSubject：保存最近向数据消费者发送的值，当一个Observer订阅后，他会立即收到最新的值；它非常适合表示随时间推移的值；BehaviorSubject 形容一个人的生日，随时间不断更新；"></a>BehaviorSubject：保存最近向数据消费者发送的值，当一个Observer订阅后，他会立即收到最新的值；它非常适合表示随时间推移的值；BehaviorSubject 形容一个人的生日，随时间不断更新；</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var subject = new Rx.BehaviorSubject(0) //初始值</span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">    next:(v) =&gt; &#123;</span><br><span class="line">        console.log(&apos;A&apos; + v )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">subject.next(1);</span><br><span class="line">subject.next(2);</span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">    next:(v) =&gt; &#123;</span><br><span class="line">        console.log(&apos;B&apos; + v )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">subject.next(3);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var subject = new Rx.ReplaySubject(3); /* 回放数量 */</span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">subject.next(1);</span><br><span class="line">subject.next(2);</span><br><span class="line">subject.next(3);</span><br><span class="line">subject.next(4);</span><br><span class="line"></span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">subject.next(5);</span><br></pre></td></tr></table></figure>
<h3 id="ReplaySubject-如同于-BehaviorSubject-是-Subject-的子类。通过-ReplaySubject-可以向新的订阅者推送旧数值，就像一个录像机-ReplaySubject-可以记录Observable的一部分状态（过去时间内推送的值）-一个-ReplaySubject-可以记录Observable执行过程中推送的多个值，并向新的订阅者回放它们。"><a href="#ReplaySubject-如同于-BehaviorSubject-是-Subject-的子类。通过-ReplaySubject-可以向新的订阅者推送旧数值，就像一个录像机-ReplaySubject-可以记录Observable的一部分状态（过去时间内推送的值）-一个-ReplaySubject-可以记录Observable执行过程中推送的多个值，并向新的订阅者回放它们。" class="headerlink" title="ReplaySubject 如同于 BehaviorSubject 是 Subject 的子类。通过 ReplaySubject 可以向新的订阅者推送旧数值，就像一个录像机 ReplaySubject 可以记录Observable的一部分状态（过去时间内推送的值）;.一个 ReplaySubject 可以记录Observable执行过程中推送的多个值，并向新的订阅者回放它们。"></a>ReplaySubject 如同于 BehaviorSubject 是 Subject 的子类。通过 ReplaySubject 可以向新的订阅者推送旧数值，就像一个录像机 ReplaySubject 可以记录Observable的一部分状态（过去时间内推送的值）;.一个 ReplaySubject 可以记录Observable执行过程中推送的多个值，并向新的订阅者回放它们。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var subject = new Rx.AsyncSubject();</span><br><span class="line"></span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">subject.next(1);</span><br><span class="line">subject.next(2);</span><br><span class="line">subject.next(3);</span><br><span class="line">subject.next(4);</span><br><span class="line"></span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">subject.next(5);</span><br><span class="line">subject.complete();</span><br></pre></td></tr></table></figure>
<h3 id="AsyncSubject是Subject的另外一个衍生类，Observable仅会在执行完成后-complete-，推送执行环境中的最后一个值。业务上很少用"><a href="#AsyncSubject是Subject的另外一个衍生类，Observable仅会在执行完成后-complete-，推送执行环境中的最后一个值。业务上很少用" class="headerlink" title="AsyncSubject是Subject的另外一个衍生类，Observable仅会在执行完成后(complete)，推送执行环境中的最后一个值。业务上很少用"></a>AsyncSubject是Subject的另外一个衍生类，Observable仅会在执行完成后(complete)，推送执行环境中的最后一个值。业务上很少用</h3><h3 id="既然Subject是一个Observer，你可以把它作为subscribe（订阅）普通Observable时的参数"><a href="#既然Subject是一个Observer，你可以把它作为subscribe（订阅）普通Observable时的参数" class="headerlink" title="既然Subject是一个Observer，你可以把它作为subscribe（订阅）普通Observable时的参数"></a>既然Subject是一个Observer，你可以把它作为subscribe（订阅）普通Observable时的参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var subject = new Rx.Subject();</span><br><span class="line"></span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</span><br><span class="line">&#125;);</span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var observable = Rx.Observable.from([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">observable.subscribe(subject); // 你可以传递Subject来订阅observable</span><br></pre></td></tr></table></figure>
<h3 id="通过添加两个Observer到Observer列表中，之后Observable直接订阅Observer列表将普通的单路推送转换为多路推送"><a href="#通过添加两个Observer到Observer列表中，之后Observable直接订阅Observer列表将普通的单路推送转换为多路推送" class="headerlink" title="通过添加两个Observer到Observer列表中，之后Observable直接订阅Observer列表将普通的单路推送转换为多路推送"></a>通过添加两个Observer到Observer列表中，之后Observable直接订阅Observer列表将普通的单路推送转换为多路推送</h3><h2 id="Cold-amp-HOT"><a href="#Cold-amp-HOT" class="headerlink" title="Cold  &amp;  HOT"></a>Cold  &amp;  HOT</h2><h3 id="observable-is-default-cold-cold-表示只有-subscribe-出现-observer-才会被激活-当有多个subscribe时，每一个都是一条独立的链；hot-每个subscirbe共享一个链，不管什么时间插入subscribe-都不会重新开始。如何把一个cold-变成-hot？Subject则可以充当中介。multicast、refCount、publish、share则是通过Subject完成将cold转变为hot的方法。"><a href="#observable-is-default-cold-cold-表示只有-subscribe-出现-observer-才会被激活-当有多个subscribe时，每一个都是一条独立的链；hot-每个subscirbe共享一个链，不管什么时间插入subscribe-都不会重新开始。如何把一个cold-变成-hot？Subject则可以充当中介。multicast、refCount、publish、share则是通过Subject完成将cold转变为hot的方法。" class="headerlink" title="observable is default cold; cold: 表示只有 subscribe 出现 observer 才会被激活; 当有多个subscribe时，每一个都是一条独立的链；hot: 每个subscirbe共享一个链，不管什么时间插入subscribe,都不会重新开始。如何把一个cold 变成 hot？Subject则可以充当中介。multicast、refCount、publish、share则是通过Subject完成将cold转变为hot的方法。"></a>observable is default cold; cold: 表示只有 subscribe 出现 observer 才会被激活; 当有多个subscribe时，每一个都是一条独立的链；hot: 每个subscirbe共享一个链，不管什么时间插入subscribe,都不会重新开始。如何把一个cold 变成 hot？Subject则可以充当中介。multicast、refCount、publish、share则是通过Subject完成将cold转变为hot的方法。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let sub = new Subject();</span><br><span class="line">let obs = sub.map(v =&gt; &#123;</span><br><span class="line">    console.log(&quot;ajax call&quot;); </span><br><span class="line">&#125;);</span><br><span class="line">obs.subscribe(v =&gt; console.log(&quot;subscribe 1&quot;));</span><br><span class="line">obs.subscribe(v =&gt; console.log(&quot;subscribe 2&quot;));         </span><br><span class="line">sub.next(&quot;value&quot;); </span><br><span class="line">// ajax call</span><br><span class="line">// subscribe 1</span><br><span class="line">// ajax call</span><br><span class="line">// subscribe 2</span><br></pre></td></tr></table></figure>
<h3 id="模拟异步请求数据的业务场景，如果有更多的subscribe的时候，则会对请求服务器多次，造成服务器负载严重，此时一般解决方法为以下两种"><a href="#模拟异步请求数据的业务场景，如果有更多的subscribe的时候，则会对请求服务器多次，造成服务器负载严重，此时一般解决方法为以下两种" class="headerlink" title="模拟异步请求数据的业务场景，如果有更多的subscribe的时候，则会对请求服务器多次，造成服务器负载严重，此时一般解决方法为以下两种"></a>模拟异步请求数据的业务场景，如果有更多的subscribe的时候，则会对请求服务器多次，造成服务器负载严重，此时一般解决方法为以下两种</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obs = sub.map(v =&gt; &#123;</span><br><span class="line">    console.log(&quot;ajax call&quot;); </span><br><span class="line">&#125;).share();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obs = sub.map(v =&gt; &#123;</span><br><span class="line">    console.log(&quot;ajax call&quot;); </span><br><span class="line">&#125;).publish().refCount();</span><br></pre></td></tr></table></figure>
<h3 id="引入multicast（组播）的概念，通过中介者订阅源序列在由它推送出去-下面是它的运作方式"><a href="#引入multicast（组播）的概念，通过中介者订阅源序列在由它推送出去-下面是它的运作方式" class="headerlink" title="引入multicast（组播）的概念，通过中介者订阅源序列在由它推送出去,下面是它的运作方式"></a>引入multicast（组播）的概念，通过中介者订阅源序列在由它推送出去,下面是它的运作方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.interval(1000).take(3);</span><br><span class="line"></span><br><span class="line">var observerA = &#123;</span><br><span class="line">    next: value =&gt; console.log(&apos;A next: &apos; + value),</span><br><span class="line">    error: error =&gt; console.log(&apos;A error: &apos; + error),</span><br><span class="line">    complete: () =&gt; console.log(&apos;A complete!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var observerB = &#123;</span><br><span class="line">    next: value =&gt; console.log(&apos;B next: &apos; + value),</span><br><span class="line">    error: error =&gt; console.log(&apos;B error: &apos; + error),</span><br><span class="line">    complete: () =&gt; console.log(&apos;B complete!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var subject = &#123;</span><br><span class="line">    observers: [],</span><br><span class="line">    subscribe: function(observer) &#123;   //addObserver</span><br><span class="line">        this.observers.push(observer)</span><br><span class="line">    &#125;,</span><br><span class="line">    next: function(value) &#123;</span><br><span class="line">        this.observers.forEach(o =&gt; o.next(value))    </span><br><span class="line">    &#125;,</span><br><span class="line">    error: function(error)&#123;</span><br><span class="line">        this.observers.forEach(o =&gt; o.error(error))</span><br><span class="line">    &#125;,</span><br><span class="line">    complete: function() &#123;</span><br><span class="line">        this.observers.forEach(o =&gt; o.complete())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.subscribe(observerA)</span><br><span class="line"></span><br><span class="line">source.subscribe(subject);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    subject.subscribe(observerB);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>
<h3 id="换一种形式，用multicast方法来实现"><a href="#换一种形式，用multicast方法来实现" class="headerlink" title="换一种形式，用multicast方法来实现"></a>换一种形式，用multicast方法来实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.interval(1000)</span><br><span class="line">             .take(3)</span><br><span class="line">             .multicast(new Rx.Subject());</span><br><span class="line"></span><br><span class="line">var observerA = &#123;</span><br><span class="line">    next: value =&gt; console.log(&apos;A next: &apos; + value),</span><br><span class="line">    error: error =&gt; console.log(&apos;A error: &apos; + error),</span><br><span class="line">    complete: () =&gt; console.log(&apos;A complete!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var observerB = &#123;</span><br><span class="line">    next: value =&gt; console.log(&apos;B next: &apos; + value),</span><br><span class="line">    error: error =&gt; console.log(&apos;B error: &apos; + error),</span><br><span class="line">    complete: () =&gt; console.log(&apos;B complete!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">source.subscribe(observerA); // subject.subscribe(observerA)</span><br><span class="line"></span><br><span class="line">source.connect();    // source.subscribe(subject)  //开始推送 </span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    source.subscribe(observerB); // subject.subscribe(observerA)</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var result = Observable.interval(1000).take(6)  //执行两次</span><br><span class="line">             .map(x =&gt; Math.random())</span><br><span class="line">            //  .share()    //不会因为订阅者数量而执行多次</span><br><span class="line">            //  .publish().refCount()</span><br><span class="line"></span><br><span class="line">     var subA = result.subscribe(x =&gt; console.log(&apos;A: &apos; + x));</span><br><span class="line">     var subB = result.subscribe(x =&gt; console.log(&apos;B: &apos; + x));</span><br></pre></td></tr></table></figure>
<h3 id="常用应用场景"><a href="#常用应用场景" class="headerlink" title="常用应用场景"></a>常用应用场景</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let sub = new Subject();</span><br><span class="line">let obs = sub.map(v =&gt; &#123;</span><br><span class="line">    console.log(&quot;ajax call&quot;);  //请求接口</span><br><span class="line">&#125;);</span><br><span class="line">obs.subscribe(v =&gt; console.log(&quot;subscribe 1&quot;));  //分发</span><br><span class="line">obs.subscribe(v =&gt; console.log(&quot;subscribe 2&quot;));         </span><br><span class="line">sub.next(&quot;value&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="ajax会打印两次，增加服务器端负载；-调用share-方法；其中angular2中的http也是not-share的，在类似场景中同样的问题；"><a href="#ajax会打印两次，增加服务器端负载；-调用share-方法；其中angular2中的http也是not-share的，在类似场景中同样的问题；" class="headerlink" title="ajax会打印两次，增加服务器端负载； 调用share()方法；其中angular2中的http也是not share的，在类似场景中同样的问题；"></a>ajax会打印两次，增加服务器端负载； 调用share()方法；其中angular2中的http也是not share的，在类似场景中同样的问题；</h3><h3 id="建立一個-subject-先拿去訂閱-observable-source-，再把我們真正的-observer-加到-subject-中，這樣一來就能完成訂閱，而每個加到-subject-中的-observer-都能整組的接收到相同的元素。"><a href="#建立一個-subject-先拿去訂閱-observable-source-，再把我們真正的-observer-加到-subject-中，這樣一來就能完成訂閱，而每個加到-subject-中的-observer-都能整組的接收到相同的元素。" class="headerlink" title="建立一個 subject 先拿去訂閱 observable(source)，再把我們真正的 observer 加到 subject 中，這樣一來就能完成訂閱，而每個加到 subject 中的 observer 都能整組的接收到相同的元素。"></a>建立一個 subject 先拿去訂閱 observable(source)，再把我們真正的 observer 加到 subject 中，這樣一來就能完成訂閱，而每個加到 subject 中的 observer 都能整組的接收到相同的元素。</h3><h3 id="Observable-multicast-new-Rx-Subject-Observable-publish-对于Subject三种衍生形式，publishReplay-1-、publishBehavior-0-、publishLast"><a href="#Observable-multicast-new-Rx-Subject-Observable-publish-对于Subject三种衍生形式，publishReplay-1-、publishBehavior-0-、publishLast" class="headerlink" title="Observable.multicast(new Rx.Subject()) == Observable.publish();对于Subject三种衍生形式，publishReplay(1)、publishBehavior(0)、publishLast()"></a>Observable.multicast(new Rx.Subject()) == Observable.publish();对于Subject三种衍生形式，publishReplay(1)、publishBehavior(0)、publishLast()</h3><h3 id="另外-Observable-publish-refCount-Observable-share"><a href="#另外-Observable-publish-refCount-Observable-share" class="headerlink" title="另外   Observable.publish().refCount() == Observable.share()"></a>另外   Observable.publish().refCount() == Observable.share()</h3><h2 id="总结Subject！"><a href="#总结Subject！" class="headerlink" title="总结Subject！"></a>总结Subject！</h2><ul>
<li>既是Observable又是Observer</li>
<li>对内部的observers进行组播</li>
<li>observer default is cold and not share.(cold 表示只有 subscribe 出现 observer 才会被激活.    not share 表示每一个 subscribe 都会激活 observer 链)</li>
</ul>
<h3 id="业务场景：窗口a接收到A-b接收到B-c接受到C，本窗口d则需要异步的捕获a和b窗口的值并乘c窗口的值，d-a-b-c"><a href="#业务场景：窗口a接收到A-b接收到B-c接受到C，本窗口d则需要异步的捕获a和b窗口的值并乘c窗口的值，d-a-b-c" class="headerlink" title="业务场景：窗口a接收到A,b接收到B,c接受到C，本窗口d则需要异步的捕获a和b窗口的值并乘c窗口的值，d = (a+b)*c;"></a>业务场景：窗口a接收到A,b接收到B,c接受到C，本窗口d则需要异步的捕获a和b窗口的值并乘c窗口的值，d = (a+b)*c;</h3><h3 id="我们可以把每个数据的变更定义成流，然后定义出这些流的组合关系"><a href="#我们可以把每个数据的变更定义成流，然后定义出这些流的组合关系" class="headerlink" title="我们可以把每个数据的变更定义成流，然后定义出这些流的组合关系"></a>我们可以把每个数据的变更定义成流，然后定义出这些流的组合关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const A = new Rx.Subject()</span><br><span class="line">const B = new Rx.Subject()</span><br><span class="line">const C = new Rx.Subject()</span><br><span class="line"></span><br><span class="line">const D = Rx.Observable</span><br><span class="line">  .combineLatest(A, B, C)</span><br><span class="line">  .map(data =&gt; &#123;</span><br><span class="line">    let [a, b, c] = data</span><br><span class="line">    return (a + b) * c</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">D.subscribe(result =&gt; console.log(result))</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; A.next(2), 3000)</span><br><span class="line">setTimeout(() =&gt; B.next(3), 5000)</span><br><span class="line">setTimeout(() =&gt; C.next(5), 2000)</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; C.next(11), 10000)</span><br></pre></td></tr></table></figure>
<h3 id="为了简单，我们用定时器来模拟异步消息。实际业务中，对每个Subject的赋值是可以跟AJAX或者WebSocket结合起来，而且对D的那段实现毫无影响。我们可以看到，在整个这个过程中，最大的便利性在于，一旦定义完整个规则，变动整个表达式树上任意一个点，整个过程都会重跑一遍，以确保最终得到正确结果。无论中间环节上哪个东西变了，它只要更新自己就可以了，别人怎么用它的，不必关心。而且，我们从D的角度看，他只关心自己的数据来源是如何组织的，这些来源最终形成了一棵树，从各叶子汇聚到树根，也就是我们的订阅者这里，树上每个节点变更，都会自动触发从它往下到树根的所有数据变动，这个过程是最精确的，不会触发无效的数据更新。"><a href="#为了简单，我们用定时器来模拟异步消息。实际业务中，对每个Subject的赋值是可以跟AJAX或者WebSocket结合起来，而且对D的那段实现毫无影响。我们可以看到，在整个这个过程中，最大的便利性在于，一旦定义完整个规则，变动整个表达式树上任意一个点，整个过程都会重跑一遍，以确保最终得到正确结果。无论中间环节上哪个东西变了，它只要更新自己就可以了，别人怎么用它的，不必关心。而且，我们从D的角度看，他只关心自己的数据来源是如何组织的，这些来源最终形成了一棵树，从各叶子汇聚到树根，也就是我们的订阅者这里，树上每个节点变更，都会自动触发从它往下到树根的所有数据变动，这个过程是最精确的，不会触发无效的数据更新。" class="headerlink" title="为了简单，我们用定时器来模拟异步消息。实际业务中，对每个Subject的赋值是可以跟AJAX或者WebSocket结合起来，而且对D的那段实现毫无影响。我们可以看到，在整个这个过程中，最大的便利性在于，一旦定义完整个规则，变动整个表达式树上任意一个点，整个过程都会重跑一遍，以确保最终得到正确结果。无论中间环节上哪个东西变了，它只要更新自己就可以了，别人怎么用它的，不必关心。而且，我们从D的角度看，他只关心自己的数据来源是如何组织的，这些来源最终形成了一棵树，从各叶子汇聚到树根，也就是我们的订阅者这里，树上每个节点变更，都会自动触发从它往下到树根的所有数据变动，这个过程是最精确的，不会触发无效的数据更新。"></a>为了简单，我们用定时器来模拟异步消息。实际业务中，对每个Subject的赋值是可以跟AJAX或者WebSocket结合起来，而且对D的那段实现毫无影响。我们可以看到，在整个这个过程中，最大的便利性在于，一旦定义完整个规则，变动整个表达式树上任意一个点，整个过程都会重跑一遍，以确保最终得到正确结果。无论中间环节上哪个东西变了，它只要更新自己就可以了，别人怎么用它的，不必关心。而且，我们从D的角度看，他只关心自己的数据来源是如何组织的，这些来源最终形成了一棵树，从各叶子汇聚到树根，也就是我们的订阅者这里，树上每个节点变更，都会自动触发从它往下到树根的所有数据变动，这个过程是最精确的，不会触发无效的数据更新。</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/28/rxjs/" itemprop="url">
                  RxJS:万物皆为流
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-02-28T13:54:14+08:00" content="2017-02-28">
              2017-02-28
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。最好的Rxjs中文文档"><a href="#首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。最好的Rxjs中文文档" class="headerlink" title="首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。最好的Rxjs中文文档"></a>首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。<a href="https://www.gitbook.com/book/buctwbzs/rxjs/details" target="_blank" rel="noopener">最好的Rxjs中文文档</a></h2><h3 id="RXJS全名Reactive-Extensions-for-JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。"><a href="#RXJS全名Reactive-Extensions-for-JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。" class="headerlink" title="RXJS全名Reactive Extensions for JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。"></a>RXJS全名Reactive Extensions for JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。</h3><h3 id="RxJS所能解决的问题："><a href="#RxJS所能解决的问题：" class="headerlink" title="RxJS所能解决的问题："></a>RxJS所能解决的问题：</h3><h4 id="时刻保持响应。这对于一个应用来说意味着当他处理用户的输入或者凭借AJAX从服务器接受一些数据时停止是一件不可能接受的事情。在JavaScript中解决问题的方案始终是大量运用回调函数来进行一些运行的处理。但回调的使用使内容丰富的大型应用变得凌乱，一旦你需要多块数据时你就陷入了回调地狱。Angular2中，组件间通讯-Output对应的EventEmitter实际上就是一个Subject-主题：同时为Observable和Observer-Http模块中Observable作为大部分API的交互对象使用。但是这只是官方的外部扩展，并不必须，也可以使用-toPromise的方式转换为Promise来使用或第三方扩展库或Fetch-API-传统Ajax已死，Fetch永生。"><a href="#时刻保持响应。这对于一个应用来说意味着当他处理用户的输入或者凭借AJAX从服务器接受一些数据时停止是一件不可能接受的事情。在JavaScript中解决问题的方案始终是大量运用回调函数来进行一些运行的处理。但回调的使用使内容丰富的大型应用变得凌乱，一旦你需要多块数据时你就陷入了回调地狱。Angular2中，组件间通讯-Output对应的EventEmitter实际上就是一个Subject-主题：同时为Observable和Observer-Http模块中Observable作为大部分API的交互对象使用。但是这只是官方的外部扩展，并不必须，也可以使用-toPromise的方式转换为Promise来使用或第三方扩展库或Fetch-API-传统Ajax已死，Fetch永生。" class="headerlink" title="时刻保持响应。这对于一个应用来说意味着当他处理用户的输入或者凭借AJAX从服务器接受一些数据时停止是一件不可能接受的事情。在JavaScript中解决问题的方案始终是大量运用回调函数来进行一些运行的处理。但回调的使用使内容丰富的大型应用变得凌乱，一旦你需要多块数据时你就陷入了回调地狱。Angular2中，组件间通讯@Output对应的EventEmitter实际上就是一个Subject(主题：同时为Observable和Observer);Http模块中Observable作为大部分API的交互对象使用。但是这只是官方的外部扩展，并不必须，也可以使用.toPromise的方式转换为Promise来使用或第三方扩展库或Fetch API 传统Ajax已死，Fetch永生。"></a>时刻保持响应。这对于一个应用来说意味着当他处理用户的输入或者凭借AJAX从服务器接受一些数据时停止是一件不可能接受的事情。在JavaScript中解决问题的方案始终是大量运用回调函数来进行一些运行的处理。但回调的使用使内容丰富的大型应用变得凌乱，一旦你需要多块数据时你就陷入了回调地狱。Angular2中，组件间通讯@Output对应的EventEmitter实际上就是一个Subject(主题：同时为Observable和Observer);Http模块中Observable作为大部分API的交互对象使用。但是这只是官方的外部扩展，并不必须，也可以使用.toPromise的方式转换为Promise来使用或第三方扩展库或Fetch API <a href="https://segmentfault.com/a/1190000003810652" target="_blank" rel="noopener">传统Ajax已死，Fetch永生</a>。</h4><p><br></p>
<h3 id="RxJS初探："><a href="#RxJS初探：" class="headerlink" title="RxJS初探："></a>RxJS初探：</h3><h4 id="RxJS是一个解决异步问题的JS开发库-它带来了观察者模式和函数式编程的相结合的最佳实践。-观察者模式是一个被实践证明的模式，基于生产者（事件的创建者）和消费者（事件的监听者）的逻辑分离关系-况且函数式编程方式的引入，如说明性编程，不可变数据结构，链式方法调用会使你极大的简化代码量。RxJS-引入了一个重要的数据类型——流（stream）。流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下，等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。"><a href="#RxJS是一个解决异步问题的JS开发库-它带来了观察者模式和函数式编程的相结合的最佳实践。-观察者模式是一个被实践证明的模式，基于生产者（事件的创建者）和消费者（事件的监听者）的逻辑分离关系-况且函数式编程方式的引入，如说明性编程，不可变数据结构，链式方法调用会使你极大的简化代码量。RxJS-引入了一个重要的数据类型——流（stream）。流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下，等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。" class="headerlink" title="RxJS是一个解决异步问题的JS开发库.它带来了观察者模式和函数式编程的相结合的最佳实践。 观察者模式是一个被实践证明的模式，基于生产者（事件的创建者）和消费者（事件的监听者）的逻辑分离关系.况且函数式编程方式的引入，如说明性编程，不可变数据结构，链式方法调用会使你极大的简化代码量。RxJS 引入了一个重要的数据类型——流（stream）。流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下，等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。"></a>RxJS是一个解决异步问题的JS开发库.它带来了观察者模式和函数式编程的相结合的最佳实践。 观察者模式是一个被实践证明的模式，基于生产者（事件的创建者）和消费者（事件的监听者）的逻辑分离关系.况且函数式编程方式的引入，如说明性编程，不可变数据结构，链式方法调用会使你极大的简化代码量。RxJS 引入了一个重要的数据类型——流（stream）。流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下，等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。</h4><p><br></p>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><h4 id="流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。"><a href="#流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。" class="headerlink" title="流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。"></a>流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 2;</span><br><span class="line">var b = 4;</span><br><span class="line">var c = a + b;</span><br><span class="line">console.log(c); //-&gt; 6</span><br><span class="line">a = 10;  // reassign a</span><br><span class="line">console.log(c); //-&gt; still 6</span><br></pre></td></tr></table></figure>
<h4 id="事件引发的改变总是从事件源（生产者）-向下传递到所有事件监听方（消费者）。如果变量看做流呢，又是什么结果呢？"><a href="#事件引发的改变总是从事件源（生产者）-向下传递到所有事件监听方（消费者）。如果变量看做流呢，又是什么结果呢？" class="headerlink" title="事件引发的改变总是从事件源（生产者）,向下传递到所有事件监听方（消费者）。如果变量看做流呢，又是什么结果呢？"></a>事件引发的改变总是从事件源（生产者）,向下传递到所有事件监听方（消费者）。如果变量看做流呢，又是什么结果呢？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var A$ = 2;</span><br><span class="line">var B$ = 4;</span><br><span class="line">var C$ = A$ + B$;</span><br><span class="line">console.log(C$); //-&gt; 6</span><br><span class="line">A$ = 10;  </span><br><span class="line">console.log(C$); //-&gt;  16</span><br></pre></td></tr></table></figure>
<h4 id="流的方式重新定义的变量值的动态行为-换句话说，C-是把两个流变量A-和B-进行合并操作。当一个新值被推进了A-，C-立刻响应式的变更为16。"><a href="#流的方式重新定义的变量值的动态行为-换句话说，C-是把两个流变量A-和B-进行合并操作。当一个新值被推进了A-，C-立刻响应式的变更为16。" class="headerlink" title="流的方式重新定义的变量值的动态行为.换句话说，C$是把两个流变量A$和B$进行合并操作。当一个新值被推进了A$，C$立刻响应式的变更为16。"></a>流的方式重新定义的变量值的动态行为.换句话说，C$是把两个流变量A$和B$进行合并操作。当一个新值被推进了A$，C$立刻响应式的变更为16。</h4><h3 id="开始了解RxJS中的几个重要成员"><a href="#开始了解RxJS中的几个重要成员" class="headerlink" title="开始了解RxJS中的几个重要成员"></a>开始了解RxJS中的几个重要成员</h3><ul>
<li>Observable可观察对象：表示一个可调用的未来值或者事件的集合。</li>
<li>Observer观察者：一个回调函数集合,它知道怎样去监听被Observable发送的值</li>
<li>Subscription订阅： 表示一个可观察对象的执行，主要用于取消执行。</li>
<li>Operators操作符： 纯粹的函数，使得以函数编程的方式处理集合比如:map,filter,contact,flatmap。</li>
<li>Subject(主题)：等同于一个事件驱动器，是将一个值或者事件广播到多个观察者的唯一途径。</li>
<li>Schedulers(调度者)： 用来控制并发，当计算发生的时候允许我们协调，比如setTimeout,requestAnimationFrame。<h3 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h3><h4 id="使用RxJS创建一个可观察对象："><a href="#使用RxJS创建一个可观察对象：" class="headerlink" title="使用RxJS创建一个可观察对象："></a>使用RxJS创建一个可观察对象：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var button = document.querySelector(&apos;button&apos;);</span><br><span class="line">Rx.Observable.fromEvent(button, &apos;click&apos;)</span><br><span class="line">.throttleTime(1000)</span><br><span class="line">.scan(count =&gt; count + 1, 0)   </span><br><span class="line">.subscribe(count =&gt; console.log(`Clicked $&#123;count&#125; times`));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="observable可观察对象，以惰性的方式推送多值的集合"><a href="#observable可观察对象，以惰性的方式推送多值的集合" class="headerlink" title="observable可观察对象，以惰性的方式推送多值的集合"></a>observable可观察对象，以惰性的方式推送多值的集合</h3><h4 id="下面的例子是一个推送1-2，3-4数值的可观察对象，一旦它被订阅1-2，3-就会被推送，4则会在订阅发生一秒之后被推送，紧接着完成推送"><a href="#下面的例子是一个推送1-2，3-4数值的可观察对象，一旦它被订阅1-2，3-就会被推送，4则会在订阅发生一秒之后被推送，紧接着完成推送" class="headerlink" title="下面的例子是一个推送1,2，3,4数值的可观察对象，一旦它被订阅1,2，3,就会被推送，4则会在订阅发生一秒之后被推送，紧接着完成推送"></a>下面的例子是一个推送1,2，3,4数值的可观察对象，一旦它被订阅1,2，3,就会被推送，4则会在订阅发生一秒之后被推送，紧接着完成推送</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var observable = Rx.Observable.create(observer=&gt;&#123;</span><br><span class="line">    observer.next(1);</span><br><span class="line">    observer.next(2);</span><br><span class="line">    observer.next(3);</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        observer.next(4);</span><br><span class="line">        observer.complete();</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Pull拉取-VS-Push推送"><a href="#Pull拉取-VS-Push推送" class="headerlink" title="Pull拉取 VS Push推送"></a>Pull拉取 VS Push推送</h3><h4 id="拉和推是数据生产者和数据的消费者两种不同的交流协议-方式"><a href="#拉和推是数据生产者和数据的消费者两种不同的交流协议-方式" class="headerlink" title="拉和推是数据生产者和数据的消费者两种不同的交流协议(方式);"></a>拉和推是数据生产者和数据的消费者两种不同的交流协议(方式);</h4><p><br></p>
<h4 id="什么是”Pull拉”？在”拉”体系中，数据的消费者决定何时从数据生产者那里获取数据，而生产者自身并不会意识到什么时候数据将会被发送给消费者。"><a href="#什么是”Pull拉”？在”拉”体系中，数据的消费者决定何时从数据生产者那里获取数据，而生产者自身并不会意识到什么时候数据将会被发送给消费者。" class="headerlink" title="什么是”Pull拉”？在”拉”体系中，数据的消费者决定何时从数据生产者那里获取数据，而生产者自身并不会意识到什么时候数据将会被发送给消费者。"></a>什么是”Pull拉”？在”拉”体系中，数据的消费者决定何时从数据生产者那里获取数据，而生产者自身并不会意识到什么时候数据将会被发送给消费者。</h4><h4 id="每一个JS函数都是一个“拉”体系，函数是数据的生产者，调用函数的代码通过“拉出”一个单一的返回值来消费该数据-return-语句-。"><a href="#每一个JS函数都是一个“拉”体系，函数是数据的生产者，调用函数的代码通过“拉出”一个单一的返回值来消费该数据-return-语句-。" class="headerlink" title="每一个JS函数都是一个“拉”体系，函数是数据的生产者，调用函数的代码通过“拉出”一个单一的返回值来消费该数据(return 语句)。"></a>每一个JS函数都是一个“拉”体系，函数是数据的生产者，调用函数的代码通过“拉出”一个单一的返回值来消费该数据(return 语句)。</h4><h4 id="什么是”Push推”？在推体系中，数据的生产者决定何时发送数据给消费者，消费者不会在接收数据之前意识到它将要接收这个数据。"><a href="#什么是”Push推”？在推体系中，数据的生产者决定何时发送数据给消费者，消费者不会在接收数据之前意识到它将要接收这个数据。" class="headerlink" title="什么是”Push推”？在推体系中，数据的生产者决定何时发送数据给消费者，消费者不会在接收数据之前意识到它将要接收这个数据。"></a>什么是”Push推”？在推体系中，数据的生产者决定何时发送数据给消费者，消费者不会在接收数据之前意识到它将要接收这个数据。</h4><h4 id="Promise-承诺-是当今JS中最常见的Push推体系，一个Promise-数据的生产者-发送一个resolved-value-成功状态的值-来注册一个回调-数据消费者-，但是不同于函数的地方的是：Promise决定着何时数据才被推送至这个回调函数。"><a href="#Promise-承诺-是当今JS中最常见的Push推体系，一个Promise-数据的生产者-发送一个resolved-value-成功状态的值-来注册一个回调-数据消费者-，但是不同于函数的地方的是：Promise决定着何时数据才被推送至这个回调函数。" class="headerlink" title="Promise(承诺))是当今JS中最常见的Push推体系，一个Promise(数据的生产者)发送一个resolved value(成功状态的值)来注册一个回调(数据消费者)，但是不同于函数的地方的是：Promise决定着何时数据才被推送至这个回调函数。"></a>Promise(承诺))是当今JS中最常见的Push推体系，一个Promise(数据的生产者)发送一个resolved value(成功状态的值)来注册一个回调(数据消费者)，但是不同于函数的地方的是：Promise决定着何时数据才被推送至这个回调函数。</h4><h4 id="RxJS引入了Observables-可观察对象-，一个全新的”推体系”。一个可观察对象是一个产生多值的生产者，并”推送给”Observer-观察者-。"><a href="#RxJS引入了Observables-可观察对象-，一个全新的”推体系”。一个可观察对象是一个产生多值的生产者，并”推送给”Observer-观察者-。" class="headerlink" title="RxJS引入了Observables(可观察对象)，一个全新的”推体系”。一个可观察对象是一个产生多值的生产者，并”推送给”Observer(观察者)。"></a>RxJS引入了Observables(可观察对象)，一个全新的”推体系”。一个可观察对象是一个产生多值的生产者，并”推送给”Observer(观察者)。</h4><h3 id="RxJS-VS-Promise—3个最重要的不同点"><a href="#RxJS-VS-Promise—3个最重要的不同点" class="headerlink" title="RxJS VS Promise—3个最重要的不同点"></a>RxJS VS Promise—3个最重要的不同点</h3><!--| 不同点               | RxJS     | Promise  |

| --------------------|:---------:|---------:|

| 动作是否可以取消？    | 是        | 否       |

| 是否可以发射多个值？  | 是        | 否       |

| 各种工具函数？        | 是        | 否       |-->
<table>
<thead>
<tr>
<th>不同点</th>
<th style="text-align:center">Rxjs</th>
<th style="text-align:right">Promise</th>
</tr>
</thead>
<tbody>
<tr>
<td>动作是否可以取消？</td>
<td style="text-align:center">是</td>
<td style="text-align:right">否</td>
</tr>
<tr>
<td>是否可以发射多个值？</td>
<td style="text-align:center">是</td>
<td style="text-align:right">否</td>
</tr>
<tr>
<td>各种工具函数？</td>
<td style="text-align:center">是</td>
<td style="text-align:right">否</td>
</tr>
</tbody>
</table>
<h2 id="Operators操作符"><a href="#Operators操作符" class="headerlink" title="Operators操作符"></a>Operators操作符</h2><h3 id="create-创建一个可观察序列，参数为一个封装数据生成逻辑的函数，该函数的参数为观察者"><a href="#create-创建一个可观察序列，参数为一个封装数据生成逻辑的函数，该函数的参数为观察者" class="headerlink" title="create()  创建一个可观察序列，参数为一个封装数据生成逻辑的函数，该函数的参数为观察者"></a>create()  创建一个可观察序列，参数为一个封装数据生成逻辑的函数，该函数的参数为观察者</h3><h3 id="empty-不需要传递参数，创建一个空序列并立即结束"><a href="#empty-不需要传递参数，创建一个空序列并立即结束" class="headerlink" title="empty()  不需要传递参数，创建一个空序列并立即结束"></a>empty()  不需要传递参数，创建一个空序列并立即结束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.empty()  =  Rx.Observable.create((o)=&gt;&#123;</span><br><span class="line">    o.onCompleted()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="never-不需要传递参数，创建一个空序列，并永远不结束"><a href="#never-不需要传递参数，创建一个空序列，并永远不结束" class="headerlink" title="never() 不需要传递参数，创建一个空序列，并永远不结束"></a>never() 不需要传递参数，创建一个空序列，并永远不结束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.never()  =  Rx.Observable.create((o)=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="throw-创建一个空序列，参数来声明错误并立即抛出错误"><a href="#throw-创建一个空序列，参数来声明错误并立即抛出错误" class="headerlink" title="throw() 创建一个空序列，参数来声明错误并立即抛出错误"></a>throw() 创建一个空序列，参数来声明错误并立即抛出错误</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.throw(&apos;error&apos;)  =  Rx.Observable.create((o)=&gt;&#123;</span><br><span class="line">    0.onError(&apos;error&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="range-创建一个有线长度的整数序列，两个参数，第一个起始值，第二个元素数量"><a href="#range-创建一个有线长度的整数序列，两个参数，第一个起始值，第二个元素数量" class="headerlink" title="range() 创建一个有线长度的整数序列，两个参数，第一个起始值，第二个元素数量"></a>range() 创建一个有线长度的整数序列，两个参数，第一个起始值，第二个元素数量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.range(30,4)  //输出:30,31,32,33</span><br></pre></td></tr></table></figure>
<h3 id="interval-创建一个无限长度的周期性序列"><a href="#interval-创建一个无限长度的周期性序列" class="headerlink" title="interval() 创建一个无限长度的周期性序列"></a>interval() 创建一个无限长度的周期性序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.interval(1000) //输出:0,1,2...</span><br></pre></td></tr></table></figure>
<h3 id="timer-指定一个额外的参数来调节第一值的静默时长，第二个参数可选，若无则仅仅在规定的静默时长后输出一个值，然后结束序列"><a href="#timer-指定一个额外的参数来调节第一值的静默时长，第二个参数可选，若无则仅仅在规定的静默时长后输出一个值，然后结束序列" class="headerlink" title="timer() 指定一个额外的参数来调节第一值的静默时长，第二个参数可选，若无则仅仅在规定的静默时长后输出一个值，然后结束序列"></a>timer() 指定一个额外的参数来调节第一值的静默时长，第二个参数可选，若无则仅仅在规定的静默时长后输出一个值，然后结束序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.timer(0,1000) //输出:0,1,2...</span><br></pre></td></tr></table></figure>
<h3 id="from-可以将已有的数据转化为Observable-参数为iterable数据集对象-常见Array-String"><a href="#from-可以将已有的数据转化为Observable-参数为iterable数据集对象-常见Array-String" class="headerlink" title="from() 可以将已有的数据转化为Observable,参数为iterable数据集对象,常见Array,String"></a>from() 可以将已有的数据转化为Observable,参数为iterable数据集对象,常见Array,String</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.from(iterable)</span><br></pre></td></tr></table></figure>
<h3 id="of-不在同一个数据集中的多个来源的数据，使用of-方法直接构造："><a href="#of-不在同一个数据集中的多个来源的数据，使用of-方法直接构造：" class="headerlink" title="of()  不在同一个数据集中的多个来源的数据，使用of()方法直接构造："></a>of()  不在同一个数据集中的多个来源的数据，使用of()方法直接构造：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.of([1,2,3])    //    [1,2,3]</span><br><span class="line">Rx.Observable.from([1,2,3])  //    1,2,3</span><br></pre></td></tr></table></figure>
<h3 id="just-将任何数据转化为一个单值输出的Observable"><a href="#just-将任何数据转化为一个单值输出的Observable" class="headerlink" title="just()  将任何数据转化为一个单值输出的Observable"></a>just()  将任何数据转化为一个单值输出的Observable</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.just([1,2,3])    //    [1,2,3]</span><br></pre></td></tr></table></figure>
<h3 id="repeat-创建一个重复值序列-par1-值，par2：次数"><a href="#repeat-创建一个重复值序列-par1-值，par2：次数" class="headerlink" title="repeat() 创建一个重复值序列  par1:值，par2：次数"></a>repeat() 创建一个重复值序列  par1:值，par2：次数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.repeat(&apos;a&apos;,2)    //   a a</span><br></pre></td></tr></table></figure>
<h3 id="fromEvent-将事件流转化为Observable"><a href="#fromEvent-将事件流转化为Observable" class="headerlink" title="fromEvent() 将事件流转化为Observable,"></a>fromEvent() 将事件流转化为Observable,</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var el = document.getElementById(&quot;btn&quot;); //DOM对象作为事件源</span><br><span class="line">Rx.Observable.fromEvent(el,&quot;click&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="toArray-将序列还原为数组对象-只有在订阅后才还原为数组"><a href="#toArray-将序列还原为数组对象-只有在订阅后才还原为数组" class="headerlink" title="toArray() 将序列还原为数组对象,只有在订阅后才还原为数组"></a>toArray() 将序列还原为数组对象,只有在订阅后才还原为数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,3,4);    //序列：1 2 3 4 </span><br><span class="line">var target = source.toArray();     //序列：[1,2,3,4]</span><br><span class="line">target.subscribe(function(d)&#123;</span><br><span class="line">    console.log(d);             //d： [1,2,3,4]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="delay-推迟-参数为数字或Date对象"><a href="#delay-推迟-参数为数字或Date对象" class="headerlink" title="delay() 推迟   参数为数字或Date对象"></a>delay() 推迟   参数为数字或Date对象</h3><h3 id="delaySubscription-延迟订阅-参数同理"><a href="#delaySubscription-延迟订阅-参数同理" class="headerlink" title="delaySubscription() 延迟订阅  参数同理"></a>delaySubscription() 延迟订阅  参数同理</h3><h3 id="startWith-可以在源序列之前添加额外的元素"><a href="#startWith-可以在源序列之前添加额外的元素" class="headerlink" title="startWith() 可以在源序列之前添加额外的元素"></a>startWith() 可以在源序列之前添加额外的元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,3); //序列：1 2 3</span><br><span class="line">var target = source.startWith(7,8,9); //序列：7 8 9 1 2 3</span><br></pre></td></tr></table></figure>
<h3 id="map-对源序列进行变换，并返回新的序列-改变了源"><a href="#map-对源序列进行变换，并返回新的序列-改变了源" class="headerlink" title="map() 对源序列进行变换，并返回新的序列(改变了源)"></a>map() 对源序列进行变换，并返回新的序列(改变了源)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var trandform = function(item)&#123;</span><br><span class="line">    return item*2;</span><br><span class="line">&#125;</span><br><span class="line">var source = Rx.Observable.of(1,2,3); //输出： 1 2 3</span><br><span class="line">var target = source.map(trandform);   //输出： 2 4 6</span><br></pre></td></tr></table></figure>
<h1 id="concat-有序拼接-merge-无序"><a href="#concat-有序拼接-merge-无序" class="headerlink" title="concat() 有序拼接   merge()无序"></a>concat() 有序拼接   merge()无序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,3); //序列：1 2 3</span><br><span class="line">var target = source.concat(</span><br><span class="line">    Rx.Observable.of(4,5,6),</span><br><span class="line">    Rx.Observable.of(7,8,9)</span><br><span class="line">); //序列：1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>
<h3 id="concatAll-如果源序列的元素也是序列-——-序列的序列，那么可以使用concatAll-方法将各元素序列按顺序拼接起来"><a href="#concatAll-如果源序列的元素也是序列-——-序列的序列，那么可以使用concatAll-方法将各元素序列按顺序拼接起来" class="headerlink" title="concatAll()  如果源序列的元素也是序列 —— 序列的序列，那么可以使用concatAll() 方法将各元素序列按顺序拼接起来"></a>concatAll()  如果源序列的元素也是序列 —— 序列的序列，那么可以使用concatAll() 方法将各元素序列按顺序拼接起来</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(10,20,30)</span><br><span class="line">    .map(function(item)&#123;</span><br><span class="line">        return Rx.Observable.range(item,3);</span><br><span class="line">    &#125;); //序列： Observable&#123;10,11,12&#125; Observable&#123;20,21,22&#125; Observable&#123;30,31,32&#125;</span><br><span class="line">var target = source.concatAll(); //序列：10 10 12 20 21 22 30 31 32</span><br></pre></td></tr></table></figure>
<h3 id="catch-捕捉源序列错误，返回新序列"><a href="#catch-捕捉源序列错误，返回新序列" class="headerlink" title="catch()  捕捉源序列错误，返回新序列"></a>catch()  捕捉源序列错误，返回新序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.create(function(o)&#123;</span><br><span class="line">    o.onNext(1);</span><br><span class="line">    o.onNext(2);</span><br><span class="line">    o.onError(new Error(&quot;fake error&quot;));</span><br><span class="line">    o.onNext(4);</span><br><span class="line">&#125;); //序列： 1 2 &lt;ERROR&gt; 4</span><br><span class="line">var target = source.catch(Rx.Observable.from(&quot;abc&quot;)); //序列： 1 2 a b c</span><br></pre></td></tr></table></figure>
<h3 id="pluck-针对元素为json对象的源序列，返回指定属性的值的序列"><a href="#pluck-针对元素为json对象的源序列，返回指定属性的值的序列" class="headerlink" title="pluck()  针对元素为json对象的源序列，返回指定属性的值的序列"></a>pluck()  针对元素为json对象的源序列，返回指定属性的值的序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(&#123;name:&apos;john&apos;,age:33&#125;,&#123;name:&apos;lee&apos;,age:22&#125;);</span><br><span class="line">var target = source.pluck(&apos;name&apos;);  //序列 john lee</span><br></pre></td></tr></table></figure>
<h3 id="flatMap-平坦化映射-首先将一个序列的各元素映射为序列，然后将各序列融合-参数是一个映射函数，返回值为序列"><a href="#flatMap-平坦化映射-首先将一个序列的各元素映射为序列，然后将各序列融合-参数是一个映射函数，返回值为序列" class="headerlink" title="flatMap()  平坦化映射:首先将一个序列的各元素映射为序列，然后将各序列融合  参数是一个映射函数，返回值为序列"></a>flatMap()  平坦化映射:首先将一个序列的各元素映射为序列，然后将各序列融合  参数是一个映射函数，返回值为序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(10,20);</span><br><span class="line">var mf = function(item)&#123;</span><br><span class="line">    return Rx.Observable.range(item,3)</span><br><span class="line">&#125;</span><br><span class="line">var target = source.flatMap(mf)  // 序列：10,11,20,12,21,22</span><br></pre></td></tr></table></figure>
<h3 id="flatMapLatest-与flatMap-的区别在于将最新的序列中的元素输出"><a href="#flatMapLatest-与flatMap-的区别在于将最新的序列中的元素输出" class="headerlink" title="flatMapLatest()  与flatMap()的区别在于将最新的序列中的元素输出"></a>flatMapLatest()  与flatMap()的区别在于将最新的序列中的元素输出</h3><h3 id="concatMap-将源序列各元素映射为序列，然后按顺序拼接-与flatMap的区别所在"><a href="#concatMap-将源序列各元素映射为序列，然后按顺序拼接-与flatMap的区别所在" class="headerlink" title="concatMap()  将源序列各元素映射为序列，然后按顺序拼接 (与flatMap的区别所在)"></a>concatMap()  将源序列各元素映射为序列，然后按顺序拼接 (与flatMap的区别所在)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,3);</span><br><span class="line">var mf = function(item)&#123;</span><br><span class="line">    return Rx.Observable.range(item,3);</span><br><span class="line">&#125;</span><br><span class="line">var target = source.concatMap(mf)  //序列：1,2,3,2,3,4,3,4,5</span><br></pre></td></tr></table></figure>
<h2 id="flatMap与map异同点"><a href="#flatMap与map异同点" class="headerlink" title="flatMap与map异同点"></a>flatMap与map异同点</h2><h3 id="Map用于对自身对象数值进行映射，将发射对象转换成另一个发射对象发射，返回一个包含映射结果的Observable对象。而flatMap是把自身对象里的数值进行映射并转换成一个新的Observable对象-当从其他类型对象中构建Observable对象时，需要使用flatMap方法"><a href="#Map用于对自身对象数值进行映射，将发射对象转换成另一个发射对象发射，返回一个包含映射结果的Observable对象。而flatMap是把自身对象里的数值进行映射并转换成一个新的Observable对象-当从其他类型对象中构建Observable对象时，需要使用flatMap方法" class="headerlink" title="Map用于对自身对象数值进行映射，将发射对象转换成另一个发射对象发射，返回一个包含映射结果的Observable对象。而flatMap是把自身对象里的数值进行映射并转换成一个新的Observable对象.当从其他类型对象中构建Observable对象时，需要使用flatMap方法"></a>Map用于对自身对象数值进行映射，将发射对象转换成另一个发射对象发射，返回一个包含映射结果的Observable对象。而flatMap是把自身对象里的数值进行映射并转换成一个新的Observable对象.当从其他类型对象中构建Observable对象时，需要使用flatMap方法</h3><h2 id="flatMap与concatMap异同点"><a href="#flatMap与concatMap异同点" class="headerlink" title="flatMap与concatMap异同点"></a>flatMap与concatMap异同点</h2><h3 id="merge和map结合与concat和map结合的区别，归根结底为merge与concat的区别，一个无序一个有序"><a href="#merge和map结合与concat和map结合的区别，归根结底为merge与concat的区别，一个无序一个有序" class="headerlink" title="merge和map结合与concat和map结合的区别，归根结底为merge与concat的区别，一个无序一个有序"></a>merge和map结合与concat和map结合的区别，归根结底为merge与concat的区别，一个无序一个有序</h3><h3 id="filter-筛选源序列中满足条件的元素，并返回新的序列"><a href="#filter-筛选源序列中满足条件的元素，并返回新的序列" class="headerlink" title="filter() 筛选源序列中满足条件的元素，并返回新的序列"></a>filter() 筛选源序列中满足条件的元素，并返回新的序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,3,4,5); //序列： 1 2 3 4 5</span><br><span class="line">var target = source.filter(x =&gt; x&lt;4)  //序列： 1 2 3</span><br></pre></td></tr></table></figure>
<h3 id="skip-num-抑制序列头部元素数量输出-skipLast-num-尾部-skipWhile-if-指定一个条件"><a href="#skip-num-抑制序列头部元素数量输出-skipLast-num-尾部-skipWhile-if-指定一个条件" class="headerlink" title="skip(num) 抑制序列头部元素数量输出   skipLast(num)尾部   skipWhile(if)指定一个条件"></a>skip(num) 抑制序列头部元素数量输出   skipLast(num)尾部   skipWhile(if)指定一个条件</h3><h3 id="take-num-截取序列头部元素数量输出-takeLast-num-尾部-takeWhile-if-指定一个条件"><a href="#take-num-截取序列头部元素数量输出-takeLast-num-尾部-takeWhile-if-指定一个条件" class="headerlink" title="take(num) 截取序列头部元素数量输出   takeLast(num)尾部   takeWhile(if)指定一个条件"></a>take(num) 截取序列头部元素数量输出   takeLast(num)尾部   takeWhile(if)指定一个条件</h3><h3 id="distinct-去重-并返回一个新序列"><a href="#distinct-去重-并返回一个新序列" class="headerlink" title="distinct 去重,并返回一个新序列"></a>distinct 去重,并返回一个新序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,3,4,2,1); //序列： 1 2 3 4 2 1</span><br><span class="line">var target = source.distinct(); //序列：1 2 3 4</span><br></pre></td></tr></table></figure>
<h3 id="distinctUntilChanged-去重-并返回一个新序列"><a href="#distinctUntilChanged-去重-并返回一个新序列" class="headerlink" title="distinctUntilChanged 去重,并返回一个新序列"></a>distinctUntilChanged 去重,并返回一个新序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,2,3,4,2,1); //序列： 1 2 3 4 2 1</span><br><span class="line">var target = source.distinctUntilChanged(); //序列：1 2 3 4 2 1</span><br></pre></td></tr></table></figure>
<h3 id="debounce-去抖动-一段时间内只取最新数据作为一次发射数据，其他数据取消发射"><a href="#debounce-去抖动-一段时间内只取最新数据作为一次发射数据，其他数据取消发射" class="headerlink" title="debounce  去抖动,一段时间内只取最新数据作为一次发射数据，其他数据取消发射"></a>debounce  去抖动,一段时间内只取最新数据作为一次发射数据，其他数据取消发射</h3><h3 id="throttle-和debounce唯一区别是debounce取一段时间内最新的，而throttle忽略这段时间后，发现新值才发送-通俗讲，都设定一个时间周期，持续触发事件，throttle为每到时间周期便会触发一次，bebounce为触发周期小于设定时间周期不予事件触发）"><a href="#throttle-和debounce唯一区别是debounce取一段时间内最新的，而throttle忽略这段时间后，发现新值才发送-通俗讲，都设定一个时间周期，持续触发事件，throttle为每到时间周期便会触发一次，bebounce为触发周期小于设定时间周期不予事件触发）" class="headerlink" title="throttle(和debounce唯一区别是debounce取一段时间内最新的，而throttle忽略这段时间后，发现新值才发送, 通俗讲，都设定一个时间周期，持续触发事件，throttle为每到时间周期便会触发一次，bebounce为触发周期小于设定时间周期不予事件触发）"></a>throttle(和debounce唯一区别是debounce取一段时间内最新的，而throttle忽略这段时间后，发现新值才发送, 通俗讲，都设定一个时间周期，持续触发事件，throttle为每到时间周期便会触发一次，bebounce为触发周期小于设定时间周期不予事件触发）</h3><h3 id="buffer-使用第二个序列触发源序列中多个元素的打包"><a href="#buffer-使用第二个序列触发源序列中多个元素的打包" class="headerlink" title="buffer() 使用第二个序列触发源序列中多个元素的打包"></a>buffer() 使用第二个序列触发源序列中多个元素的打包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.timer(0,1000);    //序列：0 1 2 3 ...</span><br><span class="line">var boundaries = Rx.Observable.timer(2500); //延时2500ms触发</span><br><span class="line">var target = source.buffer(boundaries); //序列： [0,1,2]</span><br></pre></td></tr></table></figure>
<h3 id="bufferWithTime-按固定时间间隔对源序列进行打包"><a href="#bufferWithTime-按固定时间间隔对源序列进行打包" class="headerlink" title="bufferWithTime() 按固定时间间隔对源序列进行打包"></a>bufferWithTime() 按固定时间间隔对源序列进行打包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.timer(0,1000); //序列：0 1 2 3 ...</span><br><span class="line">var target = source.bufferWithTime(2500); //序列：[0,1,2] [3,4] ...</span><br></pre></td></tr></table></figure>
<h3 id="zip-支持可变数量的序列作为参数，最后一个参数应当是一个组合函数，-其返回值将作为目标序列的元素"><a href="#zip-支持可变数量的序列作为参数，最后一个参数应当是一个组合函数，-其返回值将作为目标序列的元素" class="headerlink" title="zip()  支持可变数量的序列作为参数，最后一个参数应当是一个组合函数， 其返回值将作为目标序列的元素"></a>zip()  支持可变数量的序列作为参数，最后一个参数应当是一个组合函数， 其返回值将作为目标序列的元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var source1 = Rx.Observable.of(1,2,3); //序列： 1 2 3</span><br><span class="line">var source2 = Rx.Observable.of(4,5,6); //序列：4 5 6</span><br><span class="line">var cf = function(d1,d2)&#123; return d1 + &apos;-&apos; + d2;&#125;;</span><br><span class="line">var target = Rx.Observable.zip(source1,source2,cf); //序列： 1-4 2-5 3-6</span><br></pre></td></tr></table></figure>
<h3 id="forkJoin-将多个序列的最后一个元素组合为一个数组后，作为目标序列的唯一元素"><a href="#forkJoin-将多个序列的最后一个元素组合为一个数组后，作为目标序列的唯一元素" class="headerlink" title="forkJoin()  将多个序列的最后一个元素组合为一个数组后，作为目标序列的唯一元素"></a>forkJoin()  将多个序列的最后一个元素组合为一个数组后，作为目标序列的唯一元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var source1 = Rx.Observable.of(1,2,3); //序列： 1 2 3</span><br><span class="line">var source2 = Rx.Observable.of(4,5,6); //序列： 4 5 6</span><br><span class="line">var target = Rz.Observable.forkJoin(source1,source2); //序列：[3,6]</span><br></pre></td></tr></table></figure>
<h3 id="combineLatest-将多个序列的最后一个元素，使用组合函数构成目标序列的一个新元素"><a href="#combineLatest-将多个序列的最后一个元素，使用组合函数构成目标序列的一个新元素" class="headerlink" title="combineLatest() 将多个序列的最后一个元素，使用组合函数构成目标序列的一个新元素"></a>combineLatest() 将多个序列的最后一个元素，使用组合函数构成目标序列的一个新元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var source1 = Rx.Observable.interval(200).map(x =&gt; &apos;First:&apos; + x)</span><br><span class="line">var source2 = Rx.Observable.interval(100).map(x =&gt; &apos;Second:&apos; + x)</span><br><span class="line">var source = Rx.Observable.combineLatest(</span><br><span class="line">    source1,</span><br><span class="line">    source2</span><br><span class="line">).take(4);   // [&quot;First:0&quot;, &quot;Second:0&quot;]  [&quot;First:0&quot;, &quot;Second:1&quot;]  [&quot;First:0&quot;, &quot;Second:2&quot;]   [&quot;First:1&quot;, &quot;Second:2&quot;]</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/21/ng1与ng2依赖注入的比较/" itemprop="url">
                  依赖注入
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-11-21T09:35:40+08:00" content="2016-11-21">
              2016-11-21
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="依赖注入是一种软件设计模式，他允许你移除软件组件的硬编码方式，替代的是通过依赖注入制造低耦合的组件不论在编译阶段还是在运行阶段。硬编码就是在程序中将代码写死，低耦合就是尽量让每个模块独立，相关的处理尽量在单个模块中完成。"><a href="#依赖注入是一种软件设计模式，他允许你移除软件组件的硬编码方式，替代的是通过依赖注入制造低耦合的组件不论在编译阶段还是在运行阶段。硬编码就是在程序中将代码写死，低耦合就是尽量让每个模块独立，相关的处理尽量在单个模块中完成。" class="headerlink" title="依赖注入是一种软件设计模式，他允许你移除软件组件的硬编码方式，替代的是通过依赖注入制造低耦合的组件不论在编译阶段还是在运行阶段。硬编码就是在程序中将代码写死，低耦合就是尽量让每个模块独立，相关的处理尽量在单个模块中完成。"></a>依赖注入是一种软件设计模式，他允许你移除软件组件的硬编码方式，替代的是通过依赖注入制造低耦合的组件不论在编译阶段还是在运行阶段。硬编码就是在程序中将代码写死，低耦合就是尽量让每个模块独立，相关的处理尽量在单个模块中完成。</h3><p><br></p>
<h3 id="AngularJs有一个内在的注入机制，他可以把你的App分成许多个可重复使用的组件，当需要的时候通过依赖注入把这些自减注入进你的App中去。在需要的地方进行参数传递，这种方法不仅对测试很有用，而且还不会污染全局变量，是很好的设计模式。"><a href="#AngularJs有一个内在的注入机制，他可以把你的App分成许多个可重复使用的组件，当需要的时候通过依赖注入把这些自减注入进你的App中去。在需要的地方进行参数传递，这种方法不仅对测试很有用，而且还不会污染全局变量，是很好的设计模式。" class="headerlink" title="AngularJs有一个内在的注入机制，他可以把你的App分成许多个可重复使用的组件，当需要的时候通过依赖注入把这些自减注入进你的App中去。在需要的地方进行参数传递，这种方法不仅对测试很有用，而且还不会污染全局变量，是很好的设计模式。"></a>AngularJs有一个内在的注入机制，他可以把你的App分成许多个可重复使用的组件，当需要的时候通过依赖注入把这些自减注入进你的App中去。在需要的地方进行参数传递，这种方法不仅对测试很有用，而且还不会污染全局变量，是很好的设计模式。</h3><p><br></p>
<h2 id="AngularJS依赖注入的方法"><a href="#AngularJS依赖注入的方法" class="headerlink" title="AngularJS依赖注入的方法"></a>AngularJS依赖注入的方法</h2><ol>
<li>通过函数的参数进行推断式注入声明<h3 id="如果没有明确的声明，AngularJS会假定名称就是依赖的名称。因此，它会在内部调用函数对象的toString-方法，分析并提取函数的参数列表，然后通过-injector将这些参数再注入进对象实例。下面是代码示例："><a href="#如果没有明确的声明，AngularJS会假定名称就是依赖的名称。因此，它会在内部调用函数对象的toString-方法，分析并提取函数的参数列表，然后通过-injector将这些参数再注入进对象实例。下面是代码示例：" class="headerlink" title="如果没有明确的声明，AngularJS会假定名称就是依赖的名称。因此，它会在内部调用函数对象的toString()方法，分析并提取函数的参数列表，然后通过$injector将这些参数再注入进对象实例。下面是代码示例："></a>如果没有明确的声明，AngularJS会假定名称就是依赖的名称。因此，它会在内部调用函数对象的toString()方法，分析并提取函数的参数列表，然后通过$injector将这些参数再注入进对象实例。下面是代码示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function myController($scope,$timeout)&#123;</span><br><span class="line">	var updateTime = function()&#123;</span><br><span class="line">		$scope.clock = &#123;</span><br><span class="line">			time: new Date()</span><br><span class="line">		&#125;;</span><br><span class="line">		$timeout(function()&#123;</span><br><span class="line">			$scope.clock.time = new Date();</span><br><span class="line">			updateTime();</span><br><span class="line">		&#125;,1000)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ng-controller=&apos;myController&apos;&gt;</span><br><span class="line">	&lt;span&gt;&#123;&#123;clock.time | data:&apos;yyyy-MM-dd hh:mm:ss&apos;&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="创建了一个可以自动更新时间的应用，看看是如何进行依赖注入的。通过设置参数-scope和-timeout，angular会在内部调用函数的toString-方法，分析并提取函数的参数列表，然后通过-injector将这些参数注入到对象的实例。"><a href="#创建了一个可以自动更新时间的应用，看看是如何进行依赖注入的。通过设置参数-scope和-timeout，angular会在内部调用函数的toString-方法，分析并提取函数的参数列表，然后通过-injector将这些参数注入到对象的实例。" class="headerlink" title="创建了一个可以自动更新时间的应用，看看是如何进行依赖注入的。通过设置参数$scope和$timeout，angular会在内部调用函数的toString()方法，分析并提取函数的参数列表，然后通过$injector将这些参数注入到对象的实例。"></a>创建了一个可以自动更新时间的应用，看看是如何进行依赖注入的。通过设置参数$scope和$timeout，angular会在内部调用函数的toString()方法，分析并提取函数的参数列表，然后通过$injector将这些参数注入到对象的实例。</h3><p><br></p>
<p><font color="#f00" size="5" face="黑体">注意：</font><br><br></p>
<ul>
<li>此方法只适合未经压缩混淆的代码，因为angular需要解析未经压缩混淆的参数列表。<br><br></li>
</ul>
<ol start="2">
<li>显式的注入声明<h3 id="显式的明确定义一个函数在被调用时需要用到的依赖关系，通过这种方法声明依赖，即使在源代码被压缩，参数名称发生改变的情况下依然可以工作。代码示例："><a href="#显式的明确定义一个函数在被调用时需要用到的依赖关系，通过这种方法声明依赖，即使在源代码被压缩，参数名称发生改变的情况下依然可以工作。代码示例：" class="headerlink" title="显式的明确定义一个函数在被调用时需要用到的依赖关系，通过这种方法声明依赖，即使在源代码被压缩，参数名称发生改变的情况下依然可以工作。代码示例："></a>显式的明确定义一个函数在被调用时需要用到的依赖关系，通过这种方法声明依赖，即使在源代码被压缩，参数名称发生改变的情况下依然可以工作。代码示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var mycontrollerFactory = function mycontroller($scope,$timeout)&#123;</span><br><span class="line">	var updateTime = function () &#123;</span><br><span class="line">        $scope.clock = &#123;</span><br><span class="line">            time: new Date()</span><br><span class="line">        &#125;;</span><br><span class="line">        $timeout(function () &#123;</span><br><span class="line">            $scope.clock.time = new Date();</span><br><span class="line">            updateTime();</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">    &#125;</span><br><span class="line">    updateTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mycontrollerFactory.$inject = [&apos;$scope&apos;,&apos;$timeout&apos;];</span><br></pre></td></tr></table></figure>
<h3 id="显式的将我们需要的依赖注入到函数中，所以在函数中参数也可以分别换成其他字段。"><a href="#显式的将我们需要的依赖注入到函数中，所以在函数中参数也可以分别换成其他字段。" class="headerlink" title="显式的将我们需要的依赖注入到函数中，所以在函数中参数也可以分别换成其他字段。"></a>显式的将我们需要的依赖注入到函数中，所以在函数中参数也可以分别换成其他字段。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var mycontrollerFactory = function mycontroller(s,t)&#123;.....&#125;</span><br></pre></td></tr></table></figure>
<p><font color="#f00" size="5" face="黑体">注意：</font><br><br></p>
<ul>
<li>对于这种声明方式，参数的顺序是十分重要的，因为$inject数组元素的顺序必须和注入的参数顺序一一对应。<br><br></li>
</ul>
<ol start="3">
<li>行内注入声明<h3 id="angular提供的行内注入方法实际上是一种语法糖，它与前面的提到的通过-inject属性进行声明的原理是一样的，但是允许我们在函数定义的时候从行内将参数传入，这种方法方便简洁，而且避免了在定义的过程中使用临时变量。"><a href="#angular提供的行内注入方法实际上是一种语法糖，它与前面的提到的通过-inject属性进行声明的原理是一样的，但是允许我们在函数定义的时候从行内将参数传入，这种方法方便简洁，而且避免了在定义的过程中使用临时变量。" class="headerlink" title="angular提供的行内注入方法实际上是一种语法糖，它与前面的提到的通过$inject属性进行声明的原理是一样的，但是允许我们在函数定义的时候从行内将参数传入，这种方法方便简洁，而且避免了在定义的过程中使用临时变量。"></a>angular提供的行内注入方法实际上是一种语法糖，它与前面的提到的通过$inject属性进行声明的原理是一样的，但是允许我们在函数定义的时候从行内将参数传入，这种方法方便简洁，而且避免了在定义的过程中使用临时变量。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">angular.module(&apos;app&apos;,[])</span><br><span class="line">.controller(&apos;mycontroller&apos;,[&apos;$scope&apos;,&apos;$timeout&apos;,function($scope,$timeout)&#123;</span><br><span class="line">	var updateTime = function () &#123;</span><br><span class="line">        $scope.clock = &#123;</span><br><span class="line">            time: new Date()</span><br><span class="line">        &#125;;</span><br><span class="line">        $timeout(function () &#123;</span><br><span class="line">            $scope.clock.time = new Date();</span><br><span class="line">            updateTime();</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">    &#125;</span><br><span class="line">    updateTime();</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><font color="#f00" size="5" face="黑体">注意：</font><br><br></p>
<ul>
<li>行内声明的方式允许我们直接传入一个参数数组，而不是一个函数，数组的元素是字符串，他们代表的是可以被注入到对象中的依赖名字，最后一个参数就是依赖注入的目标函数对象本身。</li>
</ul>
<h2 id="下面来对比一下ng1与ng2的依赖注入的区别，以login组件为例"><a href="#下面来对比一下ng1与ng2的依赖注入的区别，以login组件为例" class="headerlink" title="下面来对比一下ng1与ng2的依赖注入的区别，以login组件为例"></a>下面来对比一下ng1与ng2的依赖注入的区别，以login组件为例</h2><h2 id="先来看一下angular2的架构图"><a href="#先来看一下angular2的架构图" class="headerlink" title="先来看一下angular2的架构图"></a>先来看一下angular2的架构图</h2><p><img src="http://upload-images.jianshu.io/upload_images/949077-ce2193b397ce7ee8.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="providerToservice"><br><br><br><em>Angular1</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Login&#123;</span><br><span class="line">    formValue : &#123;login:string,password:string&#125; = &#123;login:&apos;&apos;,password:&apos;&apos;&#125;;</span><br><span class="line">    onSubmit()&#123;</span><br><span class="line">        const service = new LoginService();</span><br><span class="line">        service.login(this.formValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.component(&apos;login&apos;,&#123;</span><br><span class="line">    controller: Login,</span><br><span class="line">    controllerAs ; &apos;ctrl&apos;,</span><br><span class="line">    template:`</span><br><span class="line">        &lt;form ng-submit = &quot;ctrl.onSubmit()&quot;&gt;</span><br><span class="line">        Text &lt;input type=&quot;text&quot; ng-model=&quot;ctrl.formValue.login&gt;</span><br><span class="line">        password  &lt;input type=&quot;password&quot; ng-model=&quot;ctrl.formValue.password&quot;&gt;</span><br><span class="line">        &lt;button&gt;submit&lt;/button&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><em>Angular2</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector:&apos;login&apos;,</span><br><span class="line">    template:`</span><br><span class="line">        .....</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br><span class="line">class Login&#123;</span><br><span class="line">    onSubmit(formValue:&#123;login:string,password:string&#125;)&#123;</span><br><span class="line">        const service = new LoginService();</span><br><span class="line">        service.login(formValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="在这里直接把login组件绑定在login-service上的，很难进行独立测试，也降低了它复用的可能性"><a href="#在这里直接把login组件绑定在login-service上的，很难进行独立测试，也降低了它复用的可能性" class="headerlink" title="在这里直接把login组件绑定在login service上的，很难进行独立测试，也降低了它复用的可能性"></a>在这里直接把login组件绑定在login service上的，很难进行独立测试，也降低了它复用的可能性</h3><p><br></p>
<h2 id="with-DI"><a href="#with-DI" class="headerlink" title="with DI"></a>with DI</h2><h3 id="在构造函数里面注射一个LoginService的实例，而不是直接创建"><a href="#在构造函数里面注射一个LoginService的实例，而不是直接创建" class="headerlink" title="在构造函数里面注射一个LoginService的实例，而不是直接创建"></a>在构造函数里面注射一个LoginService的实例，而不是直接创建</h3><p><em>Angular1</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Login&#123;</span><br><span class="line">    formValue : &#123;login:string,password:string&#125; = &#123;login:&apos;&apos;,password:&apos;&apos;&#125;;</span><br><span class="line">    constructor(public service:LoginService)&#123;&#125;</span><br><span class="line">    onSubmit()&#123;</span><br><span class="line">        this.service.login(this.formValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="我们还需要告诉框架应该创建这个service的实例"><a href="#我们还需要告诉框架应该创建这个service的实例" class="headerlink" title="我们还需要告诉框架应该创建这个service的实例"></a>我们还需要告诉框架应该创建这个service的实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.service(&apos;login&apos;,LoginService);</span><br></pre></td></tr></table></figure>
<p><br><br><em>Angular2</em></p>
<h3 id="同样，在构造函数里面注射一个LoginSerivce的实例"><a href="#同样，在构造函数里面注射一个LoginSerivce的实例" class="headerlink" title="同样，在构造函数里面注射一个LoginSerivce的实例"></a>同样，在构造函数里面注射一个LoginSerivce的实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Login&#123;</span><br><span class="line">    constructor(public service: LoginService)&#123;&#125;</span><br><span class="line">    onSubmit(formValue:&#123;login:string,password:string&#125;)&#123;</span><br><span class="line">        this.service.login(formValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不同于ng1，我们需要将这个service添加到providers列表里面来实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@NgModule(&#123;</span><br><span class="line">    bootstrap:[Login],</span><br><span class="line">    providers:[LoginService],</span><br><span class="line">    declarations:[Login]</span><br><span class="line">&#125;)</span><br><span class="line">class AppModule&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="如果注入到它的根模块，则整个应用都可以调用，也可以注入到使用它的组件元数据里面-只需在装饰器加上一个providers配置项-这样注入的服务只对自己和后代可用"><a href="#如果注入到它的根模块，则整个应用都可以调用，也可以注入到使用它的组件元数据里面-只需在装饰器加上一个providers配置项-这样注入的服务只对自己和后代可用" class="headerlink" title="如果注入到它的根模块，则整个应用都可以调用，也可以注入到使用它的组件元数据里面,只需在装饰器加上一个providers配置项,这样注入的服务只对自己和后代可用"></a>如果注入到它的根模块，则整个应用都可以调用，也可以注入到使用它的组件元数据里面,只需在装饰器加上一个providers配置项,这样注入的服务只对自己和后代可用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector:&apos;lr&apos;,</span><br><span class="line">    providers:[LoginService]</span><br><span class="line">&#125;)</span><br><span class="line">class APPLr&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><font color="#f00" size="5" face="黑体">注意：</font></p>
<ul>
<li>ng1依赖于字符串来配置DI，而ng2则默认使用注解的方式<h3 id="ng1里面有好几个Api可以用来给指令注入依赖，有些是根据名称注入的（LoginService）-有些依赖会一直自动提供（link函数里面的），有些需要使用require进行配置"><a href="#ng1里面有好几个Api可以用来给指令注入依赖，有些是根据名称注入的（LoginService）-有些依赖会一直自动提供（link函数里面的），有些需要使用require进行配置" class="headerlink" title="ng1里面有好几个Api可以用来给指令注入依赖，有些是根据名称注入的（LoginService）,有些依赖会一直自动提供（link函数里面的），有些需要使用require进行配置"></a>ng1里面有好几个Api可以用来给指令注入依赖，有些是根据名称注入的（LoginService）,有些依赖会一直自动提供（link函数里面的），有些需要使用require进行配置</h3><br><h3 id="ng2提供了统一的Api用来注入服务，指令等，所有这些内容都会被注入到组件的构造函数里面"><a href="#ng2提供了统一的Api用来注入服务，指令等，所有这些内容都会被注入到组件的构造函数里面" class="headerlink" title="ng2提供了统一的Api用来注入服务，指令等，所有这些内容都会被注入到组件的构造函数里面"></a>ng2提供了统一的Api用来注入服务，指令等，所有这些内容都会被注入到组件的构造函数里面</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li>
<li>DI是ng的核心机制之一</li>
<li>他可以使你的代码更加松耦合</li>
<li>提升了可测试性</li>
<li>ng2采用了统一的Api来给组件注入依赖</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/18/何时使用指令，服务，控制器/" itemprop="url">
                  何时使用指令，服务，控制器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-11-18T15:13:33+08:00" content="2016-11-18">
              2016-11-18
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>Directive(指令)</li>
<li>Controller(控制器)</li>
<li>Service(服务)<br>以上为angular1的核心概念，我们究竟什么以什么样的方式去使用它们。<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h3 id="Service是单例对象，会经常被传来传去，但是可以保证每次访问的都是同一个实例。所以很多Controler和Directive可以访问它内部的数值，所以它是一个存放数据，实现数据共享的好地方"><a href="#Service是单例对象，会经常被传来传去，但是可以保证每次访问的都是同一个实例。所以很多Controler和Directive可以访问它内部的数值，所以它是一个存放数据，实现数据共享的好地方" class="headerlink" title="Service是单例对象，会经常被传来传去，但是可以保证每次访问的都是同一个实例。所以很多Controler和Directive可以访问它内部的数值，所以它是一个存放数据，实现数据共享的好地方;"></a>Service是单例对象，会经常被传来传去，但是可以保证每次访问的都是同一个实例。所以很多Controler和Directive可以访问它内部的数值，所以它是一个存放数据，实现数据共享的好地方;</h3><br><h3 id="首先创建一个module"><a href="#首先创建一个module" class="headerlink" title="首先创建一个module,"></a>首先创建一个module,</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var module = angular.module(&apos;myModule,[]&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br><br>下一步，创建一个服务，用来管理图书的BookService;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module.factory(&apos;BookService&apos;,[&apos;rootScope&apos;,function($rootScope)&#123;</span><br><span class="line">	var service = &#123;</span><br><span class="line">		books:[</span><br><span class="line">			&#123; title: &quot;Magician&quot;, author: &quot;Raymond E. Feist&quot; &#125;,</span><br><span class="line">			&#123; title: &quot;The Hobbit&quot;, author: &quot;J.R.R Tolkien&quot; &#125;</span><br><span class="line">		],</span><br><span class="line">		addbook : function(book)&#123;</span><br><span class="line">			service.books.push(book);</span><br><span class="line">			$rootScope.$broadcast(&apos;books.updata&apos;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return service;</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure></p>
<h3 id="这里很好理解，一个对象里面有我要存放的书的集合，还有一个添加图书的方法，这个方法还会在应用上广播一个事件，告诉所有使用我们的服务的人，存放书的集合已经更新了，接下来就是要使用它的东西需要接收这个广播了。"><a href="#这里很好理解，一个对象里面有我要存放的书的集合，还有一个添加图书的方法，这个方法还会在应用上广播一个事件，告诉所有使用我们的服务的人，存放书的集合已经更新了，接下来就是要使用它的东西需要接收这个广播了。" class="headerlink" title="这里很好理解，一个对象里面有我要存放的书的集合，还有一个添加图书的方法，这个方法还会在应用上广播一个事件，告诉所有使用我们的服务的人，存放书的集合已经更新了，接下来就是要使用它的东西需要接收这个广播了。"></a>这里很好理解，一个对象里面有我要存放的书的集合，还有一个添加图书的方法，这个方法还会在应用上广播一个事件，告诉所有使用我们的服务的人，存放书的集合已经更新了，接下来就是要使用它的东西需要接收这个广播了。</h3><p><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.controller(&apos;books.list&apos;,[&apos;$scope&apos;,&apos;BookService&apos;,function($scope,BookServie)&#123;</span><br><span class="line">	$scope.$on(&apos;books.updata&apos;,function(event)&#123;</span><br><span class="line">		$scope.books = BookService.books;</span><br><span class="line">		$scope.$apply();</span><br><span class="line">	&#125;);</span><br><span class="line">	$scope.books = BookService.books;</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure></p>
<h3 id="这里就是将前面创建的BookService中存放的books赋值给了controller内部的scope对象。如果我们在controller上创建一个数组，其他地方也要处理书籍的信息，通过scope来维护数据会很麻烦，scope很容易变得混乱不堪，通过一种集中的途径进行数据的管理，更容易理解也可以使代码模块化。所以当需要在不同的地方共享数据的时候，就要依靠服务了，谁要用就注入到谁那里，就这么容易。"><a href="#这里就是将前面创建的BookService中存放的books赋值给了controller内部的scope对象。如果我们在controller上创建一个数组，其他地方也要处理书籍的信息，通过scope来维护数据会很麻烦，scope很容易变得混乱不堪，通过一种集中的途径进行数据的管理，更容易理解也可以使代码模块化。所以当需要在不同的地方共享数据的时候，就要依靠服务了，谁要用就注入到谁那里，就这么容易。" class="headerlink" title="这里就是将前面创建的BookService中存放的books赋值给了controller内部的scope对象。如果我们在controller上创建一个数组，其他地方也要处理书籍的信息，通过scope来维护数据会很麻烦，scope很容易变得混乱不堪，通过一种集中的途径进行数据的管理，更容易理解也可以使代码模块化。所以当需要在不同的地方共享数据的时候，就要依靠服务了，谁要用就注入到谁那里，就这么容易。"></a>这里就是将前面创建的BookService中存放的books赋值给了controller内部的scope对象。如果我们在controller上创建一个数组，其他地方也要处理书籍的信息，通过scope来维护数据会很麻烦，scope很容易变得混乱不堪，通过一种集中的途径进行数据的管理，更容易理解也可以使代码模块化。所以当需要在不同的地方共享数据的时候，就要依靠服务了，谁要用就注入到谁那里，就这么容易。</h3><p><br></p>
<h3 id="形容服务有一个例子特别的形象，A团A连和B团B连去执行任务，"><a href="#形容服务有一个例子特别的形象，A团A连和B团B连去执行任务，" class="headerlink" title="形容服务有一个例子特别的形象，A团A连和B团B连去执行任务，"></a>形容服务有一个例子特别的形象，A团A连和B团B连去执行任务，</h3><p>A团A连发现敌情，要报告给B团B连，军队里只有服从上级，所以他只能报告给A团A营，在一直向上报告直到A、B共同的长官C旅，C旅在下发给B团，直到B连，要是有个特殊情况，相信这时候B连已经死光了，所以才有了通信部门的存在，而这里的通信部门也就是angular中的服务。</p>
<h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><h3 id="Controller应该纯粹的把Service，依赖关系，以及其他对象串连在一起，通过scope关联到view上。Dom操作的部分最好把它放入指令里面"><a href="#Controller应该纯粹的把Service，依赖关系，以及其他对象串连在一起，通过scope关联到view上。Dom操作的部分最好把它放入指令里面" class="headerlink" title="Controller应该纯粹的把Service，依赖关系，以及其他对象串连在一起，通过scope关联到view上。Dom操作的部分最好把它放入指令里面;"></a>Controller应该纯粹的把Service，依赖关系，以及其他对象串连在一起，通过scope关联到view上。Dom操作的部分最好把它放入指令里面;</h3><p><br></p>
<h2 id="Directive"><a href="#Directive" class="headerlink" title="Directive"></a>Directive</h2><h3 id="应用中最复杂的部分应该在指令中，下面来扩展前面的例子，提供一个按钮，通过这个按钮向服务里面添加一本书。"><a href="#应用中最复杂的部分应该在指令中，下面来扩展前面的例子，提供一个按钮，通过这个按钮向服务里面添加一本书。" class="headerlink" title="应用中最复杂的部分应该在指令中，下面来扩展前面的例子，提供一个按钮，通过这个按钮向服务里面添加一本书。"></a>应用中最复杂的部分应该在指令中，下面来扩展前面的例子，提供一个按钮，通过这个按钮向服务里面添加一本书。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module.directive(&apos;addBookButton&apos;,[&apos;BookService&apos;,function(BookService)&#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		restrict:&apos;EA&apos;,</span><br><span class="line">		replace:true,</span><br><span class="line">		link:function(scope,ele,attrs)&#123;</span><br><span class="line">			ele.bind(&apos;click&apos;,function()&#123;</span><br><span class="line">				BookService.addbook(&#123; title: &quot;Star Wars&quot;, author: &quot;George Lucas&quot; &#125;);</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure>
<h3 id="创建了一个指令，目的是向books集合里面添加一本书，books已经注册在服务中，所以可以直接注入服务进行使用。下面将指令应用到视图中"><a href="#创建了一个指令，目的是向books集合里面添加一本书，books已经注册在服务中，所以可以直接注入服务进行使用。下面将指令应用到视图中" class="headerlink" title="创建了一个指令，目的是向books集合里面添加一本书，books已经注册在服务中，所以可以直接注入服务进行使用。下面将指令应用到视图中"></a>创建了一个指令，目的是向books集合里面添加一本书，books已经注册在服务中，所以可以直接注入服务进行使用。下面将指令应用到视图中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button add-book-button&gt;Add Book&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="每当点击按钮的时候都会添加那本书，如果将控制器上面添加一个addBook方法呢，"><a href="#每当点击按钮的时候都会添加那本书，如果将控制器上面添加一个addBook方法呢，" class="headerlink" title="每当点击按钮的时候都会添加那本书，如果将控制器上面添加一个addBook方法呢，"></a>每当点击按钮的时候都会添加那本书，如果将控制器上面添加一个addBook方法呢，</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$scope.addBook = function()&#123;</span><br><span class="line">	 BookService.addBook( &#123; title: &quot;Star Wars&quot;, author: &quot;George Lucas&quot; &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可以得到同样的结果，但是如果需要复用的话，只能copy这段代码，但是通过指令的方式，就会很方便了"><a href="#可以得到同样的结果，但是如果需要复用的话，只能copy这段代码，但是通过指令的方式，就会很方便了" class="headerlink" title="可以得到同样的结果，但是如果需要复用的话，只能copy这段代码，但是通过指令的方式，就会很方便了"></a>可以得到同样的结果，但是如果需要复用的话，只能copy这段代码，但是通过指令的方式，就会很方便了</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image" src="https://github.com/vernvn/hexoBlog/blob/master/avator/github.jpg?raw=true" alt="Lee">
          <p class="site-author-name" itemprop="name">Lee</p>
          <p class="site-description motion-element" itemprop="description">my blog</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">25</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lee</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lee/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lee/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lee/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lee/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lee/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lee/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

  


</body>
</html>
