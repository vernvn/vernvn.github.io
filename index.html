<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://vernvn.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上">
<meta property="og:type" content="website">
<meta property="og:title" content="努力混迹江湖的前端小白">
<meta property="og:url" content="http:&#x2F;&#x2F;vernvn.github.io&#x2F;index.html">
<meta property="og:site_name" content="努力混迹江湖的前端小白">
<meta property="og:description" content="保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://vernvn.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>努力混迹江湖的前端小白</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="努力混迹江湖的前端小白" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">努力混迹江湖的前端小白</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">25</span></a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vernvn.github.io/2019/11/17/2019-resume/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/17755520?s=400&u=9f444bfe70cd719b9bf43ed5fedac2f1d005ff5a&v=4">
      <meta itemprop="name" content="Lee_Ran">
      <meta itemprop="description" content="保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力混迹江湖的前端小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/17/2019-resume/" class="post-title-link" itemprop="url">2019 RESUME</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-17 14:00:06" itemprop="dateCreated datePublished" datetime="2019-11-17T14:00:06+08:00">2019-11-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-21 10:26:50" itemprop="dateModified" datetime="2019-11-21T10:26:50+08:00">2019-11-21</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>总结2019年的收获、巩固知识点</p>
</blockquote>
<ul>
<li>http</li>
<li>es6/es7/es8</li>
<li>pwa</li>
<li>angular</li>
<li>rxjs</li>
<li>flutter</li>
<li>微信</li>
<li>webpack</li>
<li>其他知识点</li>
</ul>
<h2 id="Let’s-Review"><a href="#Let’s-Review" class="headerlink" title="Let’s Review  !"></a>Let’s Review  !</h2><h3 id="一、HTTP"><a href="#一、HTTP" class="headerlink" title="一、HTTP"></a>一、HTTP</h3><h4 id="1-GET-POST"><a href="#1-GET-POST" class="headerlink" title="1. GET/POST"></a>1. GET/POST</h4><p>GET / POST主要区别：属于HTTP协议的两种请求方式，协议规定get用于获取信息，post用于修改数据；当携带参数时，get的参数在url里且长度大多受到服务器或浏览器限制（1024字符），post在body里，post传输的参数在地址栏里不可见所以安全性比get略好，但是在数据传输过程中，他们都是可以被捕获的，所以都是不安全的，所以需要进行加密处理，用到https。本质上最大的区别在于get请求是幂等性的，post不是，引用HTTP协议：</p>
<blockquote>
<p>Methods can also have the property of “idempotence” in that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as for a single request.</p>
</blockquote>
<p>HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用, GET <a href="http://www.xxx.com/article/1" target="_blank" rel="noopener">http://www.xxx.com/article/1</a>, 无论调用多少次，获取的只是这一篇文章， 如果POST <a href="http://www.xxx.com/article/1" target="_blank" rel="noopener">http://www.xxx.com/article/1</a>, 相当于创建一篇文章，如果没有唯一索引（唯一索引保证其幂等性），则每调用一次，都会创建一篇文章，post不具有幂等性。delete，put同样具有幂等性，所以在http协议下get更适合获取，post更适合创建，put更适合更新，现如今更多的只是语义上的区别</p>
<h4 id="2-HTTP报文"><a href="#2-HTTP报文" class="headerlink" title="2. HTTP报文"></a>2. HTTP报文</h4><p>http报文有请求报文和响应报文两种。请求报文是从客户端向服务器发送请求报文，响应报文是服务端的回答<br>一个请求报文由四部分组成：请求行、请求头、空行、请求数据。<br>请求行包括请求方法字段、url字段、http协议版本字段，并用空格分隔<br>GET /index.html HTTP/1.1<br>请求头有字值对组成，典型的请求头有user-agent:浏览器类型，accept:客户端可识别的内容类型列表，host:请求的主机名，accept-encoding：允许的压缩方式，connection:keep-alive保持客户端到服务器连结持续有效，当后续触发请求时，避免建立连接释放连接的开销<br>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器之后不会再有请求头<br>请求数据中常见的有content-type的几个常用类型：application/x-www-form-urlencoded—form表单，multipart/form-data—文件，application/json—JSON字符串</p>
<h4 id="4-URL加载全过程"><a href="#4-URL加载全过程" class="headerlink" title="4. URL加载全过程"></a>4. URL加载全过程</h4><p>DNS解析（递归查询）—TCP连接—发送http请求—服务器处理请求响应—浏览器解析渲染—结束连接<br>DNS查找缓存顺序：浏览器缓存——&gt;hosts文件——&gt;路由器缓存——&gt;网络服务商缓存——&gt;根域名服务器缓存</p>
<h4 id="5-HTTPS"><a href="#5-HTTPS" class="headerlink" title="5. HTTPS"></a>5. HTTPS</h4><p>HTTP报文是包裹在TCP报文中发送的，服务器端收到TCP报文时会解包提取出HTTP报文。但是这个过程中存在一定的风险，HTTP报文是明文，如果中间被截取的话会存在一些信息泄露的风险。那么在进入TCP报文之前对HTTP做一次加密就可以解决这个问题了。HTTPS协议的本质就是HTTP + SSL(or TLS)。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL使用了非对称加密，对称加密以及hash等</p>
<p><a href="https://zhuanlan.zhihu.com/p/27395037" target="_blank" rel="noopener">HTTPS原理详解</a></p>
<h4 id="7-HTTP缓存"><a href="#7-HTTP缓存" class="headerlink" title="7. HTTP缓存"></a>7. HTTP缓存</h4><p>HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(强制缓存，对比缓存)。对于强制缓存来说，响应header中会有两个字段来标明失效规则（Expires/Cache-Control）Cache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。常见的http缓存只能缓存get请求响应的资源，对于其他类型的响应则无能为力。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private:             客户端可以缓存</span><br><span class="line">public:              客户端和代理服务器都可缓存</span><br><span class="line">max-age=xxx:         缓存的内容将在 xxx 秒后失效</span><br><span class="line">no-cache:            需要使用对比缓存来验证缓存数据（后面介绍）</span><br><span class="line">no-store:            所有内容都不会缓存，强制缓存，对比缓存都不会触发</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/4845448-39248bf4a3b45c3e?imageMogr2/auto-orient/strip|imageView2/2/w/800/format/webp" alt=""><br><a href="https://juejin.im/entry/599afbe5f265da247c4ee6e3" target="_blank" rel="noopener">HTTP缓存机制详解</a></p>
<h4 id="8-cors预请求"><a href="#8-cors预请求" class="headerlink" title="8. cors预请求"></a>8. cors预请求</h4><p>很多时候发送一个post请求之前会先发送一个options请求，为什么会这样？cors本身是一种机制（跨域资源共享），为跨域访问提供了安全的数据传输。options作为预请求主要用途有两个：获取服务器支持的http请求方法，检查服务器的性能；ajax进行跨域请求时，需要向另一个域名的资源发送一个options请求用于判断实际要发出的请求是否安全。本身从不同的域访问资源是受到同源策略禁止的，所以cors定义了这种浏览器和服务器交互的形式允许跨域请求。现阶段大部分浏览器都支持cors机制，服务端则需要配置Access-Control-Allow-Origin:*,允许任何域发起请求。<br>不会触发cors预检的请求称之为简单请求，日常开发满足下列条件的称之为简单请求：1.使用get,post,head其中一种；2.只使用了如下的安全首部字段，没有人为的设置其他首部字段：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type仅限：text/plain、multipart/form-data、application/x-www-form-urlencoded<h4 id="6-跨域"><a href="#6-跨域" class="headerlink" title="6. 跨域"></a>6. 跨域</h4>解决跨域的方法有很多种。cors是比较好的解决方案。JsonP只支持get请求，但是适配老式浏览器<h5 id="9-TCP三次握手"><a href="#9-TCP三次握手" class="headerlink" title="9. TCP三次握手"></a>9. TCP三次握手</h5>三次握手的过程：<br>主机向服务器发送一个建立连接的请求（您好，我想认识您）；<br>服务器接到请求后发送同意连接的信号（好的，很高兴认识您）；<br>主机接到同意连接的信号后，再次向服务器发送了确认信号（我也很高兴认识您），自此，主机与服务器两者建立了连接。<br>四次挥手的过程：<br>主机向服务器发送一个断开连接的请求（不早了，我该走了）；<br>服务器接到请求后发送确认收到请求的信号（知道了）；<br>服务器向主机发送断开通知（我也该走了）；<br>主机接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接；<br>为什么建立连接是三次？为什么断开链接是四次呢？<br>为了确保数据全部发送并且防止服务器端一直等待而浪费资源；</li>
</ul>
<h4 id="10-性能优化"><a href="#10-性能优化" class="headerlink" title="10. 性能优化"></a>10. 性能优化</h4><p>合理使用缓存，将资源放在浏览器端，这是最快的方式（service worker）；合理进行http缓存；如果资源必须从网络中加载，则要考虑缩短连接时间，即DNS优化部分；减少响应内容大小，即对内容进行压缩，静态资源优化gzip、br；减少reflow的次数；无用代码移除；tree-shaking；差异化加载；减少http请求；预加载；懒加载；节流防抖；内存回收；<br>will-change优化动画、滚动等效果的性能，尤其在移动端（调动更多的GPU资源进行计算和重绘）<br>缩减首屏白屏时间：从资源和视觉两方面去优化：懒加载/按需加载（提高首屏加载速度），视觉上可以采取Medium渐变加载的策略，给用户一个柔和的感觉。<br><img src="https://img-blog.csdn.net/20160501111846529" alt=""></p>
<h3 id="二、ES6-ES7-ES8"><a href="#二、ES6-ES7-ES8" class="headerlink" title="二、ES6/ES7/ES8"></a>二、ES6/ES7/ES8</h3><blockquote>
<p>ES全称ECMAScript，ECMAScript是ECMA制定的标准化脚本语言。</p>
</blockquote>
<p>es6的特性跨度和es5比较大，所以es6的特性比较多，es7,es8是在es6的基础上进行的补充。下面列举一些常用的es6特性：</p>
<ul>
<li>类</li>
<li>模块化</li>
<li>箭头函数</li>
<li>模版字符串</li>
<li>解构赋值</li>
<li>Promise</li>
<li>let、const</li>
<li>延展操作符</li>
<li>函数参数默认值</li>
</ul>
<p>es6引入了类的概念，js的面向对象编程更加容易理解。模块化主要有export和import组成，每一个模块都有自己单独的作用域，通过export暴露对外接口，通过import来引用其他模块提供的接口。箭头函数是es6中最重要的特性之一，可以很好的处理this指针的问题，箭头函数中this继承的是父执行上下文中的this，；箭头函数和bind方法，每次执行后都会返回一个新的函数引用。</p>
<p>es7新增Array.prototype.includes(),用来判断一个数组是否包含指定的值，包含返回true，不包含返回false；新增指数操作符<strong>，Math.pow(2,10)等价于2</strong>10；</p>
<p>es8新增async/await;</p>
<h3 id="三、PWA"><a href="#三、PWA" class="headerlink" title="三、PWA"></a>三、PWA</h3><p>Progressive Web App, 简称 PWA，是提升 Web App 的体验的一种新方法，能给用户原生应用的体验。他的本质上还是一个web app，但是借助了技术使其也具备了native app的部分特性，并兼顾了web app 和 native app各自的优点；<br>几大特性：</p>
<ul>
<li>性能提升，能够快速响应，有着相对很平滑的动画体验</li>
<li>一键生成，可以添加到桌面，终端设备，避免应用商店下载，趋向于native app的体验形式</li>
<li>弱网、离线情况下正常运行，通过service-worker代理请求，操作浏览器缓存；</li>
<li>HTTPS协议下确保了应用的安全性</li>
<li>持续更新</li>
</ul>
<p>区别于其他类型APP:</p>
<p>WebAPP：开发成本低，更新简单，体验差，不具备离线和推送功能；<br>NativeAPP：开发成本高，需审核，需下载；体验好；<br>HybridAPP：介于web app 和 native-app之间，通过ui-webview访问里面；一套代码多端运行，兼容差，体验差；</p>
<p>Web Worker:<br>一个网页只会有两个线程：GUI 渲染线程和 JS 引擎线程。JS 引擎线程和 GUI 渲染线程是互斥的，因此在 JS 执行的时候，UI 页面会被阻塞住。为了在进行高耗时 JS 运算时，UI 页面仍可用，那么就得另外开辟一个独立的 JS 线程来运行这些高耗时的 JS 代码，这就是 Web Worker。Web Worker只能服务于新建它的页面，不同页面之间不能共享同一个 Web Worker。<br>当页面关闭时，该页面新建的 Web Worker 也会随之关闭，不会常驻在浏览器中。<br>Service Worker 在 Web Worker 的基础上加上了持久离线缓存能力.<br>依赖Promise、html5 fetch API、缓存机制依赖cache API、https环境。它能够拦截和处理网络请求，并且配合 Cache Storage API，开发者可以自由的对页面发送的 HTTP 请求进行管理，这就是为什么 Service Worker 能让 Web 站点离线的原因。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vernvn.github.io/2019/06/18/%E5%B8%B8%E8%A7%81%E7%9A%84Widget%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/17755520?s=400&u=9f444bfe70cd719b9bf43ed5fedac2f1d005ff5a&v=4">
      <meta itemprop="name" content="Lee_Ran">
      <meta itemprop="description" content="保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力混迹江湖的前端小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/18/%E5%B8%B8%E8%A7%81%E7%9A%84Widget%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">常见的Widget使用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-18 13:35:28" itemprop="dateCreated datePublished" datetime="2019-06-18T13:35:28+08:00">2019-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-06-21 17:12:22" itemprop="dateModified" datetime="2019-06-21T17:12:22+08:00">2019-06-21</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="ScrollView-in-Flutter"><a href="#ScrollView-in-Flutter" class="headerlink" title="ScrollView in Flutter"></a>ScrollView in Flutter</h4><p>想象有一种应用场景，scrollable组件内部嵌套另一个scrollable组件。特别是当同时显示ListView和GridView时应该怎么处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">return Scaffold (</span><br><span class="line">    appBar: AppBar(</span><br><span class="line">        title: Text(&apos;listView&apos;)</span><br><span class="line">    ),</span><br><span class="line">    body: Container(</span><br><span class="line">        child: SingleChildScrollView(</span><br><span class="line">            child: Column(</span><br><span class="line">                children: &lt;Widget&gt;[</span><br><span class="line">                    someWidget,</span><br><span class="line">                    someWidget,</span><br><span class="line">                    someWidget,</span><br><span class="line">                    ListView(</span><br><span class="line">                        children: &lt;Widget&gt;[</span><br><span class="line">                            anotherWidget,</span><br><span class="line">                            anotherWidget,</span><br><span class="line">                            anotherWidget</span><br><span class="line">                        ]</span><br><span class="line">                    )</span><br><span class="line">                ]</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>运行以上代码，控制台会抛出异常，其中关键的一句翻译过来就是：</p>
<blockquote>
<p>垂直视口被赋予无限高度。这种情况通常在可滚动小部件嵌套在另一个可滚动小部件内时发生。</p>
</blockquote>
<p>这个时候，我们可以通过Slivers来实现这一需求。通过以下代码替换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">return Scaffold (</span><br><span class="line">    appBar: AppBar(</span><br><span class="line">        title: Text(&apos;listView&apos;)</span><br><span class="line">    ),</span><br><span class="line">    body: Container(</span><br><span class="line">        child: CustomScrollView(</span><br><span class="line">            slivers: &lt;Widget&gt;[</span><br><span class="line">                SliverList(</span><br><span class="line">                    delegate: SliverChildListDelegate(</span><br><span class="line">                        someWidget,</span><br><span class="line">                        someWidget,</span><br><span class="line">                        someWidget,</span><br><span class="line">                    )</span><br><span class="line">                ),</span><br><span class="line">                SliverList(</span><br><span class="line">                    delegate: SliverChildListDelegate(</span><br><span class="line">                        anotherWidget,</span><br><span class="line">                        anotherWidget,</span><br><span class="line">                        anotherWidget,</span><br><span class="line">                    )</span><br><span class="line">                ),</span><br><span class="line">                SliverGrid(</span><br><span class="line">                    gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 2),</span><br><span class="line">                    delegate: SliverChildListDelegate(</span><br><span class="line">                        thirdWidget,</span><br><span class="line">                        thirdWidget,</span><br><span class="line">                        thirdWidget,</span><br><span class="line">                    )</span><br><span class="line">                ),</span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<div align=center><br>  <img src="https://cdn-images-1.medium.com/max/1600/1*EV0ISPIhC8Yrf9nEwSJEMQ.gif" ><br></div>

<h3 id="下面介绍Slivers系列常见的控件及使用场景"><a href="#下面介绍Slivers系列常见的控件及使用场景" class="headerlink" title="下面介绍Slivers系列常见的控件及使用场景"></a>下面介绍Slivers系列常见的控件及使用场景</h3><h4 id="SliverAppBar"><a href="#SliverAppBar" class="headerlink" title="SliverAppBar"></a>SliverAppBar</h4><p>经常用于AppBar展开收起的场景，通过配置flexibleSpace和expandedHeight属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CustomScrollView(</span><br><span class="line">    slivers: &lt;Widget&gt;[</span><br><span class="line">        SliverAppBar(</span><br><span class="line">            actions: &lt;Widget&gt;[</span><br><span class="line">                _buildAction(),</span><br><span class="line">            ],</span><br><span class="line">            title: Text(&apos;SliverAppBar&apos;),</span><br><span class="line">            backgroundColor: Theme.of(context).accentColor,</span><br><span class="line">            expandedHeight: 200.0,</span><br><span class="line">            flexibleSpace: FlexibleSpaceBar(</span><br><span class="line">                background: Image.asset(&apos;images/food01.jpeg&apos;, fit: BoxFit.cover),</span><br><span class="line">            ),</span><br><span class="line">        ),</span><br><span class="line">        SliverFixedExtentList(</span><br><span class="line">            itemExtent: 120.0,</span><br><span class="line">            delegate: SliverChildListDelegate(</span><br><span class="line">                products.map((product) &#123;</span><br><span class="line">                return _buildItem(product);</span><br><span class="line">                &#125;).toList(),</span><br><span class="line">            ),</span><br><span class="line">        ),</span><br><span class="line">    ],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<div align=center><br>  <img src="https://user-gold-cdn.xitu.io/2018/10/23/1669f73f1ef4beb9?imageslim" ><br></div>

<p>flexibleSpace是被展开和收起的组件，expandedHeight是其操控的高度；其他属性具体含义可以参考官方文档</p>
<h4 id="SliverList"><a href="#SliverList" class="headerlink" title="SliverList"></a>SliverList</h4><p>SliverList只需要设置delegate属性就可以，可以滑动的列表，常常用于滑动组件嵌套的场景</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CustomScrollView(</span><br><span class="line">    slivers: &lt;Widget&gt;[</span><br><span class="line">        SliverList(</span><br><span class="line">            delegate: SliverChildBuilderDelegate(</span><br><span class="line">                (BuildContext context, int index) &#123;</span><br><span class="line">                    return _buildItem(context, products[index]);</span><br><span class="line">                &#125;,</span><br><span class="line">                childCount: 3,</span><br><span class="line">            ),</span><br><span class="line">        )</span><br><span class="line">    ],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>也可以通过SliverChildListDelegate来构建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CustomScrollView(</span><br><span class="line">    slivers: &lt;Widget&gt;[</span><br><span class="line">        SliverList(</span><br><span class="line">            delegate: SliverChildListDelegate([</span><br><span class="line">              _buildItem(),</span><br><span class="line">              _buildItem(),</span><br><span class="line">              _buildItem(),</span><br><span class="line">            ]),</span><br><span class="line">        )</span><br><span class="line">    ],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<font face="黑体" color="#f00" size = 4>SliverChildListDelegate和SliverChildBuilderDelegate的区别：</font>

<p>SliverChildListDelegate一般用来构item建数量明确的列表，会提前build好所有的子item，所以在效率上会有问题，适合item数量不多的情况。<br>SliverChildBuilderDelegate构建的列表理论上是可以无限长的。<br>两者的区别有些类似于ListView和ListView.builder()的区别。</p>
<div align=center><br>  <img src="https://user-gold-cdn.xitu.io/2018/10/23/1669f785cc80d26b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" ><br></div>

<h4 id="SliverGrid"><a href="#SliverGrid" class="headerlink" title="SliverGrid"></a>SliverGrid</h4><p>SliverGrid有三个构造函数：SliverGrid.count()、SliverGrid.extent和SliverGrid()。</p>
<ul>
<li>SliverGrid.count()指定了一行展示多少个item，下面的例子表示一行展示4个：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SliverGrid.count(children: scrollItems, crossAxisCount: 4)</span><br></pre></td></tr></table></figure>
<ul>
<li>SliverGrid.extent可以指定item的最大宽度，然后让Flutter自己决定一行展示多少个item</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SliverGrid.extent(children: scrollItems, maxCrossAxisExtent: 90.0)</span><br></pre></td></tr></table></figure>
<ul>
<li>SliverGrid()则是需要指定一个gridDelegate，它提供给了程序员一个自定义Delegate的入口，你可以自己决定每一个item怎么排列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SliverGrid(</span><br><span class="line">  gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">    crossAxisCount: 2</span><br><span class="line">  ),</span><br><span class="line">  delegate: SliverChildBuilderDelegate(</span><br><span class="line">    (BuildContext context, int index) &#123;</span><br><span class="line">      return _buildItem(products[index]);;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<div align=center><br>  <img src="https://user-gold-cdn.xitu.io/2018/10/23/1669f785c4f198d3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" ><br></div>

<h4 id="SliverPersistentHeader"><a href="#SliverPersistentHeader" class="headerlink" title="SliverPersistentHeader"></a>SliverPersistentHeader</h4><p>SliverPersistentHeader顾名思义，就是给一个可滑动的视图添加一个头（实际上，在CustomScrollView的slivers列表中，header可以出现在视图的任意位置，不一定要是在顶部）。这个Header会随着滑动而展开/收起</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SliverPersistentHeader(</span><br><span class="line">    delegate: _SliverAppBarDelegate(</span><br><span class="line">        minHeight: 60.0,</span><br><span class="line">        maxHeight: 180.0,</span><br><span class="line">        child: Container(),</span><br><span class="line">    ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>构建一个SliverPersistentHeader需要传入一个delegate，这个delegate是SliverPersistentHeaderDelegate类型的，而SliverPersistentHeaderDelegate是一个abstract类，我们不能直接new一个SliverPersistentHeaderDelegate出来，因此，我们需要自定义一个delegate来实现SliverPersistentHeaderDelegate类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class _SliverAppBarDelegate extends SliverPersistentHeaderDelegate &#123;</span><br><span class="line">  _SliverAppBarDelegate(&#123;</span><br><span class="line">    @required this.minHeight,</span><br><span class="line">    @required this.maxHeight,</span><br><span class="line">    @required this.child,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  final double minHeight;</span><br><span class="line">  final double maxHeight;</span><br><span class="line">  final Widget child;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  double get minExtent =&gt; minHeight;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  double get maxExtent =&gt; math.max(maxHeight, minHeight);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(</span><br><span class="line">      BuildContext context, double shrinkOffset, bool overlapsContent) &#123;</span><br><span class="line">    return new SizedBox.expand(child: child);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  bool shouldRebuild(_SliverAppBarDelegate oldDelegate) &#123;</span><br><span class="line">    return maxHeight != oldDelegate.maxHeight ||</span><br><span class="line">        minHeight != oldDelegate.minHeight ||</span><br><span class="line">        child != oldDelegate.child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写一个自定义SliverPersistentHeaderDelegate很简单，只需重写build()、get maxExtent、get minExtent和shouldRebuild()这四个方法，上面就是一个最简单的SliverPersistentHeaderDelegate的实现。其中，maxExtent表示header完全展开时的高度，minExtent表示header在收起时的最小高度。因此，对于我们上面的那个自定义Delegate，如果将minHeight和maxHeight的值设置为相同时，header就不会收缩了，这样的Header跟我们平常理解的Header更像。</p>
<div align=center><br>  <img src="https://user-gold-cdn.xitu.io/2018/10/23/1669f73f1f050152?imageslim" ><br></div>

<h4 id="SliverToBoxAdapter"><a href="#SliverToBoxAdapter" class="headerlink" title="SliverToBoxAdapter"></a>SliverToBoxAdapter</h4><p> SliverPersistentHeader一般来说都是会展开/收起的（除非minExtent和maxExtent值相同），那么如果想要在滚动视图中添加一个普通的控件，那么就可以使用SliverToBoxAdapter来将各种视图组合在一起，放在CustomListView中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">CustomScrollView(</span><br><span class="line">    physics: ScrollPhysics(),</span><br><span class="line">    slivers: &lt;Widget&gt;[</span><br><span class="line">        SliverToBoxAdapter(</span><br><span class="line">            child: _buildHeader(),</span><br><span class="line">        ),</span><br><span class="line">        SliverGrid.count(</span><br><span class="line">            crossAxisCount: 3,</span><br><span class="line">            children: products.map((product) &#123;</span><br><span class="line">                return _buildItemGrid(product);</span><br><span class="line">            &#125;).toList(),</span><br><span class="line">        ),</span><br><span class="line">        SliverToBoxAdapter(</span><br><span class="line">            child: _buildSearch(),</span><br><span class="line">        ),</span><br><span class="line">        SliverFixedExtentList(</span><br><span class="line">            itemExtent: 100.0,</span><br><span class="line">            delegate: SliverChildListDelegate(</span><br><span class="line">                products.map((product) &#123;</span><br><span class="line">                return _buildItemList(product);</span><br><span class="line">                &#125;).toList(),</span><br><span class="line">            ),</span><br><span class="line">        ),</span><br><span class="line">        SliverToBoxAdapter(</span><br><span class="line">            child: _buildFooter(),</span><br><span class="line">        ),</span><br><span class="line">    ],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<div align=center><br>  <img src="https://user-gold-cdn.xitu.io/2018/10/23/1669f73f8a91a7e8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" ><br></div>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vernvn.github.io/2019/06/12/Flutter%E6%96%B0%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/17755520?s=400&u=9f444bfe70cd719b9bf43ed5fedac2f1d005ff5a&v=4">
      <meta itemprop="name" content="Lee_Ran">
      <meta itemprop="description" content="保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力混迹江湖的前端小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/12/Flutter%E6%96%B0%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">Flutter新的状态管理方案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-12 14:21:51" itemprop="dateCreated datePublished" datetime="2019-06-12T14:21:51+08:00">2019-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-18 12:37:11" itemprop="dateModified" datetime="2019-11-18T12:37:11+08:00">2019-11-18</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>在Google IO 2019大会上提出了新的状态管理方案Provider用来替代之前的状态管理方案Provide，针对不同类型对象提供了多种不同的Provider;Provider借助了InheritWidget，将共享状态放到顶层Widget。</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzUyMjg5NTI3NQ==&amp;mid=2247483784&amp;idx=1&amp;sn=aef9b82cb7aa41f0d9172b46e5853362&amp;chksm=f9c5ab4cceb2225a4aaa0fb9a643b553afc07802c30f4bf069d0c6f0b775d3ec6f6c488f9011&amp;mpshare=1&amp;scene=23&amp;srcid=#rd" target="_blank" rel="noopener">很细心的讲解文章</a></p>
<ul>
<li>借助了InheritWidget，允许将有效信息传递到组件树下的小组件</li>
<li>提供DI</li>
<li>创建和销毁实例</li>
<li>结合Bloc等进行状态管理</li>
</ul>
<h4 id="Let’s-Code"><a href="#Let’s-Code" class="headerlink" title="Let’s Code"></a>Let’s Code</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const Provider.value(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    @required T value,</span><br><span class="line">    this.updateShouldNotify,</span><br><span class="line">    this.child</span><br><span class="line">&#125;) : dispose = null, super.value(key: key, value: value);</span><br></pre></td></tr></table></figure>
<p>上面的源码value的类型为范型，并没有进行限制，所以可以绑定任意数据类型</p>
<h5 id="如何绑定数据"><a href="#如何绑定数据" class="headerlink" title="如何绑定数据"></a>如何绑定数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">    @override</span><br><span class="line">    Widget build (BuildContext context) &#123;</span><br><span class="line">        return MaterialApp(</span><br><span class="line">            title: &apos;demo&apos;,</span><br><span class="line">            home: Provider&lt;String&gt;.value(</span><br><span class="line">                value: &apos;demo&apos;,</span><br><span class="line">                child: Demo()</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Provider.of()在Provider窗口小部件对应的后代中BuildContext是必需的；获取BuildContext麻烦时Consumer()是很好的替代方式</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">    @override</span><br><span class="line">    Widget build (BuildContext context) &#123;</span><br><span class="line">        return MaterialApp(</span><br><span class="line">            title: &apos;demo&apos;,</span><br><span class="line">            home: Provider&lt;String&gt;.value(</span><br><span class="line">                value: &apos;demo&apos;,</span><br><span class="line">                child: Consumer&lt;String&gt;(</span><br><span class="line">                    builder: (context, value, child) &#123;</span><br><span class="line">                        return Center(</span><br><span class="line">                            child: Text(value)</span><br><span class="line">                        )</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="如何获取数据"><a href="#如何获取数据" class="headerlink" title="如何获取数据"></a>如何获取数据</h5><p>provider需要在绑定的子widget中获取数据，使用静态方法Provider.of(BuildContext context),此方法将从关联的widget树中查找<font face="黑体" color="#f00" size = 4>最近的相同类型的数据</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class Demo extends StatelessWidget &#123;</span><br><span class="line">    @override</span><br><span class="line">    Widget build (BuildContext context) &#123;</span><br><span class="line">        final value = Provider.of&lt;String&gt;(context);</span><br><span class="line">        return Center(</span><br><span class="line">            child: Text(value)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#####以上简述了Provider的数据绑定几获取的方法，下面在应用场景里实现Provider的作用，以官方的计数器的例子来举例</p>
<p>首先创建一个Counter类，并封装他的增和减的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Counter with ChangeNotifier&#123;</span><br><span class="line">    int _counter;</span><br><span class="line">    Counter(this._counter);</span><br><span class="line">    getCouonter =&gt; _counter;</span><br><span class="line">    setCounter(int counter) =&gt; _counter = counter;</span><br><span class="line">    void increment() &#123;</span><br><span class="line">        _counter ++;</span><br><span class="line">        notifyListeners();</span><br><span class="line">    &#125;</span><br><span class="line">    void decrement() &#123;</span><br><span class="line">        _counter --;</span><br><span class="line">        notifyListeners();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在Counter类拥有了监听的功能，我们需要调用notifyListeners()去通知监听器数据变化，并更新UI</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">    @override</span><br><span class="line">    Widget build (BuildContext context) &#123;</span><br><span class="line">        return MaterialApp(</span><br><span class="line">            title: &apos;demo&apos;,</span><br><span class="line">            home: ChangeNotifierProvider&lt;Counter&gt;(</span><br><span class="line">                builder: (_) =&gt; Counter(0),</span><br><span class="line">                child: HomePage()</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class HomePage extends StatelessWidget &#123;</span><br><span class="line">    @override</span><br><span class="line">    Widget build (BuildContext context) &#123;</span><br><span class="line">        final counter = Provider.of&lt;Counter&gt;(context);</span><br><span class="line">        return Scaffold(</span><br><span class="line">            appBar: AppBar(</span><br><span class="line">                title: Text(&apos;ChangeNotifierProvider demo&apos;)</span><br><span class="line">            ),</span><br><span class="line">            body: Center(</span><br><span class="line">                child: Text(counter.getCounter())</span><br><span class="line">            ),</span><br><span class="line">            floatingActionButton: Column(</span><br><span class="line">                children: &lt;Widget&gt;[</span><br><span class="line">                    FloatingActionButton(</span><br><span class="line">                        onPressed: counter.increment,</span><br><span class="line">                        child: Icon(Icons.add)</span><br><span class="line">                    ),</span><br><span class="line">                    FloatingActionButton(</span><br><span class="line">                        onPressed: counter.decrement,</span><br><span class="line">                        child: Icon(Icons.remove)</span><br><span class="line">                    ),</span><br><span class="line">                ]</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Provider结合Bloc模式进行状态管理"><a href="#Provider结合Bloc模式进行状态管理" class="headerlink" title="Provider结合Bloc模式进行状态管理"></a>Provider结合Bloc模式进行状态管理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class CounterBloc &#123;</span><br><span class="line">    final _valueController = StreamController&lt;String&gt;();</span><br><span class="line">    Stream&lt;String&gt; get stream =&gt; _valueController.stream;</span><br><span class="line">    int _number = 0;</span><br><span class="line">    void increment() &#123;</span><br><span class="line">        _number++;</span><br><span class="line">        _valueController.sink.add(_number.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    void dispose() &#123;</span><br><span class="line">        _valueController.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProviderPage extends StatelessWidget &#123;</span><br><span class="line">    @override</span><br><span class="line">    Widget build (BuildContext context) &#123;</span><br><span class="line">        return Provider&lt;CounterBloc&gt;(</span><br><span class="line">            builder: (_) =&gt; CounterBloc(),</span><br><span class="line">            dispose: (_, bloc) =&gt; bloc.dispose(),</span><br><span class="line">            child: Scaffold(</span><br><span class="line">                body: CounterText(),</span><br><span class="line">                floatingActionButton: _floatingButton(),</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Widget _floatingButton() &#123;</span><br><span class="line">        return Consumer&lt;CounterBloc&gt;(</span><br><span class="line">            builder: (context, value, child) &#123;</span><br><span class="line">                return FloatingActionButton(</span><br><span class="line">                    onPressed: value.increment,</span><br><span class="line">                    child: const Icon(Icons.add),</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class CounterText extends StatelessWidget &#123;</span><br><span class="line">    @override</span><br><span class="line">    Widget build (BuildContext context) &#123;</span><br><span class="line">        final bloc = Provider.of&lt;CounterBloc&gt;(context);</span><br><span class="line">        return StreamBuilder&lt;String&gt;(</span><br><span class="line">            stream: bloc.stream,</span><br><span class="line">            builder: (context, snapshot) &#123;</span><br><span class="line">                return Center(</span><br><span class="line">                    child: Text(snapshot.data ?? &apos;0&apos;)</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="以上可以用Provder-value-实现，引入简单值传播"><a href="#以上可以用Provder-value-实现，引入简单值传播" class="headerlink" title="以上可以用Provder.value()实现，引入简单值传播"></a>以上可以用Provder.value()实现，引入简单值传播</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class ProviderValuePage extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  ProviderValueState createState() =&gt; ProviderValueState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProviderValueState extends State&lt;ProviderValuePage&gt; &#123;</span><br><span class="line">  final _bloc = CounterBloc();</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Scaffold(</span><br><span class="line">      body: Provider&lt;CounterBloc&gt;.value(</span><br><span class="line">        value: _bloc,</span><br><span class="line">        child: CounterText(),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: bloc.increment,</span><br><span class="line">        child: const Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void dispose() &#123;</span><br><span class="line">    _bloc.dispose();</span><br><span class="line">    super.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CounterText extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    final bloc = Provider.of&lt;CounterBloc&gt;(context);</span><br><span class="line"></span><br><span class="line">    return StreamBuilder&lt;String&gt;(</span><br><span class="line">      stream: bloc.stream,</span><br><span class="line">      builder: (context, snapshot) &#123;</span><br><span class="line">        return Center(</span><br><span class="line">          child: Text(snapshot.data ?? &apos;0&apos;)</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ChangeNotifierProvider与ChangeNotifierProvider.value()等提供商的唯一区别在于<font face="黑体" color="#f00" size = 4>ChangeNotifierProvider.value()创建和销毁模型实例需要自行处理</font></p>
<p>多提供商的场景</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Provider&lt;Foo&gt;.value(</span><br><span class="line">    value: foo,</span><br><span class="line">    child: Provider&lt;Bar&gt;.value(</span><br><span class="line">        value: bar,</span><br><span class="line">        child: Provider&lt;Baz&gt;.value(</span><br><span class="line">            value: baz,</span><br><span class="line">            child: someWidget</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>一层一层的嵌套导致代码可读性降低，所以产生了MultiProvider</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MultiProvider(</span><br><span class="line">    providers: [</span><br><span class="line">        Provider&lt;Foo&gt;.value(value: foo),</span><br><span class="line">        Provider&lt;Bar&gt;.value(value: bar),</span><br><span class="line">        Provider&lt;Baz&gt;.value(value: baz),</span><br><span class="line">    ],</span><br><span class="line">    child: someWidget</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<font face="黑体" color="#f00" size = 4>注意的是需要指定不同的类型，如果是相同的类型，将保留最后一个Provider的值</font>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vernvn.github.io/2019/06/12/flutter%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%90%BA%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%91%BD%E5%90%8D%E8%B7%AF%E7%94%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/17755520?s=400&u=9f444bfe70cd719b9bf43ed5fedac2f1d005ff5a&v=4">
      <meta itemprop="name" content="Lee_Ran">
      <meta itemprop="description" content="保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力混迹江湖的前端小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/12/flutter%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%90%BA%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%91%BD%E5%90%8D%E8%B7%AF%E7%94%B1/" class="post-title-link" itemprop="url">flutter中可以携带参数的命名路由</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-06-12 11:22:17 / 修改时间：13:51:05" itemprop="dateCreated datePublished" datetime="2019-06-12T11:22:17+08:00">2019-06-12</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="创建一个可以携带参数的flutter命名路由"><a href="#创建一个可以携带参数的flutter命名路由" class="headerlink" title="创建一个可以携带参数的flutter命名路由"></a>创建一个可以携带参数的flutter命名路由</h2><p>MaterialApp提供了一个属性<font face="黑体" color="#f00" size = 4>onGenerateRoute</font>,需要一个返回<code>Route&lt;dynamic&gt;</code>,并接受<code>RouteSettings</code>参数的函数</p>
<p>首先创建一个Router类，并且创建一个静态函数,settings包括路由的名称和参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Router &#123;</span><br><span class="line">    static Route&lt;dynamic&gt; generateRoute(RouteSettings settings) &#123;</span><br><span class="line">        switch(settings.name) &#123;</span><br><span class="line">            case &apos;/&apos;: return MaterialPageRoute(</span><br><span class="line">                builder: (_) =&gt; Home()</span><br><span class="line">            ),</span><br><span class="line">            case &apos;/feed&apos;: return MaterialPageRoute(</span><br><span class="line">                builder: (_) =&gt; Feed()</span><br><span class="line">            ),</span><br><span class="line">            default: return MaterialPageRoute(</span><br><span class="line">                builder: (_) =&gt; Scaffold(</span><br><span class="line">                    body: Center(</span><br><span class="line">                        child: Text(&apos;没有路由&apos;)</span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了避免我们的代码出现错误，我们将采用硬编码的方式定义路由名称，并放到全局可以访问的constant.dart文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const String homeRoute = &apos;/&apos;;</span><br><span class="line">const String feedRoute = &apos;/feed&apos;;</span><br></pre></td></tr></table></figure><br>switch case语句之后更改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">case homeRoute: return MaterialPageRoute(</span><br><span class="line">    builder: (_) =&gt; Home()</span><br><span class="line">),</span><br><span class="line">case feedRoute: return MaterialPageRoute(</span><br><span class="line">    builder: (_) =&gt; Feed()</span><br><span class="line">),</span><br></pre></td></tr></table></figure><br>之后，在定义MaterialApp应用程序时，generateRoute函数传递给onGenerateRoute,通过initialRoute配置起始视图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">    @override</span><br><span class="line">    Widget build (BuildContext context) &#123;</span><br><span class="line">        return MaterialApp (</span><br><span class="line">            onGenerateRoute: Router.generateRoute,</span><br><span class="line">            initialRoute: homeRoute</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这时，当你需要导航时，只需要使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Navigator.pushNamed(context, feedRoute);</span><br></pre></td></tr></table></figure><br>如果需要传递参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Navigator.pushNamed(context, feedRoute, arguments: &apos;传递的参数&apos;);</span><br><span class="line">case feedRoute: </span><br><span class="line">    var data = settins.arguments as String;</span><br><span class="line">    return MaterialPageRoute(</span><br><span class="line">        builder: (_) =&gt; Feed(data)</span><br><span class="line">    ),</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vernvn.github.io/2019/02/26/steam%20in%20dart/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/17755520?s=400&u=9f444bfe70cd719b9bf43ed5fedac2f1d005ff5a&v=4">
      <meta itemprop="name" content="Lee_Ran">
      <meta itemprop="description" content="保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力混迹江湖的前端小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/26/steam%20in%20dart/" class="post-title-link" itemprop="url">Dart Streams</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-26 15:02:52" itemprop="dateCreated datePublished" datetime="2019-02-26T15:02:52+08:00">2019-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-02-27 17:43:29" itemprop="dateModified" datetime="2019-02-27T17:43:29+08:00">2019-02-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="什么是Streams"><a href="#什么是Streams" class="headerlink" title="什么是Streams?"></a>什么是Streams?</h3><blockquote>
<p>streams就好比传送带，将物品放到一侧，他将自动运送到另一侧。我们可以将数据对象放在传送带上，他会被传送带传输。如果传送带不是无限长的（它不是一个无限的流， 例如rxjs里的interval，如果不取消订阅，他会随着时间一直流动），那么传送带的物品终会掉落。</p>
</blockquote>
<p><img src="https://cdn-images-1.medium.com/max/1600/0*z_EhYGu-2XQ5AwST.gif" alt="avatar"></p>
<blockquote>
<p>为了避免传送带上的物品无辜掉落，我们可以做一些事情，使得物品在掉落之前实现某些价值。</p>
</blockquote>
<p><img src="https://cdn-images-1.medium.com/max/1600/0*2LOUvyESiTySjwwU.gif" alt="avatar"></p>
<h3 id="Dart-Streams-和-Rx"><a href="#Dart-Streams-和-Rx" class="headerlink" title="Dart Streams 和 Rx"></a>Dart Streams 和 Rx</h3><ul>
<li><p>Rx里面的可观察对象命名未Observable，它与Dart Streams里的Stream是同等的意义，所以在可以使用Stream的任何地方赋予Observable的含义</p>
</li>
<li><p>listen / subscribe, 进行序列订阅，同等意义</p>
</li>
<li><p>listen()返回一个StreamSubscription对象，调用cancel()释放订阅</p>
</li>
<li><p>StreamController / Subject, 发布值，相当于在传送带的左侧添加物品，同等意义</p>
</li>
</ul>
<h3 id="使用StreamBuilder"><a href="#使用StreamBuilder" class="headerlink" title="使用StreamBuilder"></a>使用StreamBuilder</h3><p>不用使用initState()和setState(),flutter提供了一个方便的widget称之为StreamBuilder,它需要一个Stream和一个builder函数，只要Stream发出一个新值就会调用他,不再需要initState或dispose.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">body: Center(</span><br><span class="line">	child: Column(</span><br><span class="line">		mainAxisAligment: MainAxisAlignment.center,</span><br><span class="line">		children: &lt;Widget&gt;[</span><br><span class="line">			Text(&apos;demo&apos;),</span><br><span class="line">			StreamBuilder&lt;int&gt;(</span><br><span class="line">				initialData: 0,</span><br><span class="line">				stream: _stream,</span><br><span class="line">				builder: (context, snappShot) &#123;</span><br><span class="line">					String valueString = &apos;NoData&apos;;</span><br><span class="line">					if (snappShot != null &amp;&amp; snappShot.hasData) &#123;</span><br><span class="line">						valueString = snappShot.data.toString();</span><br><span class="line">					&#125;</span><br><span class="line">					return Text(</span><br><span class="line">						valueString,</span><br><span class="line">						style: Theme.of(context).textTheme.display1</span><br><span class="line">					)</span><br><span class="line">				&#125;</span><br><span class="line">			)</span><br><span class="line">		]</span><br><span class="line">	)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>相对于直接订阅，使用StreamBuilder有几个明显的区别：</p>
<ul>
<li>setState()在listen()时接受新值时会重建整页，而StreamBuilder只会重建他自己的widget</li>
<li>snappShot包含从Stream接收的最新数据</li>
<li>含有一个initialData,用于第一次构建，即屏幕的第一帧，解决StreamBuilder不能在第一帧期间接收值的问题,如果snappShot无效,则返回默认Widget，适用于某些业务场景</li>
</ul>
<h3 id="flutter中使用BLOC模式"><a href="#flutter中使用BLOC模式" class="headerlink" title="flutter中使用BLOC模式"></a>flutter中使用BLOC模式</h3><h4 id="什么是bloc模式？"><a href="#什么是bloc模式？" class="headerlink" title="什么是bloc模式？"></a>什么是bloc模式？</h4><p>bloc[Business Logic Component]翻译过来就是业务逻辑组件，把业务逻辑抽出来，数据和ui解耦，一处改动，多处更新</p>
<blockquote>
<p><img src="https://ask.qcloudimg.com/http-save/1203298/sb707akvgg.png?imageView2/2/w/1620" alt="avatar"></p>
</blockquote>
<blockquote>
<p>上面描述的是组件的一些基本行为，【展示数据】，【发送事件】,flutter中实现Bloc的精髓就是stream，严格遵守了单一职责原则，代码解耦更好。</p>
</blockquote>
<p>UI<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void main() =&gt; runApp(MyApp());</span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">class CounterPage extends StateLessWidget &#123;</span><br><span class="line">	@override</span><br><span class="line">	Widget build(BuildContext context) &#123;</span><br><span class="line">		final IncrementBloc bloc = BlocProvider.of&lt;IncrementBloc&gt;(context);</span><br><span class="line">		return Scaffod(</span><br><span class="line">			appBar: AppBar(</span><br><span class="line">				title: Text(&apos;block&apos;)</span><br><span class="line">			),</span><br><span class="line">			body: Center(</span><br><span class="line">				child: StreamBuilder&lt;int&gt;(</span><br><span class="line">					stream: bloc._counterStream,</span><br><span class="line">					initialData: 0,</span><br><span class="line">					builder: (BuildContext context, AsyncSnapShot&lt;int&gt; snapshot) &#123;</span><br><span class="line">						return Text(&apos;clicked $&#123;snapshot.data&#125; times&apos;)</span><br><span class="line">					&#125;</span><br><span class="line">				)</span><br><span class="line">			),</span><br><span class="line">			floatingActionButton: FloatingActionButton(</span><br><span class="line">				child: Icon(Icons.add),</span><br><span class="line">				onPressed: () &#123;</span><br><span class="line">					bloc._actionSink.add(null);  // 发送事件</span><br><span class="line">				&#125;</span><br><span class="line">			)</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Bloc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class IncrementBloc &#123;</span><br><span class="line">	int _counter;</span><br><span class="line">	StreamController&lt;int&gt; _counterController = StreamController&lt;int&gt;();</span><br><span class="line">	StreamSink&lt;int&gt; _counterSink =&gt; _counterController.sink;  		// 发送数据</span><br><span class="line">	Stream&lt;int&gt; _counterStream =&gt; _counterController.stream;   		// stream</span><br><span class="line"></span><br><span class="line">	StreamController _actionController = StreamController();</span><br><span class="line">	StreamSink _actionSink =&gt; _actionController.sink;</span><br><span class="line">	Stream _actionStream =&gt; _actionController.stream; </span><br><span class="line"></span><br><span class="line">	void IncrementBloc() &#123;</span><br><span class="line">		_counter = 0;</span><br><span class="line">		_actionStream.listen((data)&#123;</span><br><span class="line">			_counter = _counter + 1;</span><br><span class="line">			_counterSink.add(_counter);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vernvn.github.io/2019/02/21/flutter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/17755520?s=400&u=9f444bfe70cd719b9bf43ed5fedac2f1d005ff5a&v=4">
      <meta itemprop="name" content="Lee_Ran">
      <meta itemprop="description" content="保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力混迹江湖的前端小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/21/flutter/" class="post-title-link" itemprop="url">flutter 学习笔记与问题总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-21 10:26:33" itemprop="dateCreated datePublished" datetime="2019-02-21T10:26:33+08:00">2019-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-02-27 15:54:15" itemprop="dateModified" datetime="2019-02-27T15:54:15+08:00">2019-02-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Flutter框架结构"><a href="#Flutter框架结构" class="headerlink" title="Flutter框架结构"></a>Flutter框架结构</h4><p><img src="https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/framework.png" alt="avatar"></p>
<ul>
<li><p>底下两层（Foundation和Animation、Painting、Gestures被合并为一个dart UI层，它是Flutter引擎暴露的底层UI库，提供动画、手势及绘制能力。</p>
</li>
<li><p>Rendering层，这一层是一个抽象的布局层，它依赖于dart UI层，Rendering层会构建一个UI树，当UI树有变化时，会计算出有变化的部分，然后更新UI树，最终将UI树绘制到屏幕上，这个过程类似于React中的虚拟DOM。Rendering层可以说是Flutter UI框架最核心的部分，它除了确定每个UI元素的位置、大小之外还要进行坐标变换、绘制(调用底层dart:ui)。</p>
</li>
<li><p>Widgets层是Flutter提供的的一套基础组件库，在基础组件库之上，Flutter还提供了 Material 和Cupertino两种视觉风格的组件库。而我们Flutter开发的大多数场景，只是和这两层打交道。</p>
</li>
</ul>
<h4 id="primarySwatch-和-primaryColor-的区别"><a href="#primarySwatch-和-primaryColor-的区别" class="headerlink" title="primarySwatch 和 primaryColor 的区别"></a>primarySwatch 和 primaryColor 的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Widget build (BuildContext context) &#123;</span><br><span class="line">	return MaterialApp(</span><br><span class="line">		title: &apos;myApp&apos;,</span><br><span class="line">		theme: ThemeData(</span><br><span class="line">			primaryColor: Colors.white   // primarySwatch  </span><br><span class="line">		)</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用primaryColor可以Colors.white,使用primarySwatch不可以设置白色和黑色，primarySwatch中的颜色是调用MaterialColor这种颜色类</p>
<h4 id="listView"><a href="#listView" class="headerlink" title="listView"></a>listView</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Widget _buildSuggestions() &#123;</span><br><span class="line">	return ListView.builder(</span><br><span class="line">		padding: EdgeInsets.all(16.0),</span><br><span class="line">		itemCount: 100,</span><br><span class="line">		itemBuilder: (BuildContext context, i) &#123;   //itemBuilder callback </span><br><span class="line">			if (i.isOdd) &#123;</span><br><span class="line">				return Something();</span><br><span class="line">			&#125;</span><br><span class="line">			return Another()</span><br><span class="line">		&#125;</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h4><p>与js一样，dart支持单线程执行，js中Promise对象表示异步操作的最终结果，dart中用Future对象来处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_getIpAddress() &#123;</span><br><span class="line">	final url = &apos;http://www.google.com&apos;;</span><br><span class="line">	HttpRequest.reqeust(url).then((value) =&gt; &#123;</span><br><span class="line">		print(json.decode(value.responseText)[&apos;origin&apos;]);</span><br><span class="line">	&#125;).catchError((error) =&gt; print(error))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>async函数返回Future,await等待Future</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_getIpAddress() &#123;</span><br><span class="line">	final url = &apos;http://www.google.com&apos;;</span><br><span class="line">	var request = await HttpRequest.reqeust(url);</span><br><span class="line">	String ip = json.decode(request.responseText)[&apos;origin&apos;];</span><br><span class="line">	print(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Contianer(</span><br><span class="line">	child: Center(</span><br><span class="line">		child: Container(</span><br><span class="line">			child: Text(&apos;demo&apos;),</span><br><span class="line">			decoration: BoxDecoration(    // color, borderRadius, boxShadow, shape 通过BoxDecoration装饰</span><br><span class="line">				color: Colors.red,</span><br><span class="line">				borderRadius: BorderRadius.all(</span><br><span class="line">					Radius.circular(8.0)</span><br><span class="line">				),</span><br><span class="line">				boxshadow: &lt;BoxShadow&gt;[</span><br><span class="line">					BoxShadow(</span><br><span class="line">						color: Color(0xcc000000),</span><br><span class="line">						offset: Offset(0.0, 2.0)</span><br><span class="line">					),</span><br><span class="line">					BoxShadow(</span><br><span class="line">						color: Color(0000000000),</span><br><span class="line">						offset: Offset(0.0, 2.0)</span><br><span class="line">					)</span><br><span class="line">				],</span><br><span class="line">				shape: BoxShape.circle  </span><br><span class="line">			),</span><br><span class="line">			padding: EdgesInsets.all(16.0),</span><br><span class="line">			width: 240.0</span><br><span class="line">		)</span><br><span class="line">	)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>Positioned widget and Stack widget</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">	child: Stack(</span><br><span class="line">		children: [</span><br><span class="line">			Positioned(</span><br><span class="line">				child: Container(</span><br><span class="line">					child: Text(&apos;demo&apos;),</span><br><span class="line">					decoration: BoxDecoration(</span><br><span class="line">						color: Colors.red</span><br><span class="line">					)</span><br><span class="line">				),</span><br><span class="line">				left: 24.0,</span><br><span class="line">				top: 24.0</span><br><span class="line">			)</span><br><span class="line">		]</span><br><span class="line">	),</span><br><span class="line">	width: 320.0,</span><br><span class="line">	height: 320.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>Transform widget and Scaling widget</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">	child: Transform(</span><br><span class="line">		child: Container(</span><br><span class="line">			child: Text(&apos;demo&apos;)</span><br><span class="line">		),</span><br><span class="line">		alignment: Alignment.center,</span><br><span class="line">		transform: Matrix4.identity()..rotateZ(15 * 3.1415926 / 180)  // rotate</span><br><span class="line">		transform: Matrix4.identity()..scale(1.5)   // scale</span><br><span class="line">	),</span><br><span class="line">	width: 320.0,</span><br><span class="line">	height: 320.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>ellipsis</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">	child: Container(</span><br><span class="line">		child: Text(</span><br><span class="line">			child: Text(&apos;demo&apos;),</span><br><span class="line">			overflow: TextOverflow.ellipsis,</span><br><span class="line">			maxLines: 1</span><br><span class="line">		),</span><br><span class="line">	),</span><br><span class="line">	width: 320.0,</span><br><span class="line">	height: 320.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="GestureDetector-处理手势"><a href="#GestureDetector-处理手势" class="headerlink" title="GestureDetector 处理手势"></a>GestureDetector 处理手势</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MyButton extends StatelessWidget &#123;</span><br><span class="line">	@override</span><br><span class="line">	Widget build (BuildContext context) &#123;</span><br><span class="line">		return GestureDetector(     		// IconButton等使用GestureDetector提供onPressed回调</span><br><span class="line">			onTap: () &#123;   					// onLongPress...</span><br><span class="line">				print(&apos;tapped&apos;)</span><br><span class="line">			&#125;,</span><br><span class="line">			child: Container(</span><br><span class="line">				child: Text(&apos;demo&apos;)</span><br><span class="line">			)</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="final-const-var-static-in-Dart"><a href="#final-const-var-static-in-Dart" class="headerlink" title="final const var static in Dart"></a>final const var static in Dart</h4><blockquote>
<p>static: 表示一个成员属于类而不是对象，修饰成员</p>
</blockquote>
<blockquote>
<p>final: 必须初始化，且值不可变，编译时不能确定值，修饰变量  //  final list = [1,2,3];  list[0] = 4;  =&gt; [4,2,3]</p>
</blockquote>
<blockquote>
<p>const: 编译时可确定，并且不能修改    // var list = const [1,2,3];  list[0] = 4;  error</p>
</blockquote>
<h4 id="typedef-类型定义，通过用来检查函数类型"><a href="#typedef-类型定义，通过用来检查函数类型" class="headerlink" title="typedef 类型定义，通过用来检查函数类型"></a>typedef 类型定义，通过用来检查函数类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef int Compart(int a, int b);</span><br><span class="line">int sort(int a, int b) =&gt; a - b;</span><br><span class="line">main() &#123;</span><br><span class="line">	assert(sort is Compare);   // True</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vernvn.github.io/2018/11/06/rxjs%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%8F%8A%E9%A1%B9%E7%9B%AE%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/17755520?s=400&u=9f444bfe70cd719b9bf43ed5fedac2f1d005ff5a&v=4">
      <meta itemprop="name" content="Lee_Ran">
      <meta itemprop="description" content="保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力混迹江湖的前端小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/06/rxjs%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%8F%8A%E9%A1%B9%E7%9B%AE%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">rxjs常用操作符及项目应用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-06 17:20:07" itemprop="dateCreated datePublished" datetime="2018-11-06T17:20:07+08:00">2018-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-11-15 17:08:43" itemprop="dateModified" datetime="2018-11-15T17:08:43+08:00">2018-11-15</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>RXJS全名Reactive Extensions for JavaScript，是JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。ReactiveX结合了观察者模式、迭代器模式和函数式编程构建一个管理事件序列的理想方式。</p>
<h4 id="RxJS所能解决的问题："><a href="#RxJS所能解决的问题：" class="headerlink" title="RxJS所能解决的问题："></a>RxJS所能解决的问题：</h4><p>时刻保持响应。这对于一个应用来说意味着当他处理用户的输入或者凭借AJAX从服务器接受一些数据时停止是一件不可能接受的事情。在JavaScript中解决问题的方案始终是大量运用回调函数来进行一些应用的处理。但回调的使用使内容丰富的大型应用变得凌乱，一旦你需要多块数据时你就陷入了回调地狱。Angular2中，组件间通讯@Output对应的EventEmitter实际上就是一个Subject；Http模块中Observable作为大部分API的交互对象使用。但是这只是官方推荐的外部扩展并不必须，也可以使用Promise,之后会介绍Observable和Promise的区别。</p>
<h4 id="RxJS初探："><a href="#RxJS初探：" class="headerlink" title="RxJS初探："></a>RxJS初探：</h4><h5 id="首先尝试一个简单的小例子："><a href="#首先尝试一个简单的小例子：" class="headerlink" title="首先尝试一个简单的小例子："></a>首先尝试一个简单的小例子：</h5><ul>
<li>存在一个数组，里面含有多种数据类型的元素</li>
<li>找到其中的数字及字数组成的字符串</li>
<li>每一个符合标准的元素乘以2</li>
<li>累加</li>
</ul>
<p>需要同时满足以上四个要求，可以通过循环列表来筛选满足要求的元素在进一步操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const source = [1, 5, 9, 3, &apos;hi&apos;, &apos;tb&apos;, 456, &apos;11&apos;, &apos;yoyoyo&apos;];</span><br><span class="line">let total = 0;</span><br><span class="line">for (let i = 0; i &lt; source.length; i++) &#123;</span><br><span class="line">    const num = parseInt(source[i], 10);</span><br><span class="line">    if (!isNaN(num)) &#123;</span><br><span class="line">        total += num * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果拥有函数式编程的经验，相信大家一定会通过es6的映射函数进行操作,接下来通过这个例子说明一下命令式编程和函数式编程的区别。</p>
<blockquote>
<p>声明式编程发轫于人工智能的研究，主要包括函数式编程（functional programming，简称FP）和逻辑式编程（logic programming，简称LP）;<br>如果想探究声明式编程与函数式编程的具体关系请访问：<a href="https://www.cnblogs.com/doit8791/p/8232821.html" target="_blank" rel="noopener">函数式与声明式的关系</a>，在此不是本篇的重点</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const source = [1, 5, 9, 3, &apos;hi&apos;, &apos;tb&apos;, 456, &apos;11&apos;, &apos;yoyoyo&apos;];</span><br><span class="line">let total = source  </span><br><span class="line">    .map(x =&gt; parseInt(x as any, 10))</span><br><span class="line">    .filter(x =&gt; !isNaN(x))</span><br><span class="line">    .map(x =&gt; x * 2)</span><br><span class="line">    .reduce((total, value) =&gt; total + value);</span><br></pre></td></tr></table></figure>
<p>函数式编程中的函数这个术语不是指计算机中的函数，而是指数学中的函数，即自变量的映射。也就是说一个函数返回的值仅决定于函数参数的值，不依赖其他状态。命令式编程注重的是函数执行的细节，函数式编程注重的是函数执行的结果。<br>函数式编程对函数的使用有一些特殊要求：</p>
<ul>
<li>声明式函数</li>
<li>纯函数</li>
<li>数据不可变性</li>
</ul>
<p>声明式编程是人脑思维方式的抽象，即利用数理逻辑或既定规范对已知条件进行推理或运算。声明式的函数，让开发者只需要表达”想要做什么”，而不需要表达“怎么去做”。<br>纯函数指的是执行结果由输入参数决定，参数相同时结果相同，不受其他数据影响，并且不会带来副作用的函数。副作用指的是函数做了和本身运算返回值没有关系的事情，如修改外部变量或传入的参数对象，甚至是执行console.log都算是副作用。前端中常见的副作用有发送http请求、操作DOM、调用alert或者confirm函数等。<br>数据不可变就是指这个数据一旦产生，它的值就永远不会变。JavaScript中字符串类型和数字类型就是不可改变的，而对象基本都是可变的，可能会带来各种副作用。</p>
<h4 id="函数式编程带来的好处主要可以总结为以下两点："><a href="#函数式编程带来的好处主要可以总结为以下两点：" class="headerlink" title="函数式编程带来的好处主要可以总结为以下两点："></a>函数式编程带来的好处主要可以总结为以下两点：</h4><ul>
<li>相比命令式编程，少了非常多的状态变量的声明与维护</li>
<li>代码更为简洁，可读性更强</li>
</ul>
<h3 id="进入RxJS"><a href="#进入RxJS" class="headerlink" title="进入RxJS"></a>进入RxJS</h3><p>流（Stream）无非是随<strong>时间</strong>流逝的一系列事件。流可以用来处理任何类型的事件，如：鼠标点击，键盘按下等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。Stream在其时间轴中发出三样东西，一个值，一个错误和完整的信号。我们必须捕获此异步事件并相应地执行函数。</p>
<p><img src="https://s1.ax1x.com/2018/09/20/im7Ry9.gif" alt=""></p>
<p>想要抓取事件，一般可以用 callback 或是 Promise 来达成，promise和observable都是为解决异步问题而设计的（避免“回调地狱”）, 然而 Promise 主要設设计一次性的事件与单一回傳=传值，而RxJS除了包含Promise外，提供了observable可观察对象，以惰性的方式推送多值的集合</p>
<h4 id="Pull拉取-VS-Push推送"><a href="#Pull拉取-VS-Push推送" class="headerlink" title="Pull拉取 VS Push推送"></a>Pull拉取 VS Push推送</h4><p>拉和推是数据生产者和数据的消费者两种不同的交流协议;什么是”pull”？在”pull”体系中，数据的消费者决定何时从数据生产者那里获取数据，而生产者自身并不会意识到什么时候数据将会被发送给消费者。每一个JS函数都是一个“pull”体系.<br>什么是”push”？在push体系中，数据的生产者决定何时发送数据给消费者，消费者不会在接收数据之前意识到它将要接收这个数据。<br>Promise(承诺))是当今JS中最常见的Push体系，一个Promise(数据的生产者)发送一个resolved value(成功状态的值)来注册一个回调(数据消费者)，但是不同于函数的地方的是：Promise决定着何时数据才被推送至这个回调函数。<br>RxJS引入了Observables(可观察对象)，一个全新的”推体系”。一个可观察对象是一个产生多值的生产者，并”推送给”Observer(观察者)。</p>
<h4 id="单值与多值"><a href="#单值与多值" class="headerlink" title="单值与多值"></a>单值与多值</h4><p>如果您通过Promise提出请求并等待回复。您可以确定对同一请求不会有多个响应。Observables允许您在调用observer.complete()函数之前解析多个值</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*ThbKddqq1qC4a1pDDjHNoQ.jpeg" alt=""></p>
<h4 id="总结RxJS-VS-Promise-——-三个最重要的区别"><a href="#总结RxJS-VS-Promise-——-三个最重要的区别" class="headerlink" title="总结RxJS VS Promise —— 三个最重要的区别"></a>总结RxJS VS Promise —— 三个最重要的区别</h4><table>
<thead>
<tr>
<th>区别</th>
<th style="text-align:center">Rxjs</th>
<th style="text-align:right">Promise</th>
</tr>
</thead>
<tbody>
<tr>
<td>动作是否可以取消？</td>
<td style="text-align:center">是</td>
<td style="text-align:right">否</td>
</tr>
<tr>
<td>是否可以发射多个值？</td>
<td style="text-align:center">是</td>
<td style="text-align:right">否</td>
</tr>
<tr>
<td>各种工具函数？</td>
<td style="text-align:center">是</td>
<td style="text-align:right">否</td>
</tr>
</tbody>
</table>
<h4 id="开始了解RxJS中的几个重要成员"><a href="#开始了解RxJS中的几个重要成员" class="headerlink" title="开始了解RxJS中的几个重要成员"></a>开始了解RxJS中的几个重要成员</h4><ul>
<li>Observable(可观察对象)：表示一个可调用的未来值或者时间序列上的事件集合</li>
<li>Observer(观察者)：一个回调函数集合,它知道怎样去监听被Observable发送的值</li>
<li>Subscription(订阅)： 表示一个可观察对象的执行，主要用于取消执行</li>
<li>Subject(主题)：等同于一个事件驱动器，是将一个值或者事件广播到多个观察者的唯一途径</li>
<li>Operators(操作符)： 纯函数，使得以函数编程的方式处理集合</li>
</ul>
<h4 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h4><p><img src="https://cdn-images-1.medium.com/max/1600/1*lq9uxKQpQZllnc-vNgzITg.jpeg" alt=""></p>
<p>Observable是一个具有一些特殊的特征的函数。它接收一个“观察者”（一个带有“next”，“error”和“complete”方法的对象）</p>
<ul>
<li>Observable支持在应用程序中的发布者和订阅者之间传递消息。</li>
<li>Observable很懒惰。它不会开始生成数据，直到您订阅它为止。</li>
<li>subscribe()返回一个订阅，消费者可以在unsubscribe()取消订阅并销毁生产者。</li>
<li>RxJS提供了许多可用于创建Observable的函数。这些函数可以简化创建可观察对象的过程</li>
</ul>
<h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h4><p>什么是Observer？Observer是Observable传递过来的数据的消费者。Observers由一个带有“next”，“error”和“complete”方法的对象构成，next、error、和 complete用来传递数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var observer = &#123;</span><br><span class="line">    next: x =&gt; console.log(&apos;Observable got a next value: &apos; + x),</span><br><span class="line">    error: err =&gt; console.log(&apos;Observable got and error: &apos; + err),</span><br><span class="line">    complete: () =&gt; console.log(&apos;Observable got a complete notification&apos;)</span><br><span class="line">&#125;;</span><br><span class="line">observable.subscribe(observer)</span><br></pre></td></tr></table></figure>
<h4 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h4><p>一个Subscription代表了一个一次性的资源，通常表示的是一个Observable执行。一个Subscription有一个重要的方法，unsubscribe，它不需要参数，仅仅是取消订阅释放资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const observable = interval(1000);</span><br><span class="line">const subscription = observable.subscribe(x =&gt; console.log(x));</span><br><span class="line">subscription.unsubscribe();</span><br></pre></td></tr></table></figure><br>Subscriptions也可以放在一起，这样会导致使用一个unsubscribe()将取消多个Observable执行，通过add、remove方法维护关联的Subscription</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const observable1 = interval(400);</span><br><span class="line">const observable2 = interval(300);</span><br><span class="line">const subscription = observable1.subscribe(x =&gt; console.log(&apos;first: &apos; + x));</span><br><span class="line">const childSubscription = observable2.subscribe(x =&gt; console.log(&apos;second: &apos; + x));</span><br><span class="line">subscription.add(childSubscription);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>
<h4 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h4><p><img src="https://cdn-images-1.medium.com/max/1600/1*pZ4lHOGYFBZUPHQJVpGrzg.jpeg" alt=""></p>
<ul>
<li><p>Subject是一种特殊类型的Observable，允许将值多播到许多观察者。虽然普通的Observable是单播的（每个订阅的Observer都拥有Observable的独立执行），但Subject是多播的</p>
</li>
<li><p><font color="#f00" size = 2>每一个Subject都是一个observable可观察对象，</font>给定一个Subject后，你可以订阅它，提供的观察者将会正常的开始接收值。从观察者的角度来看，它不能判断一个可观察对象的执行时来自于单播的Observable还是来自于一个Subject.<br>在Subject的内部，subscribe并不调用一个新的发送值得执行。它仅仅在观察者注册表中注册给定的观察者，类似addEventListener的工作方式。</p>
</li>
<li><p><font color="#f00" size = 2>每一个Subject都是一个Observer观察者对象。</font>它是一个拥有next()/error()/complete()方法的对象。要想Subject提供一个新的值，只需调用next()，它将会被多播至用来监听Subject的观察者。</p>
</li>
</ul>
<blockquote>
<p>Subject就是一个可观察对象，只不过可以被多播至多个观察者。同时Subject也类似于EventEmitter:维护者着众多事件监听器的注册表。</p>
</blockquote>
<h4 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h4><p>Subjects的一个变体是BehaviorSubject,其有”当前值”的概念。它储存着要发射给消费者的最新的值。无论何时一个新的观察者订阅它，都会立即接受到这个来自BehaviorSubject的”当前值”</p>
<blockquote>
<p>BehaviorSubject对于表示”随时间的值”是很有用的。举个例子，人的生日的事件流是一个Subject,然而人的年龄的流是一个BehaviorSubject。</p>
</blockquote>
<h4 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h4><p>一个ReplaySubject类似于一个BehaviorSubject，因为它可以发送一个过去的值(old values)给一个新的订阅者，但是它也可以记录可观察对象的一部分执行。</p>
<blockquote>
<p>一个ReplaySubject 从一个可观察对象的执行中记录多个值，并且可以重新发送给新的订阅者。</p>
</blockquote>
<h4 id="AsyncSubject"><a href="#AsyncSubject" class="headerlink" title="AsyncSubject"></a>AsyncSubject</h4><p>AsyncSubject是另一个变体，它只发送给观察者可观察对象执行的最新值，并且仅在执行结束时。AsyncSubject类似于last()操作符,因为它为了发送单一值而等待complete通知。</p>
<h4 id="常用的操作符"><a href="#常用的操作符" class="headerlink" title="常用的操作符"></a>常用的操作符</h4><p>每一个操作符都会产生一个新的Observable，不会对上游的Observable做任何修改，这完全符合函数式编程“数据不可变”的要求。pipe方法就是数据管道，会对数据流进行处理，可以添加操作符作为参数。</p>
<p><strong>interval</strong> 创建一个无限长度的周期性序列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interval(1000)  // 输出: 0,1,2...</span><br></pre></td></tr></table></figure></p>
<p><strong>timer</strong> 指定一个额外的参数来调节第一值的静默时长，第二个参数可选，若无则仅仅在规定的静默时长后输出一个值，然后结束序列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer(0,1000) // 输出:0,1,2...</span><br></pre></td></tr></table></figure><br><strong>from</strong> 可以将已有的数据转化为Observable,参数为iterable数据集对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from([1,2,3,4])   // 输出:1,2,3,4</span><br></pre></td></tr></table></figure><br><strong>of</strong> 不在同一个数据集中的多个来源的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">of([1,2,3])    //    [1,2,3]</span><br><span class="line">from([1,2,3])  //    1,2,3</span><br></pre></td></tr></table></figure><br><strong>fromEvent</strong> 将事件流转化为Observable,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const el = document.getElementById(&quot;btn&quot;); </span><br><span class="line">fromEvent(el,&quot;click&quot;);</span><br></pre></td></tr></table></figure><br><strong>delay</strong> 推迟   参数为数字或Date对象</p>
<p><strong>startWith</strong> 可以在源序列之前添加额外的元素</p>
<p><strong>map</strong> 对源序列进行变换，并返回新的序列(改变了源)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const source = of(1,2,3); // 输出： 1 2 3</span><br><span class="line">const target = source.map(x =&gt; x * 2);   //输出： 2 4 6</span><br></pre></td></tr></table></figure>
<p>concat<strong>有序</strong>拼接 ， merge<strong>无序</strong>拼接</p>
<p><img src="https://github.com/vernvn/hexoBlog/blob/master/decImg/concat.jpg?raw=true" alt=""></p>
<p><img src="https://github.com/vernvn/hexoBlog/blob/master/decImg/merge.jpg?raw=true" alt=""></p>
<p><strong>mergeMap</strong> 平坦化映射:首先将一个序列的各元素映射为序列，然后将各序列融合，参数是一个映射函数，返回值为序列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const source = fromEvent(document, &apos;click&apos;);</span><br><span class="line">    const target = source.pipe(</span><br><span class="line">    mapTo(1),</span><br><span class="line">    mergeMap(() =&gt; interval(1000).pipe(take(3)))</span><br><span class="line">    ).subscribe(res =&gt; console.log(res));   //输出： 0 1 2 0 ...</span><br></pre></td></tr></table></figure>
<p><strong>switchMap</strong>  与mergeMap的区别在于将最新的序列中的元素输出</p>
<p><strong>concatMap</strong>  将源序列各元素映射为序列，然后按顺序拼接 (与mergeMap的区别所在)</p>
<p><strong>filter</strong> 筛选源序列中满足条件的元素，并返回新的序列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const source = of(1,2,3,4,5); //序列： 1 2 3 4 5</span><br><span class="line">const target = source.filter(x =&gt; x &lt; 4)  //序列： 1 2 3</span><br></pre></td></tr></table></figure>
<p><strong>take</strong> 截取序列头部元素数量输出</p>
<p><strong>distinct</strong> 去重,并返回一个新序列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const source = of(1,2,2,3,4,2,1); //序列： 1 2 2 3 4 2 1</span><br><span class="line">const target = source.distinct(); //序列：1 2 3 4</span><br></pre></td></tr></table></figure><br><strong>distinctUntilChanged</strong> 相邻元素去重,并返回一个新序列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const source = of(1,2,2,3,4,2,1); //序列： 1 2 2 3 4 2 1</span><br><span class="line">const target = source.distinctUntilChanged(); //序列：1 2 3 4 2 1</span><br></pre></td></tr></table></figure></p>
<p><strong>debounce</strong>  去抖动,一段时间内只取最新数据作为一次发射数据，其他数据取消发射</p>
<p><strong>throttle</strong> (和debounce唯一区别是debounce取一段时间内最新的，而throttle忽略这段时间后，发现新值才发送, 通俗讲，都设定一个时间周期，持续触发事件，throttle为每到时间周期便会触发一次，bebounce为触发周期小于设定时间周期不予事件触发）</p>
<p><strong>zip</strong> 支持可变数量的序列作为参数，最后一个参数应当是一个组合函数， 其返回值将作为目标序列的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const source1 = of(1, 2, 3);</span><br><span class="line">const source2 = of(4, 5, 6);</span><br><span class="line">const target = zip(source1, source2).subscribe(([val1, val2]) =&gt; &#123;      // 序列： 1-4  2-5  3-6</span><br><span class="line">    console.log(val1 + &apos;-&apos; + val2)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><strong>forkJoin</strong>  将多个序列的最后一个元素组合为一个数组后，作为目标序列的唯一元素,一个常见用例是在页面加载时你希望发起多个请求，并在所有请求都响应后再采取行动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const source1 = of(1, 2, 3);</span><br><span class="line">const source2 = of(4, 5, 6);</span><br><span class="line">const target = forkJoin(source1, source2).subscribe(([val1, val2]) =&gt; &#123;   // 序列： 3-6</span><br><span class="line">    console.log(val1 + &apos;-&apos; + val2)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><strong>combineLatest</strong> 将多个序列的最后一个元素，使用组合函数构成目标序列的一个新元素</p>
<pre><code>const setHtml = id =&gt; val =&gt; document.getElementById(id).innerHTML = val;
const addOneClick$ = id =&gt; fromEvent(document.getElementById(id), &apos;click&apos;)
    .pipe(
        mapTo(1),
        startWith(0),
        scan((acc, curr) =&gt; acc + curr, 0),
        tap(setHtml(`${id}Total`))
    );
    const combineTotal$ = combineLatest(
        addOneClick$(&apos;red&apos;),
        addOneClick$(&apos;black&apos;)
    ).pipe(
        map(([val1, val2]) =&gt; val1 + val2)
    )
    .subscribe(setHtml(&apos;total&apos;));
</code></pre><p>map用于对自身对象数值进行映射，将发射对象转换成另一个发射对象发射， <font color="#f00" size = 2>返回一个包含映射结果的Observable对象</font> 而mergeMap是把自身对象里的数值进行映射并转换成一个新的Observable对象.<font color="#f00" size = 2>返回一个内部元素为映射的Observable对象的Observable对象</font></p>
<h4 id="marble-diagrams"><a href="#marble-diagrams" class="headerlink" title="marble diagrams"></a>marble diagrams</h4><p>为了解释operators是如何工作的，光是文本解释是不够的。许多operators和时间有关，它们可能会延迟执行，例如，throttle等。图标往往能够比文字更多表达清楚。Marble Diagrams能够可视化的表现出operators是如何工作的，包括输入的Observable(s)，operator和它的参数，以及输出的Observable.  <a href="http://rxmarbles.com/" target="_blank" rel="noopener">Marble diagrams</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vernvn.github.io/2018/03/01/git%E6%96%B0%E7%9A%84%E6%8C%87%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/17755520?s=400&u=9f444bfe70cd719b9bf43ed5fedac2f1d005ff5a&v=4">
      <meta itemprop="name" content="Lee_Ran">
      <meta itemprop="description" content="保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力混迹江湖的前端小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/01/git%E6%96%B0%E7%9A%84%E6%8C%87%E4%BB%A4/" class="post-title-link" itemprop="url">git新的指令</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2018-03-01 14:22:58 / 修改时间：17:00:06" itemprop="dateCreated datePublished" datetime="2018-03-01T14:22:58+08:00">2018-03-01</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="使用Git管理项目总结"><a href="#使用Git管理项目总结" class="headerlink" title="使用Git管理项目总结"></a>使用Git管理项目总结</h2><h4 id="导语："><a href="#导语：" class="headerlink" title="导语："></a>导语：</h4><blockquote>
<p>使用git已经一段时间了，总结一下我的理解关于使用git进行团队协作开发的流程。首先master分支作为主分支应该承担版本发布的责任。开发任务应该在develop分支上。不论当前分支是从哪个分支分离开来，都需要合并到那个分支上。根据需求的不同以及开发人员的指派，应该创建一系列feature-<em>分支，一旦开发完毕后，进行代码的review，确认无误后合并分支到develop分支上，之后删除相应的feature-</em>分支。在进行版本的发布前，需要从develop分支分离并创建对应的预发布分支，进行当前版本的测试，完成后，需要合并进develop分支和master分支，之后切换分支到master分支，生成版本节点标签并删除对应预发布分支，进行版本的发布。如果遇到bug问题，需要从master分支分离出修复bug分支，修复完成后合并进develop和master分支，之后切换分支到master分支，生成节点标签并删除对应bug分支。</p>
</blockquote>
<h3 id="一般的git命令已经用的很多了，今天记录几个很重要但是我自己在日常工作中很少使用的几个命令。"><a href="#一般的git命令已经用的很多了，今天记录几个很重要但是我自己在日常工作中很少使用的几个命令。" class="headerlink" title="一般的git命令已经用的很多了，今天记录几个很重要但是我自己在日常工作中很少使用的几个命令。"></a>一般的git命令已经用的很多了，今天记录几个很重要但是我自己在日常工作中很少使用的几个命令。</h3><h4 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h4><p>正在feature分支开发，master分支报了一个bug错误，此时需要即时修复bug,但是开发还没有完成，此时提交不太友好。Git提供的stash功能正好适用这个场景。可以把当前工作储存起来，处理完事情后继续工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash    // order code</span><br><span class="line">Saved working directory and index state WIP on feature-**: 4966d2d bingo</span><br></pre></td></tr></table></figure>
<p>此时git status查看工作区是干净的。此时可以创建临时分支处理bug。处理完bug后切换回feature-分支继续开发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list // order code</span><br><span class="line">stash@&#123;0&#125;: WIP on feature-**: 4966d2d bingo</span><br></pre></td></tr></table></figure>
<p>工作现场存在，现在需要恢复现场。两个办法：</p>
<ul>
<li><p>git stash apply &amp;&amp; git stash drop  // 前者恢复现场不删除stash内容，后者为补充删除stash内容</p>
</li>
<li><p>git stash pop  // 恢复现场同时删除stash内容</p>
</li>
</ul>
<p>如果多次stash的情况下，可以git stash list查看，然后恢复指定的stash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply stash@&#123;0&#125;  // 括号内为指定stash内容</span><br></pre></td></tr></table></figure>
<h4 id="–no-ff"><a href="#–no-ff" class="headerlink" title="–no-ff"></a>–no-ff</h4><p>这个参数的意思是保留原分支记录，默认情况下，执行fast-forward merge,直接将master分支指向develop分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff develop // 把develop合并进master分支</span><br></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/Kt1rngH.png" alt="fast-forward"></p>
<p><img src="http://i.imgur.com/rDt0UhJ.png" alt="--no-ff"></p>
<h4 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h4><p>比较两次修改的差异</p>
<h3 id="工作区-VS-暂存区"><a href="#工作区-VS-暂存区" class="headerlink" title="工作区 VS 暂存区"></a>工作区 VS 暂存区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git diff &lt;filename&gt;  </span><br><span class="line"></span><br><span class="line">$ git diff &lt;branch&gt; &lt;filename&gt; // 和另一分支的区别</span><br></pre></td></tr></table></figure>
<h3 id="暂存区-VS-Git仓库"><a href="#暂存区-VS-Git仓库" class="headerlink" title="暂存区 VS Git仓库"></a>暂存区 VS Git仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached &lt;filename&gt;  </span><br><span class="line"></span><br><span class="line">$ git diff --cached &lt;commit&gt; &lt;filename&gt; // 和指定commit的区别</span><br></pre></td></tr></table></figure>
<h3 id="工作目录-VS-Git仓库"><a href="#工作目录-VS-Git仓库" class="headerlink" title="工作目录 VS Git仓库"></a>工作目录 VS Git仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff &lt;commit&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Git仓库-VS-Git仓库"><a href="#Git仓库-VS-Git仓库" class="headerlink" title="Git仓库 VS Git仓库"></a>Git仓库 VS Git仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff &lt;commit&gt; &lt;commit&gt;  // git仓库任意两次commit的差别</span><br></pre></td></tr></table></figure>
<h2 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h2><p>以上命令可以不指定<filename>,则对应全部文件操作<br>以上命令涉及git仓库对比的，均可指定commit版本</p>
<ul>
<li><p>HEAD 最近一次commit</p>
</li>
<li><p>HEAD^ 上次提交</p>
</li>
<li><p>HEAD～100 上100次提交</p>
</li>
<li><p>每次提交产生的哈希值</p>
</li>
</ul>
<h4 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h4><h3 id="将某个分支上的所有提交记录移植到另一个分支上，清除不必要的提交记录"><a href="#将某个分支上的所有提交记录移植到另一个分支上，清除不必要的提交记录" class="headerlink" title="将某个分支上的所有提交记录移植到另一个分支上，清除不必要的提交记录"></a>将某个分支上的所有提交记录移植到另一个分支上，清除不必要的提交记录</h3><h3 id="永远不要rebase一个已经分享的分支"><a href="#永远不要rebase一个已经分享的分支" class="headerlink" title="永远不要rebase一个已经分享的分支"></a>永远不要rebase一个已经分享的分支</h3><p>一图以意之</p>
<p><img src="https://sfault-image.b0.upaiyun.com/206/854/2068544494-5783bdd025d80_articlex" alt="0"></p>
<h3 id="以下是一个例子讲解rebase的作用"><a href="#以下是一个例子讲解rebase的作用" class="headerlink" title="以下是一个例子讲解rebase的作用"></a>以下是一个例子讲解rebase的作用</h3><p><img src="https://backlog.com/git-tutorial/cn/img/post/stepup/capture_stepup2_8_1_1.png" alt="1"></p>
<p>切换到issue3分支后，对master执行rebase,解决冲突</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout issue3</span><br><span class="line">$ git rebase master</span><br></pre></td></tr></table></figure>
<p>冲突解决后不需要commit命令进行提交，而是执行rebase命令的continue选项或着abort选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git rebase --continue  /  --abort</span><br></pre></td></tr></table></figure>
<p><img src="https://backlog.com/git-tutorial/cn/img/post/stepup/capture_stepup2_8_1.png" alt="2"></p>
<p>master分支的issue3分支可以fast-forward了。切换到master分支执行合并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge issue3</span><br></pre></td></tr></table></figure>
<p>rebase的内容与merge的效果是一样的，但是历史记录会简洁</p>
<p><img src="https://backlog.com/git-tutorial/cn/img/post/stepup/capture_stepup2_8_2.png" alt="3"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vernvn.github.io/2018/02/08/ng2-translate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/17755520?s=400&u=9f444bfe70cd719b9bf43ed5fedac2f1d005ff5a&v=4">
      <meta itemprop="name" content="Lee_Ran">
      <meta itemprop="description" content="保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力混迹江湖的前端小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/02/08/ng2-translate/" class="post-title-link" itemprop="url">ng2-translate</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2018-02-08 15:56:40 / 修改时间：16:48:42" itemprop="dateCreated datePublished" datetime="2018-02-08T15:56:40+08:00">2018-02-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="i18n国际化，演示angular控件ng2-translate"><a href="#i18n国际化，演示angular控件ng2-translate" class="headerlink" title="i18n国际化，演示angular控件ng2-translate"></a>i18n国际化，演示angular控件ng2-translate</h2><p>app.module</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; TranslateModule, TranslateLoader, TranslateStaticLoader &#125; from &apos;ng2-translate&apos;;</span><br><span class="line">//..</span><br><span class="line">export function createTranslateStaticLoader(http: Http) &#123;</span><br><span class="line">    return new TranslateStaticLoader(http, &apos;./assets/i18n&apos;, &apos;.json&apos;);   // 发送请求，拿到i18n文件夹下的json后缀文件</span><br><span class="line">&#125;</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">    imports: [</span><br><span class="line">        TranslateModule.forRoot(&#123;</span><br><span class="line">            provide: TranslateLoader,</span><br><span class="line">            useFactory: createTranslateStaticLoader,</span><br><span class="line">            deps: [Http]</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>app.component</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import &#123; TranslateService &#125; from &apos;ng2-translate&apos;;</span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;app-root&apos;</span><br><span class="line">&#125;)</span><br><span class="line">export class AppComponent &#123;</span><br><span class="line">    constructor(</span><br><span class="line">        private translate: TranslateService</span><br><span class="line">    ) &#123;&#125;</span><br><span class="line">    ngOnInit() &#123;</span><br><span class="line">        this.translate.addLangs([&apos;zh&apos;, &apos;en&apos;]);</span><br><span class="line">        this.translate.setDefaultLang(&apos;zh&apos;);</span><br><span class="line">        const browserLang = this.translate.getBrowserLang();</span><br><span class="line">        this.translate.use(browserLang.match(/zh|en/) ? browserLang : &apos;zh&apos; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模版使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; word | trnaslate &#125;&#125;&lt;p&gt;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vernvn.github.io/2018/02/08/NgZone/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/17755520?s=400&u=9f444bfe70cd719b9bf43ed5fedac2f1d005ff5a&v=4">
      <meta itemprop="name" content="Lee_Ran">
      <meta itemprop="description" content="保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力混迹江湖的前端小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/02/08/NgZone/" class="post-title-link" itemprop="url">NgZone</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-02-08 10:22:09" itemprop="dateCreated datePublished" datetime="2018-02-08T10:22:09+08:00">2018-02-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-03-01 15:12:51" itemprop="dateModified" datetime="2018-03-01T15:12:51+08:00">2018-03-01</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><h4 align="center">利用Angular本身ChangeDetectionStrategyAPI改变检查策略脱离变化检测器，即减少不必要的检测来提高应用的性能</p>
<h4>

<h3 id="zone是什么"><a href="#zone是什么" class="headerlink" title="zone是什么"></a>zone是什么</h3><p>对浏览器的异步api做了封装，并对外发出通知何时开始何时结束，angular在得到异步事件结束的通知后，执行变化检查。</p>
<h3 id="zone性能优化的重点在哪"><a href="#zone性能优化的重点在哪" class="headerlink" title="zone性能优化的重点在哪"></a>zone性能优化的重点在哪</h3><p>精确的控制哪些异步事件是应该在angular的zone以内运行的，哪些是应该在angular的zone之外运行的。显然在angular的zone之外运行的事件是不会进行变化检测的，减少不必要的变化检测则实现了性能上的优化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NgZone &#125; from &apos;@angular/core&apos;;</span><br><span class="line">constructor(private zone: NgZone) &#123;&#125;</span><br><span class="line">mouseDown(event) &#123;</span><br><span class="line">    this.zone.runOutsideAngular(() =&gt; &#123;</span><br><span class="line">        window.document.addEventListener(&apos;mouseover&apos;, this.mouseMove.bind(this));  // 此处应该尽量避免直接操纵dom,应该利用底层封装api(renderer, renderer2)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NgZone可以让代码继续回到zone里运行，会再次触发anuglar的变化检测，调用NgZone.run();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mouseUp(event) &#123;</span><br><span class="line">    this.zone.run(() =&gt; &#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;)</span><br><span class="line">    window.docuemnt.removeEventListener(&apos;mousemove&apos;, this.mouseMove);  // 移除mousemove绑定的回调</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>zone.js为javascript提供执行上下文，可以在异步任务之间进行持久性传递。采用了猴子补丁将javascript中的异步任务包裹了一层。使得异步任务运行在zone的上下文中。每一个异步任务都被当作一个task,并在task基础上提供钩子函数。</p>
<ul>
<li><p>onZoneCreated: 产生一个新的zone对象时的钩子函数，zone.fork也会产生一个继承基类zone的新zone,形成一个独立的zone上下文</p>
</li>
<li><p>beforeTask: zone Task 执行前的钩子函数</p>
</li>
<li><p>afterTask</p>
</li>
<li><p>onError: zone运行Task时候的异常钩子函数</p>
</li>
</ul>
<p>并且对大多数异步事件进行了包裹封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const log = (phase) =&gt; &#123;</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">        console.log(&apos;i am in zone.js&apos; + phase + &apos;!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">zone.fork(&#123;</span><br><span class="line">    onZoneCreated: log(&apos;onZoneCreated&apos;),</span><br><span class="line">    beforeTask: log(&apos;beforeTask&apos;),</span><br><span class="line">    afterTask: log(&apos;afterTask&apos;)</span><br><span class="line">&#125;).run(() =&gt; &#123;</span><br><span class="line">    const methodLog = (func) =&gt; &#123;</span><br><span class="line">        return () =&gt; &#123;</span><br><span class="line">            console.log(&apos;i am from&apos; + func + &apos;function&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    foo = methodLog(&apos;foo&apos;),</span><br><span class="line">    bar = methodLog(&apos;bar&apos;),</span><br><span class="line">    baz = () =&gt; &#123;</span><br><span class="line">        setTimeout( methodLog(&apos;baz in setTimeout&apos;), 0)</span><br><span class="line">    &#125;;</span><br><span class="line">    foo(); </span><br><span class="line">    baz();</span><br><span class="line">    bar();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">i am in zone.js beforeTask;</span><br><span class="line">i am from foo function;</span><br><span class="line">i am from bar function;</span><br><span class="line">i am in zone.js afterTask;</span><br><span class="line"></span><br><span class="line">i am in zone.js onZoneCreated;</span><br><span class="line">i am in zone.js beforeTask;</span><br><span class="line">i am from baz in setTimeout function;</span><br><span class="line">i am in zone.js afterTask;</span><br></pre></td></tr></table></figure>
<p>上述例子中将run方法分为了两个task，分别为同步task和异步task。fork方法会产生一个继承根zone的子类，并在fork函数中配置特定的钩子函数，形成独立的zone上下文，而run方法则是启动执行业务代码的对外接口。</p>
<h3 id="使用Observable优化脏检查"><a href="#使用Observable优化脏检查" class="headerlink" title="使用Observable优化脏检查"></a>使用Observable优化脏检查</h3><p>使用OnPush的检查策略，如果修改了对象内部的值，此时不会进行脏检查，不会进行视图更新。此时可以选择Observable对象，通过手动调用markForCheck()方法进行优化，当前组件到根组件的路径上的所有组件都会进行变化检测。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    ...,</span><br><span class="line">    changeDetection: ChangeDetectionStrategy.OnPush</span><br><span class="line">&#125;)</span><br><span class="line">export class TodosComponent implements OnInit&#123;</span><br><span class="line">    @Input() todos: Observable&lt;Todo[]&gt;;</span><br><span class="line">    constructor(private cd: ChangeDetectorRef) &#123;&#125;</span><br><span class="line">    ngOnInit() &#123;</span><br><span class="line">        this.todos.subscribe(todos =&gt; &#123;</span><br><span class="line">            业务代码；</span><br><span class="line">            this.cd.markForCheck();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vernvn.github.io/2018/02/07/everyNote/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/17755520?s=400&u=9f444bfe70cd719b9bf43ed5fedac2f1d005ff5a&v=4">
      <meta itemprop="name" content="Lee_Ran">
      <meta itemprop="description" content="保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力混迹江湖的前端小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/02/07/everyNote/" class="post-title-link" itemprop="url">EveryNote</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-02-07 11:09:10" itemprop="dateCreated datePublished" datetime="2018-02-07T11:09:10+08:00">2018-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-02-08 17:13:53" itemprop="dateModified" datetime="2018-02-08T17:13:53+08:00">2018-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="记录每天学习中发现的知识点"><a href="#记录每天学习中发现的知识点" class="headerlink" title="记录每天学习中发现的知识点"></a>记录每天学习中发现的知识点</h2><font face="黑体" color="#f00" size = 4>总结TemplateRef与ViewContainerRef</font>

<h4 id="TemplateRef-用于表示内嵌的template模板元素，可以创建内嵌视图（createEmbeddedView）-可以访问到封装后的nativeElement-模板经过渲染后会替换成comment元素"><a href="#TemplateRef-用于表示内嵌的template模板元素，可以创建内嵌视图（createEmbeddedView）-可以访问到封装后的nativeElement-模板经过渲染后会替换成comment元素" class="headerlink" title="TemplateRef: 用于表示内嵌的template模板元素，可以创建内嵌视图（createEmbeddedView）,可以访问到封装后的nativeElement,模板经过渲染后会替换成comment元素"></a>TemplateRef: 用于表示内嵌的template模板元素，可以创建内嵌视图（createEmbeddedView）,可以访问到封装后的nativeElement,模板经过渲染后会替换成comment元素</h4><h4 id="ViewContainerRef-用于表示一个视图容器，可添加一或多个视图，通过ViewContainerRef实例，可以基于TemplateRef创建内嵌视图，并指定插入位置，主要创建管理内嵌视图"><a href="#ViewContainerRef-用于表示一个视图容器，可添加一或多个视图，通过ViewContainerRef实例，可以基于TemplateRef创建内嵌视图，并指定插入位置，主要创建管理内嵌视图" class="headerlink" title="ViewContainerRef: 用于表示一个视图容器，可添加一或多个视图，通过ViewContainerRef实例，可以基于TemplateRef创建内嵌视图，并指定插入位置，主要创建管理内嵌视图"></a>ViewContainerRef: 用于表示一个视图容器，可添加一或多个视图，通过ViewContainerRef实例，可以基于TemplateRef创建内嵌视图，并指定插入位置，主要创建管理内嵌视图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template #tpl&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">@ViewChild(&apos;tpl&apos;) tplRef: TemplateRef&lt;any&gt;;</span><br><span class="line">@ViewChild(&apos;tpl&apos;, &#123; read: ViewContainerRef &#125;) tplVcRef: ViewContainerRef;</span><br><span class="line">ngAfterViewInit()&#123;</span><br><span class="line">    this.tplVcRef.createEmbeddedView(this.tplRef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意：-ViewChild属性装饰器若未设置read属性，默认返回ElementRef对象实例"><a href="#注意：-ViewChild属性装饰器若未设置read属性，默认返回ElementRef对象实例" class="headerlink" title="注意：@ViewChild属性装饰器若未设置read属性，默认返回ElementRef对象实例"></a>注意：@ViewChild属性装饰器若未设置read属性，默认返回ElementRef对象实例</h3><font face="黑体" color="#f00" size = 4>指令的一般应用场景</font>

<h4 id="分类：内置指令，-自定义指令"><a href="#分类：内置指令，-自定义指令" class="headerlink" title="分类：内置指令， 自定义指令"></a>分类：内置指令， 自定义指令</h4><h4 id="主要考虑自定义指令的属性指令与结构指令"><a href="#主要考虑自定义指令的属性指令与结构指令" class="headerlink" title="主要考虑自定义指令的属性指令与结构指令"></a>主要考虑自定义指令的属性指令与结构指令</h4><h3 id="自定义属性指令实现简写"><a href="#自定义属性指令实现简写" class="headerlink" title="自定义属性指令实现简写"></a>自定义属性指令实现简写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Directive(&#123;</span><br><span class="line">    selector: &apos;[directivename]&apos;  // 这里定义的selector为什么使用中括号，是为了结合input装饰器获取属性值</span><br><span class="line">&#125;)</span><br><span class="line">export class SomeDirective &#123;</span><br><span class="line">    private _default = &apos;[someValue]&apos; // 旨在指令类内部定义默认值</span><br><span class="line">    @Input(directivename) directiveAnotherName;  // 输入属性</span><br><span class="line">    constructor(private el: ElementRef, private renderer: Renderer)&#123; // 引用类实例化，其中renderer对象提供许多api供渲染元素</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @HostListener(eventName) eventName()&#123;  // 监听宿主元素事件</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &lt;h1 [changeColor]=&quot;&apos;red&apos;&quot;&gt;&lt;/h1&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义结构指令是实现简写"><a href="#自定义结构指令是实现简写" class="headerlink" title="自定义结构指令是实现简写"></a>自定义结构指令是实现简写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Directive(&#123;</span><br><span class="line">    selector: &apos;[directivename]&apos;  // 这里定义的selector为什么使用中括号，是为了结合input装饰器获取属性值</span><br><span class="line">&#125;)</span><br><span class="line">export class SomeDirective &#123;</span><br><span class="line">    @Input(directivename)  </span><br><span class="line">    set condition(newCondition: boolean) &#123;  // 这里用了getter、setter存取器, 进行属性值的动态监听</span><br><span class="line">        if(newCondition)&#123;</span><br><span class="line">            this.tplVc.createEmbeddedView(this.tpl); // 创建内嵌视图,可以设置第二个参数&#123;$implicit: somevalue&#125;, 则angular提供了let模板语法，允许在生成的上下文是定义和传递</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            this.tplVc.clear();  // 清除内嵌视图</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(private tpf: TemplateRef, private tplVc: VireContainerRef)&#123; // 引用类实例化，用于创建内嵌视图</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &lt;h1 *structureDirective = true&gt;&lt;/h1&gt; // 这里用了angular结构性指令的语法糖，原理同*ngIf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结以上属性指令与结构指令"><a href="#总结以上属性指令与结构指令" class="headerlink" title="总结以上属性指令与结构指令"></a>总结以上属性指令与结构指令</h3><p><em>1 ElementRef与Renderer等的作用：支持跨平台，从底层封住，统一了api接口;
</em>2 TemplateRef与ViewContainerRef的作用： 前面有总结过他俩的作用;<br>*3 angular2中指令与组件的关系：组件继承与指令，并扩展了与视图的关系</p>
<h3 id="自定义debounceClick指令"><a href="#自定义debounceClick指令" class="headerlink" title="自定义debounceClick指令"></a>自定义debounceClick指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Directive(&#123;</span><br><span class="line">    selector: &apos;[directiveDebounceClick]&apos;</span><br><span class="line">&#125;)</span><br><span class="line">export class SomeDirective &#123;</span><br><span class="line">    @Input(&apos;debounceTime&apos;) debounceTime: string;</span><br><span class="line">    @Output(&apos;debounceClick&apos;)  debounceClick = new EventEmitter();</span><br><span class="line">    private clicks = new Subject&lt;any&gt;();  // 定义subject处理点击事件</span><br><span class="line">    constructor()&#123; &#125;</span><br><span class="line">    @HostListener(&apos;click&apos;,[&apos;$event&apos;])  // 监听宿主元素上的点击事件，第二个参数用于将事件传递给eventClick方法</span><br><span class="line">    eventClick(event)&#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">        event.stopPropagation();  // 阻止事件默认行为与事件冒泡</span><br><span class="line">        this.clicks.next(event);  // 发送新值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngOnInit()&#123;</span><br><span class="line">        this.clicks.debounceTime(this.debounceTime) // 去抖动,时间自定义</span><br><span class="line">        .subscribe(x =&gt; this.debounceClick.emit(x)); // 调用emit方法发出事件</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &lt;button directiveDebounceClick [debounceTime] =&apos;300&apos; (debounceClick)=&quot;log($event)&quot;&gt;&lt;/button&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font face="黑体" color="#f00" size = 4>ng-content包装器</font>

<h4 id="如果你尝试在-Angular-中编写可重复使用的组件，则可能会接触到内容投射的概念"><a href="#如果你尝试在-Angular-中编写可重复使用的组件，则可能会接触到内容投射的概念" class="headerlink" title="如果你尝试在 Angular 中编写可重复使用的组件，则可能会接触到内容投射的概念:"></a>如果你尝试在 Angular 中编写可重复使用的组件，则可能会接触到内容投射的概念:<ng-content></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;wrapper&apos;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">      &lt;ng-content&gt;&lt;/ng-content&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line">class Wrapper &#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;wrapper&apos;,</span><br><span class="line">  template: `</span><br><span class="line">  &lt;div class=&quot;box red&quot;&gt;</span><br><span class="line">    &lt;ng-content&gt;&lt;/ng-content&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;box blue&quot;&gt;</span><br><span class="line">    &lt;ng-content select=&quot;counter&quot;&gt;&lt;/ng-content&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  `,</span><br><span class="line">  styles: [`</span><br><span class="line">    .red &#123;background: red;&#125;</span><br><span class="line">    .blue &#123;background: blue;&#125;</span><br><span class="line">  `]</span><br><span class="line">&#125;)</span><br><span class="line">export class Wrapper &#123; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="将包装器的不同子项投影到模板的不同部分。-支持一个-select-属性，可以让你在特定的地方投射具体的内容。该属性支持-CSS-选择器（my-element，-my-class，-my-attribute-，…）来匹配你想要的内容。如果-ng-content-上没有设置-select-属性，它将接收全部内容，或接收不匹配任何其他-ng-content-元素的内容。"><a href="#将包装器的不同子项投影到模板的不同部分。-支持一个-select-属性，可以让你在特定的地方投射具体的内容。该属性支持-CSS-选择器（my-element，-my-class，-my-attribute-，…）来匹配你想要的内容。如果-ng-content-上没有设置-select-属性，它将接收全部内容，或接收不匹配任何其他-ng-content-元素的内容。" class="headerlink" title="将包装器的不同子项投影到模板的不同部分。 支持一个 select 属性，可以让你在特定的地方投射具体的内容。该属性支持 CSS 选择器（my-element，.my-class，[my-attribute]，…）来匹配你想要的内容。如果 ng-content 上没有设置 select 属性，它将接收全部内容，或接收不匹配任何其他 ng-content 元素的内容。"></a>将包装器的不同子项投影到模板的不同部分。<ng-content> 支持一个 select 属性，可以让你在特定的地方投射具体的内容。该属性支持 CSS 选择器（my-element，.my-class，[my-attribute]，…）来匹配你想要的内容。如果 ng-content 上没有设置 select 属性，它将接收全部内容，或接收不匹配任何其他 ng-content 元素的内容。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;wrapper&gt;</span><br><span class="line">  &lt;span&gt;This is not a counter&lt;/span&gt;</span><br><span class="line">  &lt;counter&gt;&lt;/counter&gt;</span><br><span class="line">&lt;/wrapper&gt;</span><br></pre></td></tr></table></figure>
<h4 id="counter组件被正确投影到第二个蓝色框中，而-span-元素最终会在全部红色框中。"><a href="#counter组件被正确投影到第二个蓝色框中，而-span-元素最终会在全部红色框中。" class="headerlink" title="counter组件被正确投影到第二个蓝色框中，而 span 元素最终会在全部红色框中。"></a>counter组件被正确投影到第二个蓝色框中，而 span 元素最终会在全部红色框中。</h4><h2 id="ngProjectAs"><a href="#ngProjectAs" class="headerlink" title="ngProjectAs"></a>ngProjectAs</h2><h4 id="内部组件会被隐藏在另一个更大的组件中。你只需要将其包装在额外的容器中即可应用-ngIf-或-ngSwitch。无论什么原因，通常情况下，你的内部组件不是包装器的直接子节点。所以需要使用ngProjectAs属性，将它用于指定的元素上。"><a href="#内部组件会被隐藏在另一个更大的组件中。你只需要将其包装在额外的容器中即可应用-ngIf-或-ngSwitch。无论什么原因，通常情况下，你的内部组件不是包装器的直接子节点。所以需要使用ngProjectAs属性，将它用于指定的元素上。" class="headerlink" title="内部组件会被隐藏在另一个更大的组件中。你只需要将其包装在额外的容器中即可应用 ngIf 或 ngSwitch。无论什么原因，通常情况下，你的内部组件不是包装器的直接子节点。所以需要使用ngProjectAs属性，将它用于指定的元素上。"></a>内部组件会被隐藏在另一个更大的组件中。你只需要将其包装在额外的容器中即可应用 ngIf 或 ngSwitch。无论什么原因，通常情况下，你的内部组件不是包装器的直接子节点。所以需要使用ngProjectAs属性，将它用于指定的元素上。</h4><font face="黑体" color="#f00" size = 3>表单自定义验证规则</font>

<h4 id="举例：邮件匹配"><a href="#举例：邮件匹配" class="headerlink" title="举例：邮件匹配"></a>举例：邮件匹配</h4><p>定义用户类型接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export interface User &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    account: &#123;</span><br><span class="line">        email: string;</span><br><span class="line">        confirm: string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>邮件匹配规则函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export const emailMatcher = (control: AbstractControl): &#123;[key: string]: boolean&#125; =&gt; &#123;</span><br><span class="line">   const email = control.get(&apos;email&apos;);</span><br><span class="line">   const confirm = control.get(&apos;confirm&apos;);</span><br><span class="line">   if (!email || !confirm)&#123;</span><br><span class="line">       return;</span><br><span class="line">   &#125;</span><br><span class="line">   return email.value === confirm.value ? null : &#123; nomatch: true &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>表单模版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, OnInit&#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; FormBuilder, FormGroup, Validators &#125; from &apos;@angular/forms&apos;;</span><br><span class="line">import &#123; emailMatcher &#125; from &apos;./email-matcher&apos;;</span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;signup=form&apos;,</span><br><span class="line">    template: `</span><br><span class="line">        &lt;form novalidate (ngSubmit)=&quot;onSubmit(user)&quot; [formGroup]=&quot;user&quot;&gt;</span><br><span class="line">            &lt;label&gt;</span><br><span class="line">               name...</span><br><span class="line">            &lt;/label&gt;</span><br><span class="line">            &lt;div *ngIf=&quot;user.get(&apos;name&apos;).touched &amp;&amp; user.get(&apos;name&apos;).hasError(&apos;required&apos;)&quot;&gt;</span><br><span class="line">                name is required</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div formGroupName = &quot;account&quot;&gt;</span><br><span class="line">                &lt;label&gt;</span><br><span class="line">                    &lt;span&gt;Email address&lt;/span&gt;</span><br><span class="line">                    &lt;input type=&quot;email&quot; placeholder=&quot;Your email address&quot; formControlName=&quot;email&quot;&gt;</span><br><span class="line">                &lt;/label&gt;</span><br><span class="line">                &lt;label&gt;</span><br><span class="line">                    &lt;span&gt;Confirm address&lt;/span&gt;</span><br><span class="line">                    &lt;input type=&quot;email&quot; placeholder=&quot;Confirm your email address&quot; formControlName=&quot;confirm&quot;&gt;</span><br><span class="line">                &lt;/label&gt;</span><br><span class="line">                &lt;div *ngIf=&quot;user.get(&apos;account&apos;).touched &amp;&amp; user.get(&apos;name&apos;).hasError(&apos;nomatch&apos;)&quot;&gt;</span><br><span class="line">                    name is required</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;button type=&quot;submit&quot; [disabled]=&quot;user.invalid&quot;&gt;Sign up&lt;/button&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br><span class="line">export class SignUpFormCOmponent implements OnInit &#123;</span><br><span class="line">    user: FormGroup;</span><br><span class="line">    constructor(private fb: FormBuilder)&#123;&#125;</span><br><span class="line">    ngOnInit() &#123;</span><br><span class="line">        this.user = this.fb.group(&#123;</span><br><span class="line">            name: [&apos;&apos;, Validators.required],</span><br><span class="line">            account: this.fb.group(&#123;</span><br><span class="line">                email: [&apos;&apos;, Validators.required],</span><br><span class="line">                confirm: [&apos;&apos;, Validators.rquired],</span><br><span class="line">            &#125;, &#123;validator: emailMatcher&#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<font face="黑体" color="#f00" size = 3>对比创建表单自定义验证指令</font>

<p>模版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name=&quot;password&quot; formControlName=&quot;password&quot; validateEqual=&quot;password&quot;&gt;</span><br><span class="line">&lt;input name=&quot;confirmpassword&quot; formControlName=&quot;confirmpassword&quot; validateEqual=&quot;password&quot;&gt;</span><br></pre></td></tr></table></figure><br>validateEqual指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Directive, forwardRef, Attribute &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; Validator, AbstractControl, NG_VALIDATORS &#125; from &apos;@angular/forms&apos;;</span><br><span class="line">@DIrective(&#123;</span><br><span class="line">    selector: &apos;[validateEqual][formControlName], [validateEqual][formControl],[validateEqual][ngModel]&apos; ,</span><br><span class="line">    providers: [&#123;</span><br><span class="line">        provide: NG_VALIDATORS,</span><br><span class="line">        useExisting: forward(() =&gt; EqualValidator),</span><br><span class="line">        multi: true</span><br><span class="line">    &#125;]</span><br><span class="line">    扩展</span><br><span class="line">&#125;)</span><br><span class="line">export class EqualValidator implements Validator &#123;</span><br><span class="line">    constructor(@Attribute(&apos;validateEqual&apos;) public validateEqual: string)&#123;&#125;</span><br><span class="line">    validate(control: AbstractControl): &#123; [key:string]: boolean &#125; &#123;</span><br><span class="line">        let v  = control.value;  使用指令的控件自身值: confirmpassword</span><br><span class="line">        let e  = control.root.get(this.validateEqual);  指令指定的控件: passwordControl;</span><br><span class="line">        if (e &amp;&amp; v !== e.value) &#123;</span><br><span class="line">            return &#123; validateEqual: false&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="验证器添加到指定控件，造成只有该控件数值变化才会进行验证，先输入confirmPassword造成验证器失效，需要给验证器添加reverse属性"><a href="#验证器添加到指定控件，造成只有该控件数值变化才会进行验证，先输入confirmPassword造成验证器失效，需要给验证器添加reverse属性" class="headerlink" title="验证器添加到指定控件，造成只有该控件数值变化才会进行验证，先输入confirmPassword造成验证器失效，需要给验证器添加reverse属性"></a>验证器添加到指定控件，造成只有该控件数值变化才会进行验证，先输入confirmPassword造成验证器失效，需要给验证器添加reverse属性</h4><h3 id="Forward-Reference"><a href="#Forward-Reference" class="headerlink" title="Forward Reference"></a>Forward Reference</h3><h4 id="不论es6、es7、还是ts作为开发语言，现阶段最终都会编译为es5的代码。es5中只有function并没有class。造成js代码编译阶段只有变量声明和函数声明会自动提升，而函数表达式并不会自动提升。所以要解决此问题可以使用Angular2提供的forward-reference特性进行解决-Buffer顺序在Socket之前声明也可以，但是angular项目中模块组件化开发确认注入依赖的顺序性会带来更大负担-。"><a href="#不论es6、es7、还是ts作为开发语言，现阶段最终都会编译为es5的代码。es5中只有function并没有class。造成js代码编译阶段只有变量声明和函数声明会自动提升，而函数表达式并不会自动提升。所以要解决此问题可以使用Angular2提供的forward-reference特性进行解决-Buffer顺序在Socket之前声明也可以，但是angular项目中模块组件化开发确认注入依赖的顺序性会带来更大负担-。" class="headerlink" title="不论es6、es7、还是ts作为开发语言，现阶段最终都会编译为es5的代码。es5中只有function并没有class。造成js代码编译阶段只有变量声明和函数声明会自动提升，而函数表达式并不会自动提升。所以要解决此问题可以使用Angular2提供的forward reference特性进行解决(Buffer顺序在Socket之前声明也可以，但是angular项目中模块组件化开发确认注入依赖的顺序性会带来更大负担)。"></a>不论es6、es7、还是ts作为开发语言，现阶段最终都会编译为es5的代码。es5中只有function并没有class。造成js代码编译阶段只有变量声明和函数声明会自动提升，而函数表达式并不会自动提升。所以要解决此问题可以使用Angular2提供的forward reference特性进行解决(Buffer顺序在Socket之前声明也可以，但是angular项目中模块组件化开发确认注入依赖的顺序性会带来更大负担)。</h4><font face="黑体" color="#f00" size = 3>es6+中的class不进行自动提升主要为了解决继承父类时，父类不可用的问题</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; forwardRef, Injectable &#125; from &apos;@angular2/core&apos;</span><br><span class="line">@Injectable()</span><br><span class="line">class Socket &#123;</span><br><span class="line">    constructor(@Inject(forwardRef(() =&gt; Buffer)) private buffer) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Buffer &#123;</span><br><span class="line">    constructor(@Inject(BUFFER_SIZE) private size: Number) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="OpaqueToken"><a href="#OpaqueToken" class="headerlink" title="OpaqueToken"></a>OpaqueToken</h3><h4 id="OpaqueToken允许创建基于字符串的Token类-在Provider中使用。只需导入Opaque类。"><a href="#OpaqueToken允许创建基于字符串的Token类-在Provider中使用。只需导入Opaque类。" class="headerlink" title="OpaqueToken允许创建基于字符串的Token类,在Provider中使用。只需导入Opaque类。"></a>OpaqueToken允许创建基于字符串的Token类,在Provider中使用。只需导入Opaque类。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; OpaqueToken &#125; from &apos;@angular/core&apos;;</span><br><span class="line">const CONFIG_TOKEN = new OpaqueToken(&apos;config&apos;);</span><br><span class="line">export const THIRDPARTYLIBPROVIDERS = [</span><br><span class="line">    &#123;</span><br><span class="line">        provide: CONFIG_TOKEN, useClass: ThirdPartyConfig</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>OpaqueToken类的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export class OpaqueToken &#123;</span><br><span class="line">    constructor(protected _desc: string) &#123;&#125;</span><br><span class="line">    toString() : string &#123;</span><br><span class="line">        return `Token$&#123;this._desc&#125;`</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>OpaqueToken类的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ReflectiveInjector, OpaquToken &#125; from &apos;@angular/core&apos;;</span><br><span class="line">const t = new OpaquToken(&apos;value&apos;);</span><br><span class="line">const injector = ReflectiveInjector.resolveAndCreate([</span><br><span class="line">    &#123;</span><br><span class="line">        provide: t,</span><br><span class="line">        useValue: &apos;bindingValue&apos;</span><br><span class="line">    &#125;</span><br><span class="line">]);</span><br><span class="line">injector.get(t)  // &apos;bindingValue&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="InjectionToken-Angular4"><a href="#InjectionToken-Angular4" class="headerlink" title="InjectionToken (Angular4+)"></a>InjectionToken (Angular4+)</h3><h4 id="使用ValueProvider"><a href="#使用ValueProvider" class="headerlink" title="使用ValueProvider"></a>使用ValueProvider</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@NgModule(&#123;</span><br><span class="line">    ...,</span><br><span class="line">    providers: [</span><br><span class="line">        &#123;</span><br><span class="line">            provide: &apos;apiUrl&apos;,</span><br><span class="line">            userValue: &apos;http://localhost:4200/heroes&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注入ProviderValue"><a href="#注入ProviderValue" class="headerlink" title="注入ProviderValue"></a>注入ProviderValue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Injectable()</span><br><span class="line">export class HeroService &#123;</span><br><span class="line">    constructor(</span><br><span class="line">        private loggerService: LoggerService,</span><br><span class="line">        @Inject(&apos;apiUrl&apos;) private apiUrl: String</span><br><span class="line">    )&#123;</span><br><span class="line">        console.log(apiUrl)  //  http://localhost:4200/heroes</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果引入了第三方库且名称相同就产生了问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export const THIRD_PARTY_PROVIDERS = [</span><br><span class="line">    &#123;</span><br><span class="line">        provide: &apos;apiUrl&apos;,   //  与localhost:4200相同</span><br><span class="line">        userValue: &apos;http://192.168.18.59:4200&apos;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>更新Provider配置信息则如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; THIRD_PARTY_PROVIDERS &#125; from &apos;./third-party&apos;;</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">    ...,</span><br><span class="line">    providers: [</span><br><span class="line">        &#123;</span><br><span class="line">        provide: &apos;apiUrl&apos;,</span><br><span class="line">        useValue: &apos;http://localhost:4200/heros&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        THIRD_PARTY_PROVIDERS</span><br><span class="line">    ],</span><br><span class="line">    bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<font face="黑体" color="#f00" size = 3>localhost:4200被覆盖</font>

<h4 id="使用字符串作为Token起冲突了。所以利用InjectionToken-Angular4-统一管理Token信息。"><a href="#使用字符串作为Token起冲突了。所以利用InjectionToken-Angular4-统一管理Token信息。" class="headerlink" title="使用字符串作为Token起冲突了。所以利用InjectionToken(Angular4+)统一管理Token信息。"></a>使用字符串作为Token起冲突了。所以利用InjectionToken(Angular4+)统一管理Token信息。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; InjectionToken &#125; from &apos;@angular/core&apos;;</span><br><span class="line">export const API_URL = new InjectionToken&lt;string&gt;(&apos;apiUrl&apos;);</span><br></pre></td></tr></table></figure>
<h4 id="OpaqueToken-与-InjectionToken-异同点"><a href="#OpaqueToken-与-InjectionToken-异同点" class="headerlink" title="OpaqueToken 与 InjectionToken 异同点"></a>OpaqueToken 与 InjectionToken 异同点</h4><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ul>
<li>创建可在Provider中使用的Token</li>
</ul>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul>
<li>前者ng2的类，后者ng4+引入的类，继承自OpaqueToken，且引入了泛型用于定义所关联的依赖对象的类型</li>
</ul>
<h2 id="Es6-Set-Map"><a href="#Es6-Set-Map" class="headerlink" title="Es6 Set Map"></a>Es6 Set Map</h2><h3 id="Es6提供了新的数据结构Set。类似于数组，但是成员都是唯一的，没有重复的值。接受一个数组或类数组对象作为参数"><a href="#Es6提供了新的数据结构Set。类似于数组，但是成员都是唯一的，没有重复的值。接受一个数组或类数组对象作为参数" class="headerlink" title="Es6提供了新的数据结构Set。类似于数组，但是成员都是唯一的，没有重复的值。接受一个数组或类数组对象作为参数"></a>Es6提供了新的数据结构Set。类似于数组，但是成员都是唯一的，没有重复的值。接受一个数组或类数组对象作为参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set([1,2,3,4,2]);</span><br><span class="line">[...set]    // [1,2,3,4]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set();</span><br><span class="line">[1,2,2,2,3,4].map(x =&gt; set.add(x));</span><br><span class="line">set   // [1,2,3,4]</span><br></pre></td></tr></table></figure>
<h4 id="Set内部，两个对象不相等，两个NaN相等，用length检测-可以用for…of遍历"><a href="#Set内部，两个对象不相等，两个NaN相等，用length检测-可以用for…of遍历" class="headerlink" title="Set内部，两个对象不相等，两个NaN相等，用length检测,可以用for…of遍历"></a>Set内部，两个对象不相等，两个NaN相等，用length检测,可以用for…of遍历</h4><ul>
<li><p>add(value)</p>
</li>
<li><p>delete(value) </p>
</li>
<li><p>has(value)</p>
</li>
<li><p>clear()</p>
</li>
</ul>
<h3 id="Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键-初始化Map需要一个二维数组，或者直接初始化一个空Map"><a href="#Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键-初始化Map需要一个二维数组，或者直接初始化一个空Map" class="headerlink" title="Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键, 初始化Map需要一个二维数组，或者直接初始化一个空Map"></a>Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键, 初始化Map需要一个二维数组，或者直接初始化一个空Map</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);</span><br><span class="line">m.get(&apos;Michael&apos;); // 95</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map();</span><br><span class="line">var o = &#123;p: &quot;Hello World&quot;&#125;;</span><br><span class="line">m.set(o, &quot;content&quot;)</span><br><span class="line">m.get(o)    // &quot;content&quot;</span><br><span class="line">m.has(o)    // true</span><br><span class="line">m.delete(o) // true</span><br><span class="line">m.has(o)    // false</span><br></pre></td></tr></table></figure>
<font face="黑体" color="#f00" size = 3>只有对同一个对象的引用，Map结构才视为同一个键</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var map = new Map();</span><br><span class="line">map.set([&apos;a&apos;], 555);</span><br><span class="line">map.get([&apos;a&apos;])   // undefined</span><br><span class="line">上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。</span><br></pre></td></tr></table></figure>
<h3 id="ModuleWithProviders"><a href="#ModuleWithProviders" class="headerlink" title="ModuleWithProviders"></a>ModuleWithProviders</h3><p>创建一个共享模块，包含部分功能性模块、管道、指令、和服务。对于服务，通常作为单例的服务可能被多次提供，可以通过在共享模块内部返回ModuleWithProviders对象的静态方法forRoot解决这类问题, (相对于将service注入在NgModule,通过forRoot方法返回具有NgModule属性的ModuleWithProviders对象，可以解决service多次提供的情况)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NgModule, ModuleWithProviders &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; someDirective, somePipe, someService &#125; from &apos;./functions&apos;;</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">    declarations: [</span><br><span class="line">        somePipe,</span><br><span class="line">        someDirective</span><br><span class="line">    ],</span><br><span class="line">    exports: [</span><br><span class="line">        somePipe,</span><br><span class="line">        someDirective </span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line">export class SharedModule &#123;</span><br><span class="line">    static forRoot() : ModuleWithProviders &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            ngModule: SharedModule,</span><br><span class="line">            providers: [ someService ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NgModule中并不提供服务，在模块类中定义forRoot静态方法，返回ModuleWithProviders接口对象，在应用模块中导入共享模块并调用静态方法forRoot来提供服务和其他指令管道等,这样根模块会把他得providers添加到根模块的服务提供商中，确切的说是angular会先累加所有的显式注入的提供商，然后进一步追加其他模块的提供商到@NgModule.providers中，可以确保显式添加的提供商优先级大于从其他模块导入的；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; SharedModule &#125; from &apos;./shared&apos;</span><br><span class="line">//:...</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">    imports: [</span><br><span class="line">        SharedModule.forRoot()</span><br><span class="line">    ],</span><br><span class="line">    //:...</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>不调用forRoot方法则会只访问共享的管道和指令，不在提供服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; SharedModule &#125; from &apos;./shared&apos;</span><br><span class="line">//:...</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">    imports: [</span><br><span class="line">        SharedModule、</span><br><span class="line">    ],</span><br><span class="line">    //:...</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123;&#125;</span><br></pre></td></tr></table></figure>
<font face="黑体" color="#f00" size = 3>Angular2中没有模块级别的service,所有在NgModule中声明的Provider都是注册在跟级别的DI中</font>

<h3 id="shadow-DOM-选择器"><a href="#shadow-DOM-选择器" class="headerlink" title="shadow DOM 选择器"></a>shadow DOM 选择器</h3><p>使用emulated进行样式隔离时，可以访问适用于shadow DOM的css选择器</p>
<h4 id="宿主"><a href="#宿主" class="headerlink" title="宿主"></a>宿主</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:host &#123;</span><br><span class="line">    color: red;    // &lt;song-track&gt;</span><br><span class="line">&#125;</span><br><span class="line">:host(.selected) &#123;</span><br><span class="line">    color: red;    // &lt;song-track class=&quot;selected&quot;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="样式依赖于祖先元素"><a href="#样式依赖于祖先元素" class="headerlink" title="样式依赖于祖先元素"></a>样式依赖于祖先元素</h4><p>它会在组件的宿主元素的祖先元素中查找汽配的祖先元素直到文档的根</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:host-content(.selected) &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">:host-content(#selected) &#123;</span><br><span class="line">    color: red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="宿主元素或后代元素-跨边界"><a href="#宿主元素或后代元素-跨边界" class="headerlink" title="宿主元素或后代元素(跨边界)"></a>宿主元素或后代元素(跨边界)</h4><p>它会覆盖任何封装的宿主元素或者其子元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:host /deep/ .selected&#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">:host &gt;&gt;&gt; .selected&#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font face="黑体" color="#f00" size = 3>angular-cli 启动的项目使用deep而不是&gt;&gt;&gt;</font>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vernvn.github.io/2017/12/28/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%8D%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/17755520?s=400&u=9f444bfe70cd719b9bf43ed5fedac2f1d005ff5a&v=4">
      <meta itemprop="name" content="Lee_Ran">
      <meta itemprop="description" content="保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力混迹江湖的前端小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/12/28/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%8D%95/" class="post-title-link" itemprop="url">自定义表单</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-12-28 13:47:16" itemprop="dateCreated datePublished" datetime="2017-12-28T13:47:16+08:00">2017-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-02-08 10:09:02" itemprop="dateModified" datetime="2018-02-08T10:09:02+08:00">2018-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ControlValueAccessor"><a href="#ControlValueAccessor" class="headerlink" title="ControlValueAccessor"></a>ControlValueAccessor</h2><h3 id="它是一个接口用于连接表单模型和视图，自定义表单必须实现这个接口，来实现模型与视图的映射关系"><a href="#它是一个接口用于连接表单模型和视图，自定义表单必须实现这个接口，来实现模型与视图的映射关系" class="headerlink" title="它是一个接口用于连接表单模型和视图，自定义表单必须实现这个接口，来实现模型与视图的映射关系"></a>它是一个接口用于连接表单模型和视图，自定义表单必须实现这个接口，来实现模型与视图的映射关系</h3><p>Angular引入它的原因在于不同的输入控件更新数据方式不同，input或checkbox,但是可以通过ControlValueAccessor统一</p>
<ul>
<li><p>DefaultValueAccessor - text/textarea类型</p>
</li>
<li><p>SelectControlValueAccessor - selec类型</p>
</li>
<li><p>CheckboxControlValueAccessor - checkbox类型</p>
</li>
</ul>
<h2 id="实现ControlValueAccessor接口"><a href="#实现ControlValueAccessor接口" class="headerlink" title="实现ControlValueAccessor接口"></a>实现ControlValueAccessor接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export interface ControlValueAccessor &#123;</span><br><span class="line">    writeValue(obj: any): void;     // 将模型中的新值写入视图</span><br><span class="line">    registerOnChange(fn: any): void;    // 当控件接收到change事件后，调用的函数，通知外部组件发生变化</span><br><span class="line">    registerOnTouched(fn: any): void;    // 接收到touched事件后调用的函数</span><br><span class="line">    setDisabledState?(isDisabled: boolean): void;    // 当控件状态变成DISABLED或ENABLE时，调用该函数启用或禁用dom</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component(...)</span><br><span class="line">class CounterComponent implements ControlValueAccessor &#123;</span><br><span class="line">    ...</span><br><span class="line">    propagateChange = (_: any) =&gt; &#123;&#125;;</span><br><span class="line">    registerOnChange(fn: any) &#123;</span><br><span class="line">        this.propagateChange = fn;   //  view层的值发生改变，通知外部</span><br><span class="line">    &#125;</span><br><span class="line">    registerOnTouched...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注册成为表单控件"><a href="#注册成为表单控件" class="headerlink" title="注册成为表单控件"></a>注册成为表单控件</h2><ul>
<li><p>NG_VALUE_ACCESSOR: token类型为ControlValueAccessor,将控件本身注册到DI框架，使其可以被表单访问</p>
</li>
<li><p>NG_VALIDTORS: 将控件注册成为一个可以让表单得到其验证状态的控件，token为function或Validator,配合useExisting可以让控件只暴露出对应的function或Validator的validate方法</p>
</li>
<li><p>forwardRef: 向前引用，允许我们引用一个尚未定义的对象</p>
</li>
<li><p>multi: 设置为true,该token对应多个依赖项，使用相同的token获取依赖项的时候，获取的是已注册的依赖对象列表。如果不是true,那么对于相同的token的提供商来说，后定义的提供商会覆盖前面定义的</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;exe-demo&apos;,</span><br><span class="line">    ...</span><br><span class="line">    provides: [</span><br><span class="line">             // 创建Token为NG_VALUE_ACCESSOR的提供商</span><br><span class="line">        &#123;</span><br><span class="line">            provide: NG_VALUE_ACCESSOR,</span><br><span class="line">            useExisting: forwardRef(() =&gt; SomeComponent),</span><br><span class="line">            multi: true</span><br><span class="line">        &#125;,</span><br><span class="line">             // 创建Token为NG_VALIDATORS的表单验证验证器</span><br><span class="line">        &#123;</span><br><span class="line">            provide: NG_VALIDATORS,</span><br><span class="line">            useValue: validateCounterRange,</span><br><span class="line">            multi: true</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, forwardRef , Input &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; ControlValueAccessor, NG_VALUE_ACCESSOR, NG_VALIDATORS, </span><br><span class="line">FormControl, ValidatorFn, ValidationErrors, AbstractControl &#125; from &apos;@angular/forms&apos;;</span><br><span class="line">export const EXE_COUNTER_VALUE_ACCESSOR: any = &#123;</span><br><span class="line">    provide: NG_VALUE_ACCESSOR,</span><br><span class="line">    useExisting: forwardRef(() =&gt; CounterComponent),</span><br><span class="line">    multi: true</span><br><span class="line">&#125;</span><br><span class="line">export const validateCounterRange: ValidatorFn = (control: AbstractControl) : ValidationErrors =&gt; &#123;</span><br><span class="line">   return ( control.value &gt; 10 || control.value &lt; 0 ) ? </span><br><span class="line">   &#123;</span><br><span class="line">       &apos;rangeError&apos;: &#123; current: control.value, max: 10, min: 0&#125;</span><br><span class="line">   &#125; : null</span><br><span class="line">&#125;</span><br><span class="line">export const EXE_COUNTER_VALIDATOR = &#123;</span><br><span class="line">    provide: NG_VALIDATORS,</span><br><span class="line">    useValue: validateCounterRange,  </span><br><span class="line">    multi: true</span><br><span class="line">&#125;</span><br><span class="line">@Component(&#123;</span><br><span class="line">    ...</span><br><span class="line">    provides: [</span><br><span class="line">        EXE_COUNTER_VALUE_ACCESSOR,</span><br><span class="line">        EXE_COUNTER_VALIDATOR</span><br><span class="line">    ],</span><br><span class="line">    changeDetection: ChangeDetectionStrategy.OnPush</span><br><span class="line">&#125;)</span><br><span class="line">export class CounterComponent implements ControlValueAccessor &#123;</span><br><span class="line">    @Input() _count: number = 0;</span><br><span class="line">    get count() &#123;</span><br><span class="line">        return this._count;</span><br><span class="line">    &#125;</span><br><span class="line">    set count(value: number) &#123;</span><br><span class="line">        this._count = value;</span><br><span class="line">        this.propagateChange(this._count);</span><br><span class="line">    &#125;</span><br><span class="line">    propagateChange = (_: any) =&gt; &#123;&#125;;</span><br><span class="line">    writeValue(value: any) &#123;</span><br><span class="line">        if (value) &#123;</span><br><span class="line">            this.count = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    registerOnchange(fn: any) &#123;</span><br><span class="line">        this.propagateChange = fn;</span><br><span class="line">    &#125;</span><br><span class="line">    registerOnTouched(fn: any) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    increment() &#123;</span><br><span class="line">        this.count++;</span><br><span class="line">    &#125;</span><br><span class="line">    decrement() &#123;</span><br><span class="line">        this.count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在Angular中通过Provider来描述与Token相关联的依赖对象的创建方式，分为以下四种"><a href="#在Angular中通过Provider来描述与Token相关联的依赖对象的创建方式，分为以下四种" class="headerlink" title="在Angular中通过Provider来描述与Token相关联的依赖对象的创建方式，分为以下四种"></a>在Angular中通过Provider来描述与Token相关联的依赖对象的创建方式，分为以下四种</h3><ul>
<li><p>useClass</p>
</li>
<li><p>useValue</p>
</li>
<li><p>useExisting</p>
</li>
<li><p>useFactory</p>
</li>
</ul>
<p><img src="https://sfault-image.b0.upaiyun.com/299/404/2994048125-58cc9e6c17087_articlex" alt="relation"></p>
<font color="#f00">useClass</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">providers: [ </span><br><span class="line">    &#123; provide: ApiService, useClass: ApiService &#125;  // 简介写法直接 ApiService</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<font color="#f00">useValue</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">providers: [ </span><br><span class="line">    &#123; provide: API_URL, useValue: &apos;http://my.api.com/v1&apos; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<font color="#f00">useExisting</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">providers: [ </span><br><span class="line">    &#123; provide: &apos;ApiServiceAlias&apos;, useValue: ApiService &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<font color="#f00">useFactory</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export function configFactory(config: AppConfig) &#123;</span><br><span class="line">    return () =&gt; config.load();</span><br><span class="line">&#125;</span><br><span class="line">providers: [ </span><br><span class="line">    &#123; provide: APP_INITIALIZER, useFactory: configFactory,</span><br><span class="line">    deps: [AppConfig, multi: true] &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vernvn.github.io/2017/12/15/12-15%20%20%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/17755520?s=400&u=9f444bfe70cd719b9bf43ed5fedac2f1d005ff5a&v=4">
      <meta itemprop="name" content="Lee_Ran">
      <meta itemprop="description" content="保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力混迹江湖的前端小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/12/15/12-15%20%20%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">12-15  日常笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-12-15 10:30:16" itemprop="dateCreated datePublished" datetime="2017-12-15T10:30:16+08:00">2017-12-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-02-08 10:09:02" itemprop="dateModified" datetime="2018-02-08T10:09:02+08:00">2018-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="日常遗忘知识点总结"><a href="#日常遗忘知识点总结" class="headerlink" title="日常遗忘知识点总结"></a>日常遗忘知识点总结</h2><h3 id="利用伪类实现自定义title"><a href="#利用伪类实现自定义title" class="headerlink" title="利用伪类实现自定义title"></a>利用伪类实现自定义title</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span mytitle=&quot;hello world&quot;&gt;Today is Friday&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">span[mytitle]:hover::after&#123;</span><br><span class="line">    content: attr(mytitle);</span><br><span class="line">    position: absolute;</span><br><span class="line">    right:0</span><br><span class="line">    color: #ff0;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="伪类清除浮动"><a href="#伪类清除浮动" class="headerlink" title="伪类清除浮动"></a>伪类清除浮动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;child1&quot; style=&quot;float:left;width:25%;&quot;&gt;&lt;/div&gt; </span><br><span class="line">    &lt;div class=&quot;child2&quot; style=&quot;float:right;width:25%;&quot;&gt;&lt;/div&gt; </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.parent::after&#123;</span><br><span class="line">    content: &apos;\0020&apos;;</span><br><span class="line">    height: 0;</span><br><span class="line">    display: block;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h3><blockquote>
<p>引自 <font color="#f00" size = 3>大漠老师的文章，进行flex布局的学习与记录总结</font>  <a href="https://www.w3cplus.com/css3/understanding-flexbox-everything-you-need-to-know.html" target="_blank" rel="noopener">原文地址</a></p>
</blockquote>
<p>显式声明flex容器后，启动了一个flexbox格式化上下文。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ul&#123;</span><br><span class="line">    display: flex;   //或者inline-flex;</span><br><span class="line">    li &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        margin: 8px;</span><br><span class="line">        background-color: #8cacea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-6.png" alt="flex"></p>
<p>display显示设置了flex属性后，自身变为flex容器，子元素变为了flex项目。</p>
<font color="#f00">容器属性: flex-direction || flex-wrap || flex-flow || justify-content || align-items || align-content</font>

<h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ul&#123;</span><br><span class="line">    flex-direction: row || column || row-reverse || column-reverse;   // default: row</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>row: 从左向右水平<br>…</p>
<h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ul&#123;</span><br><span class="line">    flex-wrap: wrap || norwrap || wrap-reverse;   // default: nowrap(不换行)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果拥有大量子元素，会自适应每个元素的大小，全部注入到一行内，即使宽度大于视窗宽度出现滚动条（nowrap）</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-15.png" alt="nowrap"></p>
<p>显示默认宽度都行排列，不会强迫一行有多少个flex项目（wrap）</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-16.png" alt="wrap"></p>
<h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p>是flex-direction和flex-wrap属性的速记属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ul&#123;</span><br><span class="line">    flex-flow: row wrap;</span><br><span class="line">    相当于  // flex-direction: row; flex-wrap: wrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><font color="#f00">接受属性值: flex-start || flex-end || center || space-between || space-around</font>


<p>flex-start: 左对齐 （default）</p>
<p>flex-end: 右对齐</p>
<p>center: 居中对齐</p>
<p>space-between: 两端对齐(除了第一个和最后一个部分，间距相等)</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-24.jpeg" alt="space-between"></p>
<p>space-around: 让每个flex元素都具有相同的空间</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-26.jpeg" alt="space-between"></p>
<h4 id="align-items-（不同于justify-content，它处理的是容器的纵向排列）"><a href="#align-items-（不同于justify-content，它处理的是容器的纵向排列）" class="headerlink" title="align-items （不同于justify-content，它处理的是容器的纵向排列）"></a>align-items （不同于justify-content，它处理的是容器的纵向排列）</h4><font color="#f00">接受属性值: flex-start || flex-end || center || stretch || baseline</font>


<p>stretch: 所有flex元素高度和容器高度一样 （default）</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-27.png" alt="stretch"></p>
<p>flex-start: 顶部对齐</p>
<p>flex-end: 底部对齐</p>
<p>center: 居中对齐</p>
<p>baseline: 沿着自身的基线对齐</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-32.jpeg" alt="baseline"></p>
<h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p>添加大量子元素，让其多行排列，该属性用于控制多行排列的flex容器的排列方式，效果类似align-items，expect baseline</p>
<font color="#f00">接受属性值: flex-start || flex-end || center || stretch</font>


<p>stretch: 纵向适应可用空间 （default）</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-33.png" alt="stretch"></p>
<p>flex-start: 沿着顶部到底部排列</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-34.png" alt="flex-start"></p>
<p>flex-end: 沿着低部到顶部排列</p>
<p>center: 居中</p>
<h2 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="未完待续。。。"></a>未完待续。。。</h2><h2 id="12-18-继续flex布局要点学习"><a href="#12-18-继续flex布局要点学习" class="headerlink" title="12.18 继续flex布局要点学习"></a>12.18 继续flex布局要点学习</h2><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p>允许flex项目在flex容器内重新排序，默认值为0，可以接受负值</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-38.png" alt="order=0"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li:nth-child(1)&#123; </span><br><span class="line">    order: 1; /*设置一个比0更大的值*/ </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从低到高拍下</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-39.png" alt="order=1"></p>
<h4 id="flex-grow-flex-shrink"><a href="#flex-grow-flex-shrink" class="headerlink" title="flex-grow | flex-shrink"></a>flex-grow | flex-shrink</h4><p>控制flex项目在容器的空间上进行扩展; 接受0或者大于0的任何正数，默认为0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&lt;ul&gt; </span><br><span class="line">    &lt;li&gt;I am a simple list&lt;/li&gt; </span><br><span class="line">&lt;/ul&gt; </span><br><span class="line"></span><br><span class="line">ul &#123; </span><br><span class="line">    display: flex; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当把flex-grow设置为1的时候，填充多余空间</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-43.png" alt="flex-grow"></p>
<p>当有多个flex项目需要进行扩展比设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#main div:nth-of-type(1) &#123;flex-grow: 1;&#125;</span><br><span class="line">#main div:nth-of-type(2) &#123;flex-grow: 3;&#125;</span><br><span class="line">#main div:nth-of-type(3) &#123;flex-grow: 1;&#125;</span><br><span class="line">#main div:nth-of-type(4) &#123;flex-grow: 1;&#125;</span><br><span class="line">#main div:nth-of-type(5) &#123;flex-grow: 1;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/vernvn/hexoBlog/blob/master/decImg/222.png?raw=true" alt="flex-grow"></p>
<p>当把flex-shrink设置为大于1的时候，缩小flex项目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=&quot;flex&quot;&gt;</span><br><span class="line">    &lt;li&gt;a&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;b&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;c&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">flex &#123;display:flex;width:400px;margin:0;padding:0;list-style:none;&#125;</span><br><span class="line">flex li&#123;width:200px;&#125;</span><br><span class="line">flex li:nth-child(3)&#123;flex-shrink:3;&#125;</span><br></pre></td></tr></table></figure>
<p>flex-shrink默认值为1，接受正整数，压缩空间比,c显式的定义了flex-shrink，a,b没有显式定义，但将根据默认值1来计算，可以看到总共将剩余空间分成了5份，其中a占1份，b占1份，c占3分，即1:1:3<br>我们可以看到父容器定义为400px，子项被定义为200px，相加之后即为600px，超出父容器200px。那么这么超出的200px需要被a,b,c消化<br>通过收缩因子，所以加权综合可得200 <em> 1+200 </em> 1+200 <em> 3=1000px；<br>于是我们可以计算a,b,c将被移除的溢出量是多少：<br>a被移除溢出量：(200</em>1/1000)<em>200，即约等于40px<br>b被移除溢出量：(200</em>1/1000)<em>200，即约等于40px<br>c被移除溢出量：(200</em>3/1000)*200，即约等于120px<br>最后a,b,c的实际宽度分别为：200-40=160px, 200-40=160px, 200-120=80px</p>
<h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>初始化flex项目的大小。默认值auto.接受任何用于width的值。px | % | rem | em; 如果为0也需要加单位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li &#123;</span><br><span class="line">    flex-basis: 150px;   // 初始固定大小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="flex速记"><a href="#flex速记" class="headerlink" title="flex速记"></a>flex速记</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li&#123;</span><br><span class="line">    flex: 0 1 auto;  // flex-grow、flex-shrink、flex-basis </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p>改变一个弹性项目沿着侧轴的位置而不影响弹性项目</p>
<font color="#f0f">接受属性值: auto || flex-start || flex-end || center || stretch || baseline</font>

<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-55.png" alt="stretch"></p>
<font color="#f0f">auto为设置为父元素的align-items的值，若没有父元的话，设置为stretch</font>

<h3 id="绝对和相对flex项目"><a href="#绝对和相对flex项目" class="headerlink" title="绝对和相对flex项目"></a>绝对和相对flex项目</h3><p>二者区别在于间距的计算，相对flex项目的间距根据内容大小计算，绝对flex项目的间距根据flex属性计算，而不是内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li&#123;</span><br><span class="line">    flex: 1 1 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-59.png" alt="relative"></p>
<p>flex-basis: auto; 宽度自动计算; 此时为相对flex项目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li&#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex项目变为绝对的了，<font color="#f0f">宽度计算依据flex属性</font></p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-61.png" alt="relative"></p>
<p>flex-basis: 0;  基于flex-grow共享可用空间</p>
<font color="#f00" size = 3>所有Flexbox属性都是基于合适的flex-direction起作用。</font>


<font color="#f0f" size = 3>当在Flex项目上使用 margin: auto 时，值为 auto 的方向（左、右或者二者都是）会占据所有剩余空间</font>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vernvn.github.io/2017/12/11/%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%E5%8F%8A%E5%8A%A0%E8%BD%BD%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/17755520?s=400&u=9f444bfe70cd719b9bf43ed5fedac2f1d005ff5a&v=4">
      <meta itemprop="name" content="Lee_Ran">
      <meta itemprop="description" content="保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力混迹江湖的前端小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/12/11/%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%E5%8F%8A%E5%8A%A0%E8%BD%BD%E7%AD%96%E7%95%A5/" class="post-title-link" itemprop="url">路由守卫及加载策略</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-12-11 17:18:16" itemprop="dateCreated datePublished" datetime="2017-12-11T17:18:16+08:00">2017-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-02-08 10:09:02" itemprop="dateModified" datetime="2018-02-08T10:09:02+08:00">2018-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><p>任何时候导航到任何地方往往不能满足业务需求，需要授权守护。返回值是boolean的三种形式</p>
<ul>
<li>Observable<boolean></li>
<li>Promise<boolean></li>
<li>boolean</li>
</ul>
<p>往往同步守卫不是一个好的选择，阻塞的情况时常发生。如果返回true，导航继续，否则，导航终止，停留原地</p>
<h4 id="The-router-supports-multiple-guard-interfaces"><a href="#The-router-supports-multiple-guard-interfaces" class="headerlink" title="The router supports multiple guard interfaces:"></a>The router supports multiple guard interfaces:</h4><ul>
<li><a href="https://www.angular.cn/api/router/CanActivate" target="_blank" rel="noopener">CanActivate</a>: 导航到某路由</li>
<li><a href="https://www.angular.cn/api/router/CanActivateChild" target="_blank" rel="noopener">CanActivateChild</a>: 导航到某子路由</li>
<li><a href="https://www.angular.cn/api/router/CanDeactivate" target="_blank" rel="noopener">CanDeactivate</a>: 处理当前路由离开情况</li>
<li><a href="https://www.angular.cn/api/router/Resolve" target="_blank" rel="noopener">Resolve</a>: 激活前获取路由数据</li>
<li><a href="https://www.angular.cn/api/router/CanLoad" target="_blank" rel="noopener">Canload</a>: 异步导航特性模块</li>
</ul>
<h4 id="在分层路由的每个级别上，我们都可以设置多个守卫。-路由器会先按照从最深的子路由由下往上检查的顺序来检查CanDeactivate-和CanActivateChild-守卫。-然后它会按照从上到下的顺序检查CanActivate-守卫。-如果特性模块是异步加载的，在加载它之前还会检查CanLoad-守卫。-如果任何一个守卫返回false，其它尚未完成的守卫会被取消，这样整个导航就被取消了。"><a href="#在分层路由的每个级别上，我们都可以设置多个守卫。-路由器会先按照从最深的子路由由下往上检查的顺序来检查CanDeactivate-和CanActivateChild-守卫。-然后它会按照从上到下的顺序检查CanActivate-守卫。-如果特性模块是异步加载的，在加载它之前还会检查CanLoad-守卫。-如果任何一个守卫返回false，其它尚未完成的守卫会被取消，这样整个导航就被取消了。" class="headerlink" title="在分层路由的每个级别上，我们都可以设置多个守卫。 路由器会先按照从最深的子路由由下往上检查的顺序来检查CanDeactivate()和CanActivateChild()守卫。 然后它会按照从上到下的顺序检查CanActivate()守卫。 如果特性模块是异步加载的，在加载它之前还会检查CanLoad()守卫。 如果任何一个守卫返回false，其它尚未完成的守卫会被取消，这样整个导航就被取消了。"></a>在分层路由的每个级别上，我们都可以设置多个守卫。 路由器会先按照从最深的子路由由下往上检查的顺序来检查CanDeactivate()和CanActivateChild()守卫。 然后它会按照从上到下的顺序检查CanActivate()守卫。 如果特性模块是异步加载的，在加载它之前还会检查CanLoad()守卫。 如果任何一个守卫返回false，其它尚未完成的守卫会被取消，这样整个导航就被取消了。</h4><h3 id="特性模块的授权验证"><a href="#特性模块的授权验证" class="headerlink" title="特性模块的授权验证"></a>特性模块的授权验证</h3><p>匿名用户会重定向到登录页，因为区分用户是否授权，所以创建在根目录下(auth-guard.ts)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Injectable &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; CanActivate, Router, ActivatedRouteSnapshot, RouterStateSnapshot &#125; from &apos;@angular/rotuer&apos;;</span><br><span class="line">@Injectable()</span><br><span class="line">export class AuthGuard implements CanActivate &#123;</span><br><span class="line">   constructor(private router: Router) &#123;&#125;</span><br><span class="line">   canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) &#123;</span><br><span class="line">        let url = state.url;</span><br><span class="line">        return this.checkLogin(url);</span><br><span class="line">   &#125;</span><br><span class="line">   checkLogin(url: string): boolean &#123;</span><br><span class="line">       if (&apos;登录成功标识&apos;) &#123;</span><br><span class="line">           reutrn true;</span><br><span class="line">       &#125;</span><br><span class="line">       this.router.navigate([&apos;/login&apos;]);</span><br><span class="line">       return false</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="#f00" size = 3 >ActivatedRouteSnapshot包含即将被激活的路由，RouterStateSnapshot包含即将到达的状态</font>   

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; AuthGuard &#125; from &apos;../aut-guard.service&apos;;</span><br><span class="line">const routes : Routes = [</span><br><span class="line">    path: &apos;admin&apos;,</span><br><span class="line">    component: AdminComponent,</span><br><span class="line">    canActive: [AuthGuard],</span><br><span class="line">    ...</span><br><span class="line">]</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">    providers: [</span><br><span class="line">        AuthGuard</span><br><span class="line">    ],</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="CanActivateChild区别在于子路由被激活前的守卫"><a href="#CanActivateChild区别在于子路由被激活前的守卫" class="headerlink" title="CanActivateChild区别在于子路由被激活前的守卫"></a>CanActivateChild区别在于子路由被激活前的守卫</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; CanActivateChild &#125; from &apos;@angular/router&apos;;</span><br><span class="line">canActivateChild(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean &#123;</span><br><span class="line">    return this.canActivate(route, state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const routes : Routes = [</span><br><span class="line">    path: &apos;admin&apos;,</span><br><span class="line">    component: AdminComponent,</span><br><span class="line">    canActive: [AuthGuard],</span><br><span class="line">    children: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: &apos;&apos;,</span><br><span class="line">            canActivateChild: [AuthGuard],</span><br><span class="line">            children: [</span><br><span class="line">                ...</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="CanDeactivate-处理未保存的更改-不保存并离开-true-保留更改并留下-false"><a href="#CanDeactivate-处理未保存的更改-不保存并离开-true-保留更改并留下-false" class="headerlink" title="CanDeactivate 处理未保存的更改;不保存并离开(true),保留更改并留下(false)"></a>CanDeactivate 处理未保存的更改;不保存并离开(true),保留更改并留下(false)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">canDeactivate(): Observable&lt;boolean&gt; | promise&lt;boolean&gt; | boolean &#123;</span><br><span class="line">    if (!this.changeStatus) &#123; </span><br><span class="line">        return true;   //如果没有改变直接导航，否则弹框</span><br><span class="line">    &#125;</span><br><span class="line">    return this.someService.confirm(&apos;discard changes?&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &apos;:id&apos;,</span><br><span class="line">    component: CrisisDetailComponent,</span><br><span class="line">    canDeactivate: [CanDeactivateGuard]</span><br><span class="line">&#125;</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">    providers: [</span><br><span class="line">        CanDeactivateGuard</span><br><span class="line">    ],</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Resolve-预先获取数据"><a href="#Resolve-预先获取数据" class="headerlink" title="Resolve 预先获取数据"></a>Resolve 预先获取数据</h3><p>如果响应时间够长，就需要预先从服务器上获取数据，路由激活瞬间数据渲染完毕，此处需要Resolve守卫。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">resolve(route: activatedRouteSnapshot, state: RouterStateSnapshot):Observable&lt;any&gt;&#123;</span><br><span class="line">   const id = route.paramMap.get(&apos;id&apos;);</span><br><span class="line">   return this.someService.getDate(id).map(x =&gt; &#123;</span><br><span class="line">       if (x) &#123;</span><br><span class="line">           return x;</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           this.router.naviagte([&apos;./someWhere&apos;]);</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// 此处可以阻止路由被加载，直到数据获取完毕,如果没有数据获取则导航回指定路由，并且NgModule的providers中需要注册</span><br></pre></td></tr></table></figure>
<h3 id="异步路由"><a href="#异步路由" class="headerlink" title="异步路由"></a>异步路由</h3><p>异步路由可以在获取请求时惰性加载特性模块，并且带来了一下好处</p>
<ul>
<li>对于体积庞大的特性模块可以在用户请求时进行加载</li>
<li>持续扩充特性模块的功能，不用增加初始加载的体积及速度</li>
<li>模块化开发提升开发效率，结构分明</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &apos;admin&apos;,</span><br><span class="line">    loadChildren: &apos;app/admin/admin.module#AdminModule&apos;   // 相对于app目录</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="#f00" size = 3>惰性加载只会发生一次，在该路由首次被请求时，后续的请求是立即可用的</font>

<h3 id="Canload守卫-保护对特性模块的未授权加载"><a href="#Canload守卫-保护对特性模块的未授权加载" class="headerlink" title="Canload守卫 保护对特性模块的未授权加载"></a>Canload守卫 保护对特性模块的未授权加载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">canload(route: Route): boolean &#123;</span><br><span class="line">    let url = `$&#123;route.path&#125;`;   // route为准备访问的目标地址</span><br><span class="line">    return this.checkLogin(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &apos;admin&apos;,</span><br><span class="line">    loadChildren: &apos;app/admin/admin.module#AdminModule&apos;,</span><br><span class="line">    canLoad: [AuthGuard]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="#f00" size = 3>路由加载形式:立即加载、惰性加载、预加载</font>

<h4 id="预加载好比后台加载，在保证了尽可能小的初始加载体积和首屏加载速度的同时，同样满足了特性模块的按需加载-理想情况下，首屏加载完毕后会有一个短暂的空档期，如果此时完成了接下来将要访问的模块的加载成功，体验会有很大提高。此时的加载就是预加载。"><a href="#预加载好比后台加载，在保证了尽可能小的初始加载体积和首屏加载速度的同时，同样满足了特性模块的按需加载-理想情况下，首屏加载完毕后会有一个短暂的空档期，如果此时完成了接下来将要访问的模块的加载成功，体验会有很大提高。此时的加载就是预加载。" class="headerlink" title="预加载好比后台加载，在保证了尽可能小的初始加载体积和首屏加载速度的同时，同样满足了特性模块的按需加载;理想情况下，首屏加载完毕后会有一个短暂的空档期，如果此时完成了接下来将要访问的模块的加载成功，体验会有很大提高。此时的加载就是预加载。"></a>预加载好比后台加载，在保证了尽可能小的初始加载体积和首屏加载速度的同时，同样满足了特性模块的按需加载;理想情况下，首屏加载完毕后会有一个短暂的空档期，如果此时完成了接下来将要访问的模块的加载成功，体验会有很大提高。此时的加载就是预加载。</h4><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>导航完成后，路由器会查找没有加载但是可以加载的模块，此时预加载策略决定了是否加载以及加载哪些模块。</p>
<h4 id="Router内置了两种预加载策略"><a href="#Router内置了两种预加载策略" class="headerlink" title="Router内置了两种预加载策略"></a>Router内置了两种预加载策略</h4><ul>
<li>完全不预加载，默认</li>
<li>预加载所有特性模块: PreloadAllModules</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; PreloadAllModules, RouterModule &#125; from &apos;@angular/router&apos;</span><br><span class="line">RouterModule.forRoot(appRoutes, &#123;</span><br><span class="line">    preloadingStrategy: PreloadAllModules</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<font color="#f00" size = 3>CanLoad守卫会阻塞预加载策略，优先级高于预加载策略</font>

<h3 id="自定义预加载策略"><a href="#自定义预加载策略" class="headerlink" title="自定义预加载策略"></a>自定义预加载策略</h3><p>结合路由定义时的data属性，只预加载preload为true的路由</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &apos;admin&apos;,</span><br><span class="line">    loadChildren: &apos;app/admin/admin.module#AdminModule&apos;,</span><br><span class="line">    data: &#123; preload: true &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加selective-preloading-strategy.ts,实现自定义预加载策略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; PreloadingStrategy , Route &#125; from &apos;@angular/router&apos;;</span><br><span class="line">@Injectable()</span><br><span class="line">export class SelectivePreloadingStrategy implements PreloadingStrategy &#123;</span><br><span class="line">    preloadModules: string[] = [];</span><br><span class="line">    preload(route: Route, load: () =&gt; Observable&lt;any&gt;) : Observable&lt;any&gt; &#123;</span><br><span class="line">        if (route.data &amp;&amp; route.data[&apos;preload&apos;]) &#123;</span><br><span class="line">            this.preloadModules.push(route.path);</span><br><span class="line">            return load();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Observable.of(null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如果要进行预加载，返回一个靠用加载器的Observable，否则返回一个null值的Observable对象。"><a href="#如果要进行预加载，返回一个靠用加载器的Observable，否则返回一个null值的Observable对象。" class="headerlink" title="如果要进行预加载，返回一个靠用加载器的Observable，否则返回一个null值的Observable对象。"></a>如果要进行预加载，返回一个靠用加载器的Observable，否则返回一个null值的Observable对象。</h4><h3 id="重定向迁移URL"><a href="#重定向迁移URL" class="headerlink" title="重定向迁移URL"></a>重定向迁移URL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; path: &apos;heroe/:id&apos;, redirectTo: &apos;/superHero/:id&apos;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RouterModule.forRoot(rotues, &#123; useHash: true &#125;) // 基于HashLocationStrategy</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vernvn.github.io/2017/10/29/%E8%A3%85%E9%A5%B0%E5%99%A8%E3%80%81%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/17755520?s=400&u=9f444bfe70cd719b9bf43ed5fedac2f1d005ff5a&v=4">
      <meta itemprop="name" content="Lee_Ran">
      <meta itemprop="description" content="保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力混迹江湖的前端小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/29/%E8%A3%85%E9%A5%B0%E5%99%A8%E3%80%81%E6%B3%9B%E5%9E%8B/" class="post-title-link" itemprop="url">装饰器、泛型</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-29 10:00:16" itemprop="dateCreated datePublished" datetime="2017-10-29T10:00:16+08:00">2017-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-02-08 10:09:02" itemprop="dateModified" datetime="2018-02-08T10:09:02+08:00">2018-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><h3 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h3><p>LogComponent组件只为负责打印日志，通过log装饰器修饰printLog方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export class LogComponent &#123;</span><br><span class="line">    @log</span><br><span class="line">    printLog(str) &#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function log(target: Object, propertyKey: string, descriptor: TypedPropertyDescriptor&lt;any&gt;) &#123;</span><br><span class="line">    // descriptor is a object contains writable, enumberable, configurable, setter, getter, value;</span><br><span class="line">    let origin = descriptor.value;</span><br><span class="line">    descriptor.value = function (...args) &#123;  // apply方法</span><br><span class="line">        console.log(this); // LogComponent</span><br><span class="line">        let result = origin.apply(this, args);</span><br><span class="line">        console.log(&apos;Log is - &apos; + result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    return descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用场景： 可以在其他组件内继承LogComponent，也可以封装为一个service,服务于各个组件，职责单一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export class AppComponent extends LogComponent  implements OnInit &#123;</span><br><span class="line">    constructor(</span><br><span class="line">        private viewContainerRef: ViewContainerRef,</span><br><span class="line">        private renderer: Renderer2,</span><br><span class="line">        private elementRef: ElementRef,</span><br><span class="line">    ) &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line">    ngOnInit(): void &#123;</span><br><span class="line">        this.setupMenus();</span><br><span class="line">        this.printLog(&apos;test&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    printLog(str) &#123;</span><br><span class="line">        super.printLog(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Injectable()</span><br><span class="line">export class AppService &#123;</span><br><span class="line">    login( @Inject name: string) &#123; &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Inject(target: Object, propertyKey: string, parameterIndex: number) &#123;</span><br><span class="line">    console.log(propertyKey); // login 参数名称，注意是方法名</span><br><span class="line">    console.log(parameterIndex); // 0 参数索引</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型（Generic）"><a href="#泛型（Generic）" class="headerlink" title="泛型（Generic）"></a>泛型（Generic）</h2><p>集合类型如果设置为any可以实现同时支持多种类型，但是放弃了原本支持的类型检查，泛型则是为了解决这一点；帮助进行后面的类型检查</p>
<pre><code>class Name&lt;T&gt;{
    sayName(name:T): void{
        console.log(&apos; hello, i&apos;m &apos; + name);
    }
}
let user1 = new Name&lt;string&gt;();
user1.sayName(&apos;lee&apos;);

let user2 = new Name&lt;number&gt;();
user2.sayName(3);
</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vernvn.github.io/2017/09/12/%E5%B8%B8%E8%A7%84%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%932017/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/17755520?s=400&u=9f444bfe70cd719b9bf43ed5fedac2f1d005ff5a&v=4">
      <meta itemprop="name" content="Lee_Ran">
      <meta itemprop="description" content="保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力混迹江湖的前端小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/12/%E5%B8%B8%E8%A7%84%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%932017/" class="post-title-link" itemprop="url">常规面试总结2017</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-12 09:59:19" itemprop="dateCreated datePublished" datetime="2017-09-12T09:59:19+08:00">2017-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-02-08 10:09:02" itemprop="dateModified" datetime="2018-02-08T10:09:02+08:00">2018-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="常规面试总结2017"><a href="#常规面试总结2017" class="headerlink" title="常规面试总结2017"></a>常规面试总结2017</h1><h4 id="导语："><a href="#导语：" class="headerlink" title="导语："></a>导语：</h4><blockquote>
<p>在2017年对前端领域内的常见的问题进行系统性的总结，说法可能会有所不妥，会综合网上资源发表自己的见解</p>
</blockquote>
<h2 id="1-前端安全的理解与防范"><a href="#1-前端安全的理解与防范" class="headerlink" title="1.前端安全的理解与防范"></a>1.前端安全的理解与防范</h2><p>开发过程中不可避免的会出现漏洞，黑客会抓住漏洞去攻击它获取利益，所以我们需要让我们的应用变的更加安全。</p>
<h3 id="前端攻击有哪些形式，如何防范"><a href="#前端攻击有哪些形式，如何防范" class="headerlink" title="前端攻击有哪些形式，如何防范"></a>前端攻击有哪些形式，如何防范</h3><h4 id="XSS攻击："><a href="#XSS攻击：" class="headerlink" title="XSS攻击："></a>XSS攻击：</h4><p>一种安全漏洞，允许代码植入到其他页面中，通过插入script标签获取用户信息</p>
<p>如何防范： 将前端输入输出数据进行转义，避免使用eval执行个人重要信息，使用httpOnly提升cookie的安全性，限制web页面浏览器端script程序读取cookie。当使用append的时候，Jquery会将元素变为fragment,接着查找其中的script标签，使用eval去执行，会造成之前的问题，所以将输入输出部分进行转义，同样使用img标签时当加载失败时会调用onError方法，此时插入攻击代码同样需要转义进行防范</p>
<h4 id="CSRF攻击："><a href="#CSRF攻击：" class="headerlink" title="CSRF攻击："></a>CSRF攻击：</h4><p>跨站请求伪造，利用一些提交行为转换到操作其他网站（在网站支付时打款被转义到黑客账户）；</p>
<p>如何防范： 遵循http协议，token即时验证，添加验证码阻止信息外泄</p>
<h4 id="控制台注入代码："><a href="#控制台注入代码：" class="headerlink" title="控制台注入代码："></a>控制台注入代码：</h4><p>不懂的人会被欺骗到某个网站在控制台通过执行某段代码暴漏个人信息从而被黑客截取。</p>
<h1 id="2-this指向与箭头函数"><a href="#2-this指向与箭头函数" class="headerlink" title="2.this指向与箭头函数"></a>2.this指向与箭头函数</h1><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p>this在函数执行时被绑定，指向为调用该函数的对象。函数调用模式的不同造就了this指向问题上的差异。<br>函数作为一个对象的方法时，this指向该对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;window&apos;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name: &apos;lee&apos;,</span><br><span class="line">    say: function()&#123;</span><br><span class="line">        console.log(this.name); // lee</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>函数暴漏在全局作用域下，this指向为window<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;window&apos;;</span><br><span class="line">function say()&#123;</span><br><span class="line">    console.log(this.name) // lee</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>构造函数内部this指向为构造函数实例对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Obj()&#123;</span><br><span class="line">    this.name = &apos;lee&apos;;</span><br><span class="line">&#125;</span><br><span class="line">var obj = new Obj();</span><br><span class="line">obj.name // lee;</span><br></pre></td></tr></table></figure></p>
<p>改变this指向的方法： apply、call、bind, call与apply的区别在于第二部分参数前者为多个参数，后者为一个参数数组，bind与它们的差异在于只是返回一个改变了this指向的新函数，需要调用，而apply与call在改变了this指向后立即执行了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;lee&quot;</span><br><span class="line">&#125;;</span><br><span class="line">function say() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">say();    //window</span><br><span class="line">say.apply(person);   //lee</span><br><span class="line">say.call(person);   //lee</span><br><span class="line">say.bind(person)();   //lee</span><br><span class="line">say.apply();    //window</span><br></pre></td></tr></table></figure></p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>es6新增的特性之一，简化了函数定义.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; (&#123;</span><br><span class="line">    foo: x    // 单纯的返回一个表达式对象，注意需要加（）</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>箭头函数内部this是词法作用域，由上下文确定；而函数中的this指向则在函数执行时根据调用模式确定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    birth: 1990,</span><br><span class="line">    getAge: function () &#123;</span><br><span class="line">        var b = this.birth; // 1990</span><br><span class="line">        var fn = function () &#123;</span><br><span class="line">            return new Date().getFullYear() - this.birth; // 匿名函数this指向window</span><br><span class="line">        &#125;;</span><br><span class="line">        var fn = () =&gt;  new Date().getFullYear() - this.birth; // this指向obj对象</span><br><span class="line">        </span><br><span class="line">        return fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="3-var-let-const-之间的区别"><a href="#3-var-let-const-之间的区别" class="headerlink" title="3.var let const 之间的区别"></a>3.var let const 之间的区别</h1><p>var定义的变量是该变量作用域的局部变量，可以定义全局变量，但是会污染全局环境不容易维护，不推荐。<br>const定义常量，且不可重新赋值，但是如果定义的变量是一个对象的话，对象内部变量是可以改变的。<br>let声明块级作用域，块作用域内的变量在包含它们的块或for循环之外是不能访问的，否定变量声明提升，对var的一种增强。<br>es6里面不建议使用var，因为其没有块级作用域，非严格模式下会有变量声明提升的情况，会产生意想不到的错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt;5; i++)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;,10)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果会是 5 5 5 5 5; 为什么呢，怎么能打印出想要的 0，1,2,3,4,呢？</p>
<p>setTimeout事件在for循环结束后触发，此时i的值为5，解决方法；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i&lt;5; i++)&#123;</span><br><span class="line">    (function(i)&#123;</span><br><span class="line">        setTimeout(function() &#123; console.log(i); &#125;, 10);</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>利用立即执行函数迭代i的值；如果利用块级作用域呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0; i &lt;5; i++)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;,10)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>每次for循环都会产生对应的作用域</p>
<h1 id="4-深拷贝与浅拷贝"><a href="#4-深拷贝与浅拷贝" class="headerlink" title="4.深拷贝与浅拷贝"></a>4.深拷贝与浅拷贝</h1><p>浅拷贝只是复制了对象的指针，不会赋值对象本身，公用一块内存，所以改变一个对象的属性值都会变化，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">    name: &apos;john&apos;</span><br><span class="line">&#125;</span><br><span class="line">var b = a;</span><br><span class="line">b.name = &apos;jeff&apos;;</span><br><span class="line"></span><br><span class="line">a // &#123; name: &apos;jeff&#125;;</span><br><span class="line">b // &#123; name: &apos;jeff&#125;;</span><br></pre></td></tr></table></figure><br>深拷贝则复制了对象，不会共享内存与指针，修改一个不会影响到另一个；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">    name: &apos;john&apos;</span><br><span class="line">&#125;</span><br><span class="line">var b = Object.assign(&#123;&#125;, a);</span><br><span class="line">b.name = &apos;jeff&apos;;</span><br><span class="line"></span><br><span class="line">a // &#123; name: &apos;john&#125;;</span><br><span class="line">b // &#123; name: &apos;jeff&#125;;</span><br></pre></td></tr></table></figure><br>但是由于javascript中存储对象都是存地址的，Object.assign的局限性存在于它只是相对浅拷贝深入了一层，换句话就是如果对象的属性值是一个指向对象的引用，它只拷贝那个引用值，可以利用对象字符串的转换（JSON.parse(JSON.stringify(obj)）与递归实现真正的深拷贝。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; a:1, arr: [2,3] &#125;;</span><br><span class="line">var shadowObj = Object.assign(&#123;&#125;, obj);</span><br><span class="line">obj.arr[0] = 22;</span><br><span class="line">obj.a = 11;</span><br><span class="line">// obj      &#123; a: 11, arr: [22,3]&#125;</span><br><span class="line">// shadObj  &#123; a: 1,  arr: [22,3]&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vernvn.github.io/2017/04/13/Subject/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/17755520?s=400&u=9f444bfe70cd719b9bf43ed5fedac2f1d005ff5a&v=4">
      <meta itemprop="name" content="Lee_Ran">
      <meta itemprop="description" content="保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力混迹江湖的前端小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/04/13/Subject/" class="post-title-link" itemprop="url">Subject</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-04-13 15:28:16" itemprop="dateCreated datePublished" datetime="2017-04-13T15:28:16+08:00">2017-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-02-08 10:09:02" itemprop="dateModified" datetime="2018-02-08T10:09:02+08:00">2018-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Rxjs-Subject-源码片段"><a href="#Rxjs-Subject-源码片段" class="headerlink" title="Rxjs Subject 源码片段"></a>Rxjs Subject 源码片段</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Subject继承于Observable </span><br><span class="line"> */</span><br><span class="line">export class Subject extends Observable &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.observers = []; // 观察者列表  </span><br><span class="line">        this.closed = false;</span><br><span class="line">        this.isStopped = false;</span><br><span class="line">        this.hasError = false;</span><br><span class="line">        this.thrownError = null;</span><br><span class="line">    &#125;</span><br><span class="line">    next(value) &#123;</span><br><span class="line">        if (this.closed) &#123;</span><br><span class="line">            throw new ObjectUnsubscribedError();</span><br><span class="line">        &#125;</span><br><span class="line">        if (!this.isStopped) &#123;</span><br><span class="line">            const &#123; observers &#125; = this;</span><br><span class="line">            const len = observers.length;</span><br><span class="line">            const copy = observers.slice();</span><br><span class="line">            for (let i = 0; i &lt; len; i++) &#123; // 循环调用观察者next方法，通知观察者</span><br><span class="line">                copy[i].next(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    error(err) &#123;</span><br><span class="line">        if (this.closed) &#123;</span><br><span class="line">            throw new ObjectUnsubscribedError();</span><br><span class="line">        &#125;</span><br><span class="line">        this.hasError = true;</span><br><span class="line">        this.thrownError = err;</span><br><span class="line">        this.isStopped = true;</span><br><span class="line">        const &#123; observers &#125; = this;</span><br><span class="line">        const len = observers.length;</span><br><span class="line">        const copy = observers.slice();</span><br><span class="line">        for (let i = 0; i &lt; len; i++) &#123; // 循环调用观察者error方法</span><br><span class="line">            copy[i].error(err);</span><br><span class="line">        &#125;</span><br><span class="line">        this.observers.length = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    complete() &#123;</span><br><span class="line">        if (this.closed) &#123;</span><br><span class="line">            throw new ObjectUnsubscribedError();</span><br><span class="line">        &#125;</span><br><span class="line">        this.isStopped = true;</span><br><span class="line">        const &#123; observers &#125; = this;</span><br><span class="line">        const len = observers.length;</span><br><span class="line">        const copy = observers.slice();</span><br><span class="line">        for (let i = 0; i &lt; len; i++) &#123; // 循环调用观察者complete方法</span><br><span class="line">            copy[i].complete();</span><br><span class="line">        &#125;</span><br><span class="line">        this.observers.length = 0; // 清空内部观察者列表</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="因为-Subject-在订阅时，是把-observer-存放到观察者列表中，并在接收到新值的时候，遍历观察者列表并调用观察者上的-next-方法"><a href="#因为-Subject-在订阅时，是把-observer-存放到观察者列表中，并在接收到新值的时候，遍历观察者列表并调用观察者上的-next-方法" class="headerlink" title="因为 Subject 在订阅时，是把 observer 存放到观察者列表中，并在接收到新值的时候，遍历观察者列表并调用观察者上的 next 方法"></a>因为 Subject 在订阅时，是把 observer 存放到观察者列表中，并在接收到新值的时候，遍历观察者列表并调用观察者上的 next 方法</h3><h3 id="Subject继承自Observable-将Observable的单路推送转换为多路推送。它就是讲单路Observable转变为多路Observable的桥梁。"><a href="#Subject继承自Observable-将Observable的单路推送转换为多路推送。它就是讲单路Observable转变为多路Observable的桥梁。" class="headerlink" title="Subject继承自Observable,将Observable的单路推送转换为多路推送。它就是讲单路Observable转变为多路Observable的桥梁。"></a>Subject继承自Observable,将Observable的单路推送转换为多路推送。它就是讲单路Observable转变为多路Observable的桥梁。</h3><h2 id="Subject的几个衍生类：BehaviorSubject-ReplaySubject-AsyncSubject"><a href="#Subject的几个衍生类：BehaviorSubject-ReplaySubject-AsyncSubject" class="headerlink" title="Subject的几个衍生类：BehaviorSubject,ReplaySubject,AsyncSubject;"></a>Subject的几个衍生类：BehaviorSubject,ReplaySubject,AsyncSubject;</h2><h3 id="BehaviorSubject：保存最近向数据消费者发送的值，当一个Observer订阅后，他会立即收到最新的值；它非常适合表示随时间推移的值；BehaviorSubject-形容一个人的生日，随时间不断更新；"><a href="#BehaviorSubject：保存最近向数据消费者发送的值，当一个Observer订阅后，他会立即收到最新的值；它非常适合表示随时间推移的值；BehaviorSubject-形容一个人的生日，随时间不断更新；" class="headerlink" title="BehaviorSubject：保存最近向数据消费者发送的值，当一个Observer订阅后，他会立即收到最新的值；它非常适合表示随时间推移的值；BehaviorSubject 形容一个人的生日，随时间不断更新；"></a>BehaviorSubject：保存最近向数据消费者发送的值，当一个Observer订阅后，他会立即收到最新的值；它非常适合表示随时间推移的值；BehaviorSubject 形容一个人的生日，随时间不断更新；</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var subject = new Rx.BehaviorSubject(0) //初始值</span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">    next:(v) =&gt; &#123;</span><br><span class="line">        console.log(&apos;A&apos; + v )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">subject.next(1);</span><br><span class="line">subject.next(2);</span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">    next:(v) =&gt; &#123;</span><br><span class="line">        console.log(&apos;B&apos; + v )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">subject.next(3);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var subject = new Rx.ReplaySubject(3); /* 回放数量 */</span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">subject.next(1);</span><br><span class="line">subject.next(2);</span><br><span class="line">subject.next(3);</span><br><span class="line">subject.next(4);</span><br><span class="line"></span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">subject.next(5);</span><br></pre></td></tr></table></figure>
<h3 id="ReplaySubject-如同于-BehaviorSubject-是-Subject-的子类。通过-ReplaySubject-可以向新的订阅者推送旧数值，就像一个录像机-ReplaySubject-可以记录Observable的一部分状态（过去时间内推送的值）-一个-ReplaySubject-可以记录Observable执行过程中推送的多个值，并向新的订阅者回放它们。"><a href="#ReplaySubject-如同于-BehaviorSubject-是-Subject-的子类。通过-ReplaySubject-可以向新的订阅者推送旧数值，就像一个录像机-ReplaySubject-可以记录Observable的一部分状态（过去时间内推送的值）-一个-ReplaySubject-可以记录Observable执行过程中推送的多个值，并向新的订阅者回放它们。" class="headerlink" title="ReplaySubject 如同于 BehaviorSubject 是 Subject 的子类。通过 ReplaySubject 可以向新的订阅者推送旧数值，就像一个录像机 ReplaySubject 可以记录Observable的一部分状态（过去时间内推送的值）;.一个 ReplaySubject 可以记录Observable执行过程中推送的多个值，并向新的订阅者回放它们。"></a>ReplaySubject 如同于 BehaviorSubject 是 Subject 的子类。通过 ReplaySubject 可以向新的订阅者推送旧数值，就像一个录像机 ReplaySubject 可以记录Observable的一部分状态（过去时间内推送的值）;.一个 ReplaySubject 可以记录Observable执行过程中推送的多个值，并向新的订阅者回放它们。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var subject = new Rx.AsyncSubject();</span><br><span class="line"></span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">subject.next(1);</span><br><span class="line">subject.next(2);</span><br><span class="line">subject.next(3);</span><br><span class="line">subject.next(4);</span><br><span class="line"></span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">subject.next(5);</span><br><span class="line">subject.complete();</span><br></pre></td></tr></table></figure>
<h3 id="AsyncSubject是Subject的另外一个衍生类，Observable仅会在执行完成后-complete-，推送执行环境中的最后一个值。业务上很少用"><a href="#AsyncSubject是Subject的另外一个衍生类，Observable仅会在执行完成后-complete-，推送执行环境中的最后一个值。业务上很少用" class="headerlink" title="AsyncSubject是Subject的另外一个衍生类，Observable仅会在执行完成后(complete)，推送执行环境中的最后一个值。业务上很少用"></a>AsyncSubject是Subject的另外一个衍生类，Observable仅会在执行完成后(complete)，推送执行环境中的最后一个值。业务上很少用</h3><h3 id="既然Subject是一个Observer，你可以把它作为subscribe（订阅）普通Observable时的参数"><a href="#既然Subject是一个Observer，你可以把它作为subscribe（订阅）普通Observable时的参数" class="headerlink" title="既然Subject是一个Observer，你可以把它作为subscribe（订阅）普通Observable时的参数"></a>既然Subject是一个Observer，你可以把它作为subscribe（订阅）普通Observable时的参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var subject = new Rx.Subject();</span><br><span class="line"></span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</span><br><span class="line">&#125;);</span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var observable = Rx.Observable.from([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">observable.subscribe(subject); // 你可以传递Subject来订阅observable</span><br></pre></td></tr></table></figure>
<h3 id="通过添加两个Observer到Observer列表中，之后Observable直接订阅Observer列表将普通的单路推送转换为多路推送"><a href="#通过添加两个Observer到Observer列表中，之后Observable直接订阅Observer列表将普通的单路推送转换为多路推送" class="headerlink" title="通过添加两个Observer到Observer列表中，之后Observable直接订阅Observer列表将普通的单路推送转换为多路推送"></a>通过添加两个Observer到Observer列表中，之后Observable直接订阅Observer列表将普通的单路推送转换为多路推送</h3><h2 id="Cold-amp-HOT"><a href="#Cold-amp-HOT" class="headerlink" title="Cold  &amp;  HOT"></a>Cold  &amp;  HOT</h2><h3 id="observable-is-default-cold-cold-表示只有-subscribe-出现-observer-才会被激活-当有多个subscribe时，每一个都是一条独立的链；hot-每个subscirbe共享一个链，不管什么时间插入subscribe-都不会重新开始。如何把一个cold-变成-hot？Subject则可以充当中介。multicast、refCount、publish、share则是通过Subject完成将cold转变为hot的方法。"><a href="#observable-is-default-cold-cold-表示只有-subscribe-出现-observer-才会被激活-当有多个subscribe时，每一个都是一条独立的链；hot-每个subscirbe共享一个链，不管什么时间插入subscribe-都不会重新开始。如何把一个cold-变成-hot？Subject则可以充当中介。multicast、refCount、publish、share则是通过Subject完成将cold转变为hot的方法。" class="headerlink" title="observable is default cold; cold: 表示只有 subscribe 出现 observer 才会被激活; 当有多个subscribe时，每一个都是一条独立的链；hot: 每个subscirbe共享一个链，不管什么时间插入subscribe,都不会重新开始。如何把一个cold 变成 hot？Subject则可以充当中介。multicast、refCount、publish、share则是通过Subject完成将cold转变为hot的方法。"></a>observable is default cold; cold: 表示只有 subscribe 出现 observer 才会被激活; 当有多个subscribe时，每一个都是一条独立的链；hot: 每个subscirbe共享一个链，不管什么时间插入subscribe,都不会重新开始。如何把一个cold 变成 hot？Subject则可以充当中介。multicast、refCount、publish、share则是通过Subject完成将cold转变为hot的方法。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let sub = new Subject();</span><br><span class="line">let obs = sub.map(v =&gt; &#123;</span><br><span class="line">    console.log(&quot;ajax call&quot;); </span><br><span class="line">&#125;);</span><br><span class="line">obs.subscribe(v =&gt; console.log(&quot;subscribe 1&quot;));</span><br><span class="line">obs.subscribe(v =&gt; console.log(&quot;subscribe 2&quot;));         </span><br><span class="line">sub.next(&quot;value&quot;); </span><br><span class="line">// ajax call</span><br><span class="line">// subscribe 1</span><br><span class="line">// ajax call</span><br><span class="line">// subscribe 2</span><br></pre></td></tr></table></figure>
<h3 id="模拟异步请求数据的业务场景，如果有更多的subscribe的时候，则会对请求服务器多次，造成服务器负载严重，此时一般解决方法为以下两种"><a href="#模拟异步请求数据的业务场景，如果有更多的subscribe的时候，则会对请求服务器多次，造成服务器负载严重，此时一般解决方法为以下两种" class="headerlink" title="模拟异步请求数据的业务场景，如果有更多的subscribe的时候，则会对请求服务器多次，造成服务器负载严重，此时一般解决方法为以下两种"></a>模拟异步请求数据的业务场景，如果有更多的subscribe的时候，则会对请求服务器多次，造成服务器负载严重，此时一般解决方法为以下两种</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obs = sub.map(v =&gt; &#123;</span><br><span class="line">    console.log(&quot;ajax call&quot;); </span><br><span class="line">&#125;).share();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obs = sub.map(v =&gt; &#123;</span><br><span class="line">    console.log(&quot;ajax call&quot;); </span><br><span class="line">&#125;).publish().refCount();</span><br></pre></td></tr></table></figure>
<h3 id="引入multicast（组播）的概念，通过中介者订阅源序列在由它推送出去-下面是它的运作方式"><a href="#引入multicast（组播）的概念，通过中介者订阅源序列在由它推送出去-下面是它的运作方式" class="headerlink" title="引入multicast（组播）的概念，通过中介者订阅源序列在由它推送出去,下面是它的运作方式"></a>引入multicast（组播）的概念，通过中介者订阅源序列在由它推送出去,下面是它的运作方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.interval(1000).take(3);</span><br><span class="line"></span><br><span class="line">var observerA = &#123;</span><br><span class="line">    next: value =&gt; console.log(&apos;A next: &apos; + value),</span><br><span class="line">    error: error =&gt; console.log(&apos;A error: &apos; + error),</span><br><span class="line">    complete: () =&gt; console.log(&apos;A complete!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var observerB = &#123;</span><br><span class="line">    next: value =&gt; console.log(&apos;B next: &apos; + value),</span><br><span class="line">    error: error =&gt; console.log(&apos;B error: &apos; + error),</span><br><span class="line">    complete: () =&gt; console.log(&apos;B complete!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var subject = &#123;</span><br><span class="line">    observers: [],</span><br><span class="line">    subscribe: function(observer) &#123;   //addObserver</span><br><span class="line">        this.observers.push(observer)</span><br><span class="line">    &#125;,</span><br><span class="line">    next: function(value) &#123;</span><br><span class="line">        this.observers.forEach(o =&gt; o.next(value))    </span><br><span class="line">    &#125;,</span><br><span class="line">    error: function(error)&#123;</span><br><span class="line">        this.observers.forEach(o =&gt; o.error(error))</span><br><span class="line">    &#125;,</span><br><span class="line">    complete: function() &#123;</span><br><span class="line">        this.observers.forEach(o =&gt; o.complete())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.subscribe(observerA)</span><br><span class="line"></span><br><span class="line">source.subscribe(subject);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    subject.subscribe(observerB);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>
<h3 id="换一种形式，用multicast方法来实现"><a href="#换一种形式，用multicast方法来实现" class="headerlink" title="换一种形式，用multicast方法来实现"></a>换一种形式，用multicast方法来实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.interval(1000)</span><br><span class="line">             .take(3)</span><br><span class="line">             .multicast(new Rx.Subject());</span><br><span class="line"></span><br><span class="line">var observerA = &#123;</span><br><span class="line">    next: value =&gt; console.log(&apos;A next: &apos; + value),</span><br><span class="line">    error: error =&gt; console.log(&apos;A error: &apos; + error),</span><br><span class="line">    complete: () =&gt; console.log(&apos;A complete!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var observerB = &#123;</span><br><span class="line">    next: value =&gt; console.log(&apos;B next: &apos; + value),</span><br><span class="line">    error: error =&gt; console.log(&apos;B error: &apos; + error),</span><br><span class="line">    complete: () =&gt; console.log(&apos;B complete!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">source.subscribe(observerA); // subject.subscribe(observerA)</span><br><span class="line"></span><br><span class="line">source.connect();    // source.subscribe(subject)  //开始推送 </span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    source.subscribe(observerB); // subject.subscribe(observerA)</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var result = Observable.interval(1000).take(6)  //执行两次</span><br><span class="line">             .map(x =&gt; Math.random())</span><br><span class="line">            //  .share()    //不会因为订阅者数量而执行多次</span><br><span class="line">            //  .publish().refCount()</span><br><span class="line"></span><br><span class="line">     var subA = result.subscribe(x =&gt; console.log(&apos;A: &apos; + x));</span><br><span class="line">     var subB = result.subscribe(x =&gt; console.log(&apos;B: &apos; + x));</span><br></pre></td></tr></table></figure>
<h3 id="常用应用场景"><a href="#常用应用场景" class="headerlink" title="常用应用场景"></a>常用应用场景</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let sub = new Subject();</span><br><span class="line">let obs = sub.map(v =&gt; &#123;</span><br><span class="line">    console.log(&quot;ajax call&quot;);  //请求接口</span><br><span class="line">&#125;);</span><br><span class="line">obs.subscribe(v =&gt; console.log(&quot;subscribe 1&quot;));  //分发</span><br><span class="line">obs.subscribe(v =&gt; console.log(&quot;subscribe 2&quot;));         </span><br><span class="line">sub.next(&quot;value&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="ajax会打印两次，增加服务器端负载；-调用share-方法；其中angular2中的http也是not-share的，在类似场景中同样的问题；"><a href="#ajax会打印两次，增加服务器端负载；-调用share-方法；其中angular2中的http也是not-share的，在类似场景中同样的问题；" class="headerlink" title="ajax会打印两次，增加服务器端负载； 调用share()方法；其中angular2中的http也是not share的，在类似场景中同样的问题；"></a>ajax会打印两次，增加服务器端负载； 调用share()方法；其中angular2中的http也是not share的，在类似场景中同样的问题；</h3><h3 id="建立一個-subject-先拿去訂閱-observable-source-，再把我們真正的-observer-加到-subject-中，這樣一來就能完成訂閱，而每個加到-subject-中的-observer-都能整組的接收到相同的元素。"><a href="#建立一個-subject-先拿去訂閱-observable-source-，再把我們真正的-observer-加到-subject-中，這樣一來就能完成訂閱，而每個加到-subject-中的-observer-都能整組的接收到相同的元素。" class="headerlink" title="建立一個 subject 先拿去訂閱 observable(source)，再把我們真正的 observer 加到 subject 中，這樣一來就能完成訂閱，而每個加到 subject 中的 observer 都能整組的接收到相同的元素。"></a>建立一個 subject 先拿去訂閱 observable(source)，再把我們真正的 observer 加到 subject 中，這樣一來就能完成訂閱，而每個加到 subject 中的 observer 都能整組的接收到相同的元素。</h3><h3 id="Observable-multicast-new-Rx-Subject-Observable-publish-对于Subject三种衍生形式，publishReplay-1-、publishBehavior-0-、publishLast"><a href="#Observable-multicast-new-Rx-Subject-Observable-publish-对于Subject三种衍生形式，publishReplay-1-、publishBehavior-0-、publishLast" class="headerlink" title="Observable.multicast(new Rx.Subject()) == Observable.publish();对于Subject三种衍生形式，publishReplay(1)、publishBehavior(0)、publishLast()"></a>Observable.multicast(new Rx.Subject()) == Observable.publish();对于Subject三种衍生形式，publishReplay(1)、publishBehavior(0)、publishLast()</h3><h3 id="另外-Observable-publish-refCount-Observable-share"><a href="#另外-Observable-publish-refCount-Observable-share" class="headerlink" title="另外   Observable.publish().refCount() == Observable.share()"></a>另外   Observable.publish().refCount() == Observable.share()</h3><h2 id="总结Subject！"><a href="#总结Subject！" class="headerlink" title="总结Subject！"></a>总结Subject！</h2><ul>
<li>既是Observable又是Observer</li>
<li>对内部的observers进行组播</li>
<li>observer default is cold and not share.(cold 表示只有 subscribe 出现 observer 才会被激活.    not share 表示每一个 subscribe 都会激活 observer 链)</li>
</ul>
<h3 id="业务场景：窗口a接收到A-b接收到B-c接受到C，本窗口d则需要异步的捕获a和b窗口的值并乘c窗口的值，d-a-b-c"><a href="#业务场景：窗口a接收到A-b接收到B-c接受到C，本窗口d则需要异步的捕获a和b窗口的值并乘c窗口的值，d-a-b-c" class="headerlink" title="业务场景：窗口a接收到A,b接收到B,c接受到C，本窗口d则需要异步的捕获a和b窗口的值并乘c窗口的值，d = (a+b)*c;"></a>业务场景：窗口a接收到A,b接收到B,c接受到C，本窗口d则需要异步的捕获a和b窗口的值并乘c窗口的值，d = (a+b)*c;</h3><h3 id="我们可以把每个数据的变更定义成流，然后定义出这些流的组合关系"><a href="#我们可以把每个数据的变更定义成流，然后定义出这些流的组合关系" class="headerlink" title="我们可以把每个数据的变更定义成流，然后定义出这些流的组合关系"></a>我们可以把每个数据的变更定义成流，然后定义出这些流的组合关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const A = new Rx.Subject()</span><br><span class="line">const B = new Rx.Subject()</span><br><span class="line">const C = new Rx.Subject()</span><br><span class="line"></span><br><span class="line">const D = Rx.Observable</span><br><span class="line">  .combineLatest(A, B, C)</span><br><span class="line">  .map(data =&gt; &#123;</span><br><span class="line">    let [a, b, c] = data</span><br><span class="line">    return (a + b) * c</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">D.subscribe(result =&gt; console.log(result))</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; A.next(2), 3000)</span><br><span class="line">setTimeout(() =&gt; B.next(3), 5000)</span><br><span class="line">setTimeout(() =&gt; C.next(5), 2000)</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; C.next(11), 10000)</span><br></pre></td></tr></table></figure>
<h3 id="为了简单，我们用定时器来模拟异步消息。实际业务中，对每个Subject的赋值是可以跟AJAX或者WebSocket结合起来，而且对D的那段实现毫无影响。我们可以看到，在整个这个过程中，最大的便利性在于，一旦定义完整个规则，变动整个表达式树上任意一个点，整个过程都会重跑一遍，以确保最终得到正确结果。无论中间环节上哪个东西变了，它只要更新自己就可以了，别人怎么用它的，不必关心。而且，我们从D的角度看，他只关心自己的数据来源是如何组织的，这些来源最终形成了一棵树，从各叶子汇聚到树根，也就是我们的订阅者这里，树上每个节点变更，都会自动触发从它往下到树根的所有数据变动，这个过程是最精确的，不会触发无效的数据更新。"><a href="#为了简单，我们用定时器来模拟异步消息。实际业务中，对每个Subject的赋值是可以跟AJAX或者WebSocket结合起来，而且对D的那段实现毫无影响。我们可以看到，在整个这个过程中，最大的便利性在于，一旦定义完整个规则，变动整个表达式树上任意一个点，整个过程都会重跑一遍，以确保最终得到正确结果。无论中间环节上哪个东西变了，它只要更新自己就可以了，别人怎么用它的，不必关心。而且，我们从D的角度看，他只关心自己的数据来源是如何组织的，这些来源最终形成了一棵树，从各叶子汇聚到树根，也就是我们的订阅者这里，树上每个节点变更，都会自动触发从它往下到树根的所有数据变动，这个过程是最精确的，不会触发无效的数据更新。" class="headerlink" title="为了简单，我们用定时器来模拟异步消息。实际业务中，对每个Subject的赋值是可以跟AJAX或者WebSocket结合起来，而且对D的那段实现毫无影响。我们可以看到，在整个这个过程中，最大的便利性在于，一旦定义完整个规则，变动整个表达式树上任意一个点，整个过程都会重跑一遍，以确保最终得到正确结果。无论中间环节上哪个东西变了，它只要更新自己就可以了，别人怎么用它的，不必关心。而且，我们从D的角度看，他只关心自己的数据来源是如何组织的，这些来源最终形成了一棵树，从各叶子汇聚到树根，也就是我们的订阅者这里，树上每个节点变更，都会自动触发从它往下到树根的所有数据变动，这个过程是最精确的，不会触发无效的数据更新。"></a>为了简单，我们用定时器来模拟异步消息。实际业务中，对每个Subject的赋值是可以跟AJAX或者WebSocket结合起来，而且对D的那段实现毫无影响。我们可以看到，在整个这个过程中，最大的便利性在于，一旦定义完整个规则，变动整个表达式树上任意一个点，整个过程都会重跑一遍，以确保最终得到正确结果。无论中间环节上哪个东西变了，它只要更新自己就可以了，别人怎么用它的，不必关心。而且，我们从D的角度看，他只关心自己的数据来源是如何组织的，这些来源最终形成了一棵树，从各叶子汇聚到树根，也就是我们的订阅者这里，树上每个节点变更，都会自动触发从它往下到树根的所有数据变动，这个过程是最精确的，不会触发无效的数据更新。</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vernvn.github.io/2017/02/28/rxjs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/17755520?s=400&u=9f444bfe70cd719b9bf43ed5fedac2f1d005ff5a&v=4">
      <meta itemprop="name" content="Lee_Ran">
      <meta itemprop="description" content="保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力混迹江湖的前端小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/28/rxjs/" class="post-title-link" itemprop="url">RxJS:万物皆为流</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-02-28 13:54:14" itemprop="dateCreated datePublished" datetime="2017-02-28T13:54:14+08:00">2017-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-02-08 10:09:02" itemprop="dateModified" datetime="2018-02-08T10:09:02+08:00">2018-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。最好的Rxjs中文文档"><a href="#首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。最好的Rxjs中文文档" class="headerlink" title="首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。最好的Rxjs中文文档"></a>首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。<a href="https://www.gitbook.com/book/buctwbzs/rxjs/details" target="_blank" rel="noopener">最好的Rxjs中文文档</a></h2><h3 id="RXJS全名Reactive-Extensions-for-JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。"><a href="#RXJS全名Reactive-Extensions-for-JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。" class="headerlink" title="RXJS全名Reactive Extensions for JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。"></a>RXJS全名Reactive Extensions for JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。</h3><h3 id="RxJS所能解决的问题："><a href="#RxJS所能解决的问题：" class="headerlink" title="RxJS所能解决的问题："></a>RxJS所能解决的问题：</h3><h4 id="时刻保持响应。这对于一个应用来说意味着当他处理用户的输入或者凭借AJAX从服务器接受一些数据时停止是一件不可能接受的事情。在JavaScript中解决问题的方案始终是大量运用回调函数来进行一些运行的处理。但回调的使用使内容丰富的大型应用变得凌乱，一旦你需要多块数据时你就陷入了回调地狱。Angular2中，组件间通讯-Output对应的EventEmitter实际上就是一个Subject-主题：同时为Observable和Observer-Http模块中Observable作为大部分API的交互对象使用。但是这只是官方的外部扩展，并不必须，也可以使用-toPromise的方式转换为Promise来使用或第三方扩展库或Fetch-API-传统Ajax已死，Fetch永生。"><a href="#时刻保持响应。这对于一个应用来说意味着当他处理用户的输入或者凭借AJAX从服务器接受一些数据时停止是一件不可能接受的事情。在JavaScript中解决问题的方案始终是大量运用回调函数来进行一些运行的处理。但回调的使用使内容丰富的大型应用变得凌乱，一旦你需要多块数据时你就陷入了回调地狱。Angular2中，组件间通讯-Output对应的EventEmitter实际上就是一个Subject-主题：同时为Observable和Observer-Http模块中Observable作为大部分API的交互对象使用。但是这只是官方的外部扩展，并不必须，也可以使用-toPromise的方式转换为Promise来使用或第三方扩展库或Fetch-API-传统Ajax已死，Fetch永生。" class="headerlink" title="时刻保持响应。这对于一个应用来说意味着当他处理用户的输入或者凭借AJAX从服务器接受一些数据时停止是一件不可能接受的事情。在JavaScript中解决问题的方案始终是大量运用回调函数来进行一些运行的处理。但回调的使用使内容丰富的大型应用变得凌乱，一旦你需要多块数据时你就陷入了回调地狱。Angular2中，组件间通讯@Output对应的EventEmitter实际上就是一个Subject(主题：同时为Observable和Observer);Http模块中Observable作为大部分API的交互对象使用。但是这只是官方的外部扩展，并不必须，也可以使用.toPromise的方式转换为Promise来使用或第三方扩展库或Fetch API 传统Ajax已死，Fetch永生。"></a>时刻保持响应。这对于一个应用来说意味着当他处理用户的输入或者凭借AJAX从服务器接受一些数据时停止是一件不可能接受的事情。在JavaScript中解决问题的方案始终是大量运用回调函数来进行一些运行的处理。但回调的使用使内容丰富的大型应用变得凌乱，一旦你需要多块数据时你就陷入了回调地狱。Angular2中，组件间通讯@Output对应的EventEmitter实际上就是一个Subject(主题：同时为Observable和Observer);Http模块中Observable作为大部分API的交互对象使用。但是这只是官方的外部扩展，并不必须，也可以使用.toPromise的方式转换为Promise来使用或第三方扩展库或Fetch API <a href="https://segmentfault.com/a/1190000003810652" target="_blank" rel="noopener">传统Ajax已死，Fetch永生</a>。</h4><p><br></p>
<h3 id="RxJS初探："><a href="#RxJS初探：" class="headerlink" title="RxJS初探："></a>RxJS初探：</h3><h4 id="RxJS是一个解决异步问题的JS开发库-它带来了观察者模式和函数式编程的相结合的最佳实践。-观察者模式是一个被实践证明的模式，基于生产者（事件的创建者）和消费者（事件的监听者）的逻辑分离关系-况且函数式编程方式的引入，如说明性编程，不可变数据结构，链式方法调用会使你极大的简化代码量。RxJS-引入了一个重要的数据类型——流（stream）。流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下，等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。"><a href="#RxJS是一个解决异步问题的JS开发库-它带来了观察者模式和函数式编程的相结合的最佳实践。-观察者模式是一个被实践证明的模式，基于生产者（事件的创建者）和消费者（事件的监听者）的逻辑分离关系-况且函数式编程方式的引入，如说明性编程，不可变数据结构，链式方法调用会使你极大的简化代码量。RxJS-引入了一个重要的数据类型——流（stream）。流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下，等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。" class="headerlink" title="RxJS是一个解决异步问题的JS开发库.它带来了观察者模式和函数式编程的相结合的最佳实践。 观察者模式是一个被实践证明的模式，基于生产者（事件的创建者）和消费者（事件的监听者）的逻辑分离关系.况且函数式编程方式的引入，如说明性编程，不可变数据结构，链式方法调用会使你极大的简化代码量。RxJS 引入了一个重要的数据类型——流（stream）。流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下，等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。"></a>RxJS是一个解决异步问题的JS开发库.它带来了观察者模式和函数式编程的相结合的最佳实践。 观察者模式是一个被实践证明的模式，基于生产者（事件的创建者）和消费者（事件的监听者）的逻辑分离关系.况且函数式编程方式的引入，如说明性编程，不可变数据结构，链式方法调用会使你极大的简化代码量。RxJS 引入了一个重要的数据类型——流（stream）。流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下，等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。</h4><p><br></p>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><h4 id="流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。"><a href="#流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。" class="headerlink" title="流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。"></a>流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 2;</span><br><span class="line">var b = 4;</span><br><span class="line">var c = a + b;</span><br><span class="line">console.log(c); //-&gt; 6</span><br><span class="line">a = 10;  // reassign a</span><br><span class="line">console.log(c); //-&gt; still 6</span><br></pre></td></tr></table></figure>
<h4 id="事件引发的改变总是从事件源（生产者）-向下传递到所有事件监听方（消费者）。如果变量看做流呢，又是什么结果呢？"><a href="#事件引发的改变总是从事件源（生产者）-向下传递到所有事件监听方（消费者）。如果变量看做流呢，又是什么结果呢？" class="headerlink" title="事件引发的改变总是从事件源（生产者）,向下传递到所有事件监听方（消费者）。如果变量看做流呢，又是什么结果呢？"></a>事件引发的改变总是从事件源（生产者）,向下传递到所有事件监听方（消费者）。如果变量看做流呢，又是什么结果呢？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var A$ = 2;</span><br><span class="line">var B$ = 4;</span><br><span class="line">var C$ = A$ + B$;</span><br><span class="line">console.log(C$); //-&gt; 6</span><br><span class="line">A$ = 10;  </span><br><span class="line">console.log(C$); //-&gt;  16</span><br></pre></td></tr></table></figure>
<h4 id="流的方式重新定义的变量值的动态行为-换句话说，C-是把两个流变量A-和B-进行合并操作。当一个新值被推进了A-，C-立刻响应式的变更为16。"><a href="#流的方式重新定义的变量值的动态行为-换句话说，C-是把两个流变量A-和B-进行合并操作。当一个新值被推进了A-，C-立刻响应式的变更为16。" class="headerlink" title="流的方式重新定义的变量值的动态行为.换句话说，C$是把两个流变量A$和B$进行合并操作。当一个新值被推进了A$，C$立刻响应式的变更为16。"></a>流的方式重新定义的变量值的动态行为.换句话说，C$是把两个流变量A$和B$进行合并操作。当一个新值被推进了A$，C$立刻响应式的变更为16。</h4><h3 id="开始了解RxJS中的几个重要成员"><a href="#开始了解RxJS中的几个重要成员" class="headerlink" title="开始了解RxJS中的几个重要成员"></a>开始了解RxJS中的几个重要成员</h3><ul>
<li>Observable可观察对象：表示一个可调用的未来值或者事件的集合。</li>
<li>Observer观察者：一个回调函数集合,它知道怎样去监听被Observable发送的值</li>
<li>Subscription订阅： 表示一个可观察对象的执行，主要用于取消执行。</li>
<li>Operators操作符： 纯粹的函数，使得以函数编程的方式处理集合比如:map,filter,contact,flatmap。</li>
<li>Subject(主题)：等同于一个事件驱动器，是将一个值或者事件广播到多个观察者的唯一途径。</li>
<li>Schedulers(调度者)： 用来控制并发，当计算发生的时候允许我们协调，比如setTimeout,requestAnimationFrame。<h3 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h3><h4 id="使用RxJS创建一个可观察对象："><a href="#使用RxJS创建一个可观察对象：" class="headerlink" title="使用RxJS创建一个可观察对象："></a>使用RxJS创建一个可观察对象：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var button = document.querySelector(&apos;button&apos;);</span><br><span class="line">Rx.Observable.fromEvent(button, &apos;click&apos;)</span><br><span class="line">.throttleTime(1000)</span><br><span class="line">.scan(count =&gt; count + 1, 0)   </span><br><span class="line">.subscribe(count =&gt; console.log(`Clicked $&#123;count&#125; times`));</span><br></pre></td></tr></table></figure>
<h3 id="observable可观察对象，以惰性的方式推送多值的集合"><a href="#observable可观察对象，以惰性的方式推送多值的集合" class="headerlink" title="observable可观察对象，以惰性的方式推送多值的集合"></a>observable可观察对象，以惰性的方式推送多值的集合</h3><h4 id="下面的例子是一个推送1-2，3-4数值的可观察对象，一旦它被订阅1-2，3-就会被推送，4则会在订阅发生一秒之后被推送，紧接着完成推送"><a href="#下面的例子是一个推送1-2，3-4数值的可观察对象，一旦它被订阅1-2，3-就会被推送，4则会在订阅发生一秒之后被推送，紧接着完成推送" class="headerlink" title="下面的例子是一个推送1,2，3,4数值的可观察对象，一旦它被订阅1,2，3,就会被推送，4则会在订阅发生一秒之后被推送，紧接着完成推送"></a>下面的例子是一个推送1,2，3,4数值的可观察对象，一旦它被订阅1,2，3,就会被推送，4则会在订阅发生一秒之后被推送，紧接着完成推送</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var observable = Rx.Observable.create(observer=&gt;&#123;</span><br><span class="line">    observer.next(1);</span><br><span class="line">    observer.next(2);</span><br><span class="line">    observer.next(3);</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        observer.next(4);</span><br><span class="line">        observer.complete();</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Pull拉取-VS-Push推送"><a href="#Pull拉取-VS-Push推送" class="headerlink" title="Pull拉取 VS Push推送"></a>Pull拉取 VS Push推送</h3><h4 id="拉和推是数据生产者和数据的消费者两种不同的交流协议-方式"><a href="#拉和推是数据生产者和数据的消费者两种不同的交流协议-方式" class="headerlink" title="拉和推是数据生产者和数据的消费者两种不同的交流协议(方式);"></a>拉和推是数据生产者和数据的消费者两种不同的交流协议(方式);</h4><br><h4 id="什么是”Pull拉”？在”拉”体系中，数据的消费者决定何时从数据生产者那里获取数据，而生产者自身并不会意识到什么时候数据将会被发送给消费者。"><a href="#什么是”Pull拉”？在”拉”体系中，数据的消费者决定何时从数据生产者那里获取数据，而生产者自身并不会意识到什么时候数据将会被发送给消费者。" class="headerlink" title="什么是”Pull拉”？在”拉”体系中，数据的消费者决定何时从数据生产者那里获取数据，而生产者自身并不会意识到什么时候数据将会被发送给消费者。"></a>什么是”Pull拉”？在”拉”体系中，数据的消费者决定何时从数据生产者那里获取数据，而生产者自身并不会意识到什么时候数据将会被发送给消费者。</h4><h4 id="每一个JS函数都是一个“拉”体系，函数是数据的生产者，调用函数的代码通过“拉出”一个单一的返回值来消费该数据-return-语句-。"><a href="#每一个JS函数都是一个“拉”体系，函数是数据的生产者，调用函数的代码通过“拉出”一个单一的返回值来消费该数据-return-语句-。" class="headerlink" title="每一个JS函数都是一个“拉”体系，函数是数据的生产者，调用函数的代码通过“拉出”一个单一的返回值来消费该数据(return 语句)。"></a>每一个JS函数都是一个“拉”体系，函数是数据的生产者，调用函数的代码通过“拉出”一个单一的返回值来消费该数据(return 语句)。</h4></li>
</ul>
<h4 id="什么是”Push推”？在推体系中，数据的生产者决定何时发送数据给消费者，消费者不会在接收数据之前意识到它将要接收这个数据。"><a href="#什么是”Push推”？在推体系中，数据的生产者决定何时发送数据给消费者，消费者不会在接收数据之前意识到它将要接收这个数据。" class="headerlink" title="什么是”Push推”？在推体系中，数据的生产者决定何时发送数据给消费者，消费者不会在接收数据之前意识到它将要接收这个数据。"></a>什么是”Push推”？在推体系中，数据的生产者决定何时发送数据给消费者，消费者不会在接收数据之前意识到它将要接收这个数据。</h4><h4 id="Promise-承诺-是当今JS中最常见的Push推体系，一个Promise-数据的生产者-发送一个resolved-value-成功状态的值-来注册一个回调-数据消费者-，但是不同于函数的地方的是：Promise决定着何时数据才被推送至这个回调函数。"><a href="#Promise-承诺-是当今JS中最常见的Push推体系，一个Promise-数据的生产者-发送一个resolved-value-成功状态的值-来注册一个回调-数据消费者-，但是不同于函数的地方的是：Promise决定着何时数据才被推送至这个回调函数。" class="headerlink" title="Promise(承诺))是当今JS中最常见的Push推体系，一个Promise(数据的生产者)发送一个resolved value(成功状态的值)来注册一个回调(数据消费者)，但是不同于函数的地方的是：Promise决定着何时数据才被推送至这个回调函数。"></a>Promise(承诺))是当今JS中最常见的Push推体系，一个Promise(数据的生产者)发送一个resolved value(成功状态的值)来注册一个回调(数据消费者)，但是不同于函数的地方的是：Promise决定着何时数据才被推送至这个回调函数。</h4><h4 id="RxJS引入了Observables-可观察对象-，一个全新的”推体系”。一个可观察对象是一个产生多值的生产者，并”推送给”Observer-观察者-。"><a href="#RxJS引入了Observables-可观察对象-，一个全新的”推体系”。一个可观察对象是一个产生多值的生产者，并”推送给”Observer-观察者-。" class="headerlink" title="RxJS引入了Observables(可观察对象)，一个全新的”推体系”。一个可观察对象是一个产生多值的生产者，并”推送给”Observer(观察者)。"></a>RxJS引入了Observables(可观察对象)，一个全新的”推体系”。一个可观察对象是一个产生多值的生产者，并”推送给”Observer(观察者)。</h4><h3 id="RxJS-VS-Promise—3个最重要的不同点"><a href="#RxJS-VS-Promise—3个最重要的不同点" class="headerlink" title="RxJS VS Promise—3个最重要的不同点"></a>RxJS VS Promise—3个最重要的不同点</h3><!--| 不同点               | RxJS     | Promise  |

| --------------------|:---------:|---------:|

| 动作是否可以取消？    | 是        | 否       |

| 是否可以发射多个值？  | 是        | 否       |

| 各种工具函数？        | 是        | 否       |-->
<table>
<thead>
<tr>
<th>不同点</th>
<th style="text-align:center">Rxjs</th>
<th style="text-align:right">Promise</th>
</tr>
</thead>
<tbody>
<tr>
<td>动作是否可以取消？</td>
<td style="text-align:center">是</td>
<td style="text-align:right">否</td>
</tr>
<tr>
<td>是否可以发射多个值？</td>
<td style="text-align:center">是</td>
<td style="text-align:right">否</td>
</tr>
<tr>
<td>各种工具函数？</td>
<td style="text-align:center">是</td>
<td style="text-align:right">否</td>
</tr>
</tbody>
</table>
<h2 id="Operators操作符"><a href="#Operators操作符" class="headerlink" title="Operators操作符"></a>Operators操作符</h2><h3 id="create-创建一个可观察序列，参数为一个封装数据生成逻辑的函数，该函数的参数为观察者"><a href="#create-创建一个可观察序列，参数为一个封装数据生成逻辑的函数，该函数的参数为观察者" class="headerlink" title="create()  创建一个可观察序列，参数为一个封装数据生成逻辑的函数，该函数的参数为观察者"></a>create()  创建一个可观察序列，参数为一个封装数据生成逻辑的函数，该函数的参数为观察者</h3><h3 id="empty-不需要传递参数，创建一个空序列并立即结束"><a href="#empty-不需要传递参数，创建一个空序列并立即结束" class="headerlink" title="empty()  不需要传递参数，创建一个空序列并立即结束"></a>empty()  不需要传递参数，创建一个空序列并立即结束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.empty()  =  Rx.Observable.create((o)=&gt;&#123;</span><br><span class="line">    o.onCompleted()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="never-不需要传递参数，创建一个空序列，并永远不结束"><a href="#never-不需要传递参数，创建一个空序列，并永远不结束" class="headerlink" title="never() 不需要传递参数，创建一个空序列，并永远不结束"></a>never() 不需要传递参数，创建一个空序列，并永远不结束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.never()  =  Rx.Observable.create((o)=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="throw-创建一个空序列，参数来声明错误并立即抛出错误"><a href="#throw-创建一个空序列，参数来声明错误并立即抛出错误" class="headerlink" title="throw() 创建一个空序列，参数来声明错误并立即抛出错误"></a>throw() 创建一个空序列，参数来声明错误并立即抛出错误</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.throw(&apos;error&apos;)  =  Rx.Observable.create((o)=&gt;&#123;</span><br><span class="line">    0.onError(&apos;error&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="range-创建一个有线长度的整数序列，两个参数，第一个起始值，第二个元素数量"><a href="#range-创建一个有线长度的整数序列，两个参数，第一个起始值，第二个元素数量" class="headerlink" title="range() 创建一个有线长度的整数序列，两个参数，第一个起始值，第二个元素数量"></a>range() 创建一个有线长度的整数序列，两个参数，第一个起始值，第二个元素数量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.range(30,4)  //输出:30,31,32,33</span><br></pre></td></tr></table></figure>
<h3 id="interval-创建一个无限长度的周期性序列"><a href="#interval-创建一个无限长度的周期性序列" class="headerlink" title="interval() 创建一个无限长度的周期性序列"></a>interval() 创建一个无限长度的周期性序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.interval(1000) //输出:0,1,2...</span><br></pre></td></tr></table></figure>
<h3 id="timer-指定一个额外的参数来调节第一值的静默时长，第二个参数可选，若无则仅仅在规定的静默时长后输出一个值，然后结束序列"><a href="#timer-指定一个额外的参数来调节第一值的静默时长，第二个参数可选，若无则仅仅在规定的静默时长后输出一个值，然后结束序列" class="headerlink" title="timer() 指定一个额外的参数来调节第一值的静默时长，第二个参数可选，若无则仅仅在规定的静默时长后输出一个值，然后结束序列"></a>timer() 指定一个额外的参数来调节第一值的静默时长，第二个参数可选，若无则仅仅在规定的静默时长后输出一个值，然后结束序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.timer(0,1000) //输出:0,1,2...</span><br></pre></td></tr></table></figure>
<h3 id="from-可以将已有的数据转化为Observable-参数为iterable数据集对象-常见Array-String"><a href="#from-可以将已有的数据转化为Observable-参数为iterable数据集对象-常见Array-String" class="headerlink" title="from() 可以将已有的数据转化为Observable,参数为iterable数据集对象,常见Array,String"></a>from() 可以将已有的数据转化为Observable,参数为iterable数据集对象,常见Array,String</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.from(iterable)</span><br></pre></td></tr></table></figure>
<h3 id="of-不在同一个数据集中的多个来源的数据，使用of-方法直接构造："><a href="#of-不在同一个数据集中的多个来源的数据，使用of-方法直接构造：" class="headerlink" title="of()  不在同一个数据集中的多个来源的数据，使用of()方法直接构造："></a>of()  不在同一个数据集中的多个来源的数据，使用of()方法直接构造：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.of([1,2,3])    //    [1,2,3]</span><br><span class="line">Rx.Observable.from([1,2,3])  //    1,2,3</span><br></pre></td></tr></table></figure>
<h3 id="just-将任何数据转化为一个单值输出的Observable"><a href="#just-将任何数据转化为一个单值输出的Observable" class="headerlink" title="just()  将任何数据转化为一个单值输出的Observable"></a>just()  将任何数据转化为一个单值输出的Observable</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.just([1,2,3])    //    [1,2,3]</span><br></pre></td></tr></table></figure>
<h3 id="repeat-创建一个重复值序列-par1-值，par2：次数"><a href="#repeat-创建一个重复值序列-par1-值，par2：次数" class="headerlink" title="repeat() 创建一个重复值序列  par1:值，par2：次数"></a>repeat() 创建一个重复值序列  par1:值，par2：次数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.repeat(&apos;a&apos;,2)    //   a a</span><br></pre></td></tr></table></figure>
<h3 id="fromEvent-将事件流转化为Observable"><a href="#fromEvent-将事件流转化为Observable" class="headerlink" title="fromEvent() 将事件流转化为Observable,"></a>fromEvent() 将事件流转化为Observable,</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var el = document.getElementById(&quot;btn&quot;); //DOM对象作为事件源</span><br><span class="line">Rx.Observable.fromEvent(el,&quot;click&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="toArray-将序列还原为数组对象-只有在订阅后才还原为数组"><a href="#toArray-将序列还原为数组对象-只有在订阅后才还原为数组" class="headerlink" title="toArray() 将序列还原为数组对象,只有在订阅后才还原为数组"></a>toArray() 将序列还原为数组对象,只有在订阅后才还原为数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,3,4);    //序列：1 2 3 4 </span><br><span class="line">var target = source.toArray();     //序列：[1,2,3,4]</span><br><span class="line">target.subscribe(function(d)&#123;</span><br><span class="line">    console.log(d);             //d： [1,2,3,4]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="delay-推迟-参数为数字或Date对象"><a href="#delay-推迟-参数为数字或Date对象" class="headerlink" title="delay() 推迟   参数为数字或Date对象"></a>delay() 推迟   参数为数字或Date对象</h3><h3 id="delaySubscription-延迟订阅-参数同理"><a href="#delaySubscription-延迟订阅-参数同理" class="headerlink" title="delaySubscription() 延迟订阅  参数同理"></a>delaySubscription() 延迟订阅  参数同理</h3><h3 id="startWith-可以在源序列之前添加额外的元素"><a href="#startWith-可以在源序列之前添加额外的元素" class="headerlink" title="startWith() 可以在源序列之前添加额外的元素"></a>startWith() 可以在源序列之前添加额外的元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,3); //序列：1 2 3</span><br><span class="line">var target = source.startWith(7,8,9); //序列：7 8 9 1 2 3</span><br></pre></td></tr></table></figure>
<h3 id="map-对源序列进行变换，并返回新的序列-改变了源"><a href="#map-对源序列进行变换，并返回新的序列-改变了源" class="headerlink" title="map() 对源序列进行变换，并返回新的序列(改变了源)"></a>map() 对源序列进行变换，并返回新的序列(改变了源)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var trandform = function(item)&#123;</span><br><span class="line">    return item*2;</span><br><span class="line">&#125;</span><br><span class="line">var source = Rx.Observable.of(1,2,3); //输出： 1 2 3</span><br><span class="line">var target = source.map(trandform);   //输出： 2 4 6</span><br></pre></td></tr></table></figure>
<h1 id="concat-有序拼接-merge-无序"><a href="#concat-有序拼接-merge-无序" class="headerlink" title="concat() 有序拼接   merge()无序"></a>concat() 有序拼接   merge()无序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,3); //序列：1 2 3</span><br><span class="line">var target = source.concat(</span><br><span class="line">    Rx.Observable.of(4,5,6),</span><br><span class="line">    Rx.Observable.of(7,8,9)</span><br><span class="line">); //序列：1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>
<h3 id="concatAll-如果源序列的元素也是序列-——-序列的序列，那么可以使用concatAll-方法将各元素序列按顺序拼接起来"><a href="#concatAll-如果源序列的元素也是序列-——-序列的序列，那么可以使用concatAll-方法将各元素序列按顺序拼接起来" class="headerlink" title="concatAll()  如果源序列的元素也是序列 —— 序列的序列，那么可以使用concatAll() 方法将各元素序列按顺序拼接起来"></a>concatAll()  如果源序列的元素也是序列 —— 序列的序列，那么可以使用concatAll() 方法将各元素序列按顺序拼接起来</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(10,20,30)</span><br><span class="line">    .map(function(item)&#123;</span><br><span class="line">        return Rx.Observable.range(item,3);</span><br><span class="line">    &#125;); //序列： Observable&#123;10,11,12&#125; Observable&#123;20,21,22&#125; Observable&#123;30,31,32&#125;</span><br><span class="line">var target = source.concatAll(); //序列：10 10 12 20 21 22 30 31 32</span><br></pre></td></tr></table></figure>
<h3 id="catch-捕捉源序列错误，返回新序列"><a href="#catch-捕捉源序列错误，返回新序列" class="headerlink" title="catch()  捕捉源序列错误，返回新序列"></a>catch()  捕捉源序列错误，返回新序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.create(function(o)&#123;</span><br><span class="line">    o.onNext(1);</span><br><span class="line">    o.onNext(2);</span><br><span class="line">    o.onError(new Error(&quot;fake error&quot;));</span><br><span class="line">    o.onNext(4);</span><br><span class="line">&#125;); //序列： 1 2 &lt;ERROR&gt; 4</span><br><span class="line">var target = source.catch(Rx.Observable.from(&quot;abc&quot;)); //序列： 1 2 a b c</span><br></pre></td></tr></table></figure>
<h3 id="pluck-针对元素为json对象的源序列，返回指定属性的值的序列"><a href="#pluck-针对元素为json对象的源序列，返回指定属性的值的序列" class="headerlink" title="pluck()  针对元素为json对象的源序列，返回指定属性的值的序列"></a>pluck()  针对元素为json对象的源序列，返回指定属性的值的序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(&#123;name:&apos;john&apos;,age:33&#125;,&#123;name:&apos;lee&apos;,age:22&#125;);</span><br><span class="line">var target = source.pluck(&apos;name&apos;);  //序列 john lee</span><br></pre></td></tr></table></figure>
<h3 id="flatMap-平坦化映射-首先将一个序列的各元素映射为序列，然后将各序列融合-参数是一个映射函数，返回值为序列"><a href="#flatMap-平坦化映射-首先将一个序列的各元素映射为序列，然后将各序列融合-参数是一个映射函数，返回值为序列" class="headerlink" title="flatMap()  平坦化映射:首先将一个序列的各元素映射为序列，然后将各序列融合  参数是一个映射函数，返回值为序列"></a>flatMap()  平坦化映射:首先将一个序列的各元素映射为序列，然后将各序列融合  参数是一个映射函数，返回值为序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(10,20);</span><br><span class="line">var mf = function(item)&#123;</span><br><span class="line">    return Rx.Observable.range(item,3)</span><br><span class="line">&#125;</span><br><span class="line">var target = source.flatMap(mf)  // 序列：10,11,20,12,21,22</span><br></pre></td></tr></table></figure>
<h3 id="flatMapLatest-与flatMap-的区别在于将最新的序列中的元素输出"><a href="#flatMapLatest-与flatMap-的区别在于将最新的序列中的元素输出" class="headerlink" title="flatMapLatest()  与flatMap()的区别在于将最新的序列中的元素输出"></a>flatMapLatest()  与flatMap()的区别在于将最新的序列中的元素输出</h3><h3 id="concatMap-将源序列各元素映射为序列，然后按顺序拼接-与flatMap的区别所在"><a href="#concatMap-将源序列各元素映射为序列，然后按顺序拼接-与flatMap的区别所在" class="headerlink" title="concatMap()  将源序列各元素映射为序列，然后按顺序拼接 (与flatMap的区别所在)"></a>concatMap()  将源序列各元素映射为序列，然后按顺序拼接 (与flatMap的区别所在)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,3);</span><br><span class="line">var mf = function(item)&#123;</span><br><span class="line">    return Rx.Observable.range(item,3);</span><br><span class="line">&#125;</span><br><span class="line">var target = source.concatMap(mf)  //序列：1,2,3,2,3,4,3,4,5</span><br></pre></td></tr></table></figure>
<h2 id="flatMap与map异同点"><a href="#flatMap与map异同点" class="headerlink" title="flatMap与map异同点"></a>flatMap与map异同点</h2><h3 id="Map用于对自身对象数值进行映射，将发射对象转换成另一个发射对象发射，返回一个包含映射结果的Observable对象。而flatMap是把自身对象里的数值进行映射并转换成一个新的Observable对象-当从其他类型对象中构建Observable对象时，需要使用flatMap方法"><a href="#Map用于对自身对象数值进行映射，将发射对象转换成另一个发射对象发射，返回一个包含映射结果的Observable对象。而flatMap是把自身对象里的数值进行映射并转换成一个新的Observable对象-当从其他类型对象中构建Observable对象时，需要使用flatMap方法" class="headerlink" title="Map用于对自身对象数值进行映射，将发射对象转换成另一个发射对象发射，返回一个包含映射结果的Observable对象。而flatMap是把自身对象里的数值进行映射并转换成一个新的Observable对象.当从其他类型对象中构建Observable对象时，需要使用flatMap方法"></a>Map用于对自身对象数值进行映射，将发射对象转换成另一个发射对象发射，返回一个包含映射结果的Observable对象。而flatMap是把自身对象里的数值进行映射并转换成一个新的Observable对象.当从其他类型对象中构建Observable对象时，需要使用flatMap方法</h3><h2 id="flatMap与concatMap异同点"><a href="#flatMap与concatMap异同点" class="headerlink" title="flatMap与concatMap异同点"></a>flatMap与concatMap异同点</h2><h3 id="merge和map结合与concat和map结合的区别，归根结底为merge与concat的区别，一个无序一个有序"><a href="#merge和map结合与concat和map结合的区别，归根结底为merge与concat的区别，一个无序一个有序" class="headerlink" title="merge和map结合与concat和map结合的区别，归根结底为merge与concat的区别，一个无序一个有序"></a>merge和map结合与concat和map结合的区别，归根结底为merge与concat的区别，一个无序一个有序</h3><h3 id="filter-筛选源序列中满足条件的元素，并返回新的序列"><a href="#filter-筛选源序列中满足条件的元素，并返回新的序列" class="headerlink" title="filter() 筛选源序列中满足条件的元素，并返回新的序列"></a>filter() 筛选源序列中满足条件的元素，并返回新的序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,3,4,5); //序列： 1 2 3 4 5</span><br><span class="line">var target = source.filter(x =&gt; x&lt;4)  //序列： 1 2 3</span><br></pre></td></tr></table></figure>
<h3 id="skip-num-抑制序列头部元素数量输出-skipLast-num-尾部-skipWhile-if-指定一个条件"><a href="#skip-num-抑制序列头部元素数量输出-skipLast-num-尾部-skipWhile-if-指定一个条件" class="headerlink" title="skip(num) 抑制序列头部元素数量输出   skipLast(num)尾部   skipWhile(if)指定一个条件"></a>skip(num) 抑制序列头部元素数量输出   skipLast(num)尾部   skipWhile(if)指定一个条件</h3><h3 id="take-num-截取序列头部元素数量输出-takeLast-num-尾部-takeWhile-if-指定一个条件"><a href="#take-num-截取序列头部元素数量输出-takeLast-num-尾部-takeWhile-if-指定一个条件" class="headerlink" title="take(num) 截取序列头部元素数量输出   takeLast(num)尾部   takeWhile(if)指定一个条件"></a>take(num) 截取序列头部元素数量输出   takeLast(num)尾部   takeWhile(if)指定一个条件</h3><h3 id="distinct-去重-并返回一个新序列"><a href="#distinct-去重-并返回一个新序列" class="headerlink" title="distinct 去重,并返回一个新序列"></a>distinct 去重,并返回一个新序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,3,4,2,1); //序列： 1 2 3 4 2 1</span><br><span class="line">var target = source.distinct(); //序列：1 2 3 4</span><br></pre></td></tr></table></figure>
<h3 id="distinctUntilChanged-去重-并返回一个新序列"><a href="#distinctUntilChanged-去重-并返回一个新序列" class="headerlink" title="distinctUntilChanged 去重,并返回一个新序列"></a>distinctUntilChanged 去重,并返回一个新序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,2,3,4,2,1); //序列： 1 2 3 4 2 1</span><br><span class="line">var target = source.distinctUntilChanged(); //序列：1 2 3 4 2 1</span><br></pre></td></tr></table></figure>
<h3 id="debounce-去抖动-一段时间内只取最新数据作为一次发射数据，其他数据取消发射"><a href="#debounce-去抖动-一段时间内只取最新数据作为一次发射数据，其他数据取消发射" class="headerlink" title="debounce  去抖动,一段时间内只取最新数据作为一次发射数据，其他数据取消发射"></a>debounce  去抖动,一段时间内只取最新数据作为一次发射数据，其他数据取消发射</h3><h3 id="throttle-和debounce唯一区别是debounce取一段时间内最新的，而throttle忽略这段时间后，发现新值才发送-通俗讲，都设定一个时间周期，持续触发事件，throttle为每到时间周期便会触发一次，bebounce为触发周期小于设定时间周期不予事件触发）"><a href="#throttle-和debounce唯一区别是debounce取一段时间内最新的，而throttle忽略这段时间后，发现新值才发送-通俗讲，都设定一个时间周期，持续触发事件，throttle为每到时间周期便会触发一次，bebounce为触发周期小于设定时间周期不予事件触发）" class="headerlink" title="throttle(和debounce唯一区别是debounce取一段时间内最新的，而throttle忽略这段时间后，发现新值才发送, 通俗讲，都设定一个时间周期，持续触发事件，throttle为每到时间周期便会触发一次，bebounce为触发周期小于设定时间周期不予事件触发）"></a>throttle(和debounce唯一区别是debounce取一段时间内最新的，而throttle忽略这段时间后，发现新值才发送, 通俗讲，都设定一个时间周期，持续触发事件，throttle为每到时间周期便会触发一次，bebounce为触发周期小于设定时间周期不予事件触发）</h3><h3 id="buffer-使用第二个序列触发源序列中多个元素的打包"><a href="#buffer-使用第二个序列触发源序列中多个元素的打包" class="headerlink" title="buffer() 使用第二个序列触发源序列中多个元素的打包"></a>buffer() 使用第二个序列触发源序列中多个元素的打包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.timer(0,1000);    //序列：0 1 2 3 ...</span><br><span class="line">var boundaries = Rx.Observable.timer(2500); //延时2500ms触发</span><br><span class="line">var target = source.buffer(boundaries); //序列： [0,1,2]</span><br></pre></td></tr></table></figure>
<h3 id="bufferWithTime-按固定时间间隔对源序列进行打包"><a href="#bufferWithTime-按固定时间间隔对源序列进行打包" class="headerlink" title="bufferWithTime() 按固定时间间隔对源序列进行打包"></a>bufferWithTime() 按固定时间间隔对源序列进行打包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.timer(0,1000); //序列：0 1 2 3 ...</span><br><span class="line">var target = source.bufferWithTime(2500); //序列：[0,1,2] [3,4] ...</span><br></pre></td></tr></table></figure>
<h3 id="zip-支持可变数量的序列作为参数，最后一个参数应当是一个组合函数，-其返回值将作为目标序列的元素"><a href="#zip-支持可变数量的序列作为参数，最后一个参数应当是一个组合函数，-其返回值将作为目标序列的元素" class="headerlink" title="zip()  支持可变数量的序列作为参数，最后一个参数应当是一个组合函数， 其返回值将作为目标序列的元素"></a>zip()  支持可变数量的序列作为参数，最后一个参数应当是一个组合函数， 其返回值将作为目标序列的元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var source1 = Rx.Observable.of(1,2,3); //序列： 1 2 3</span><br><span class="line">var source2 = Rx.Observable.of(4,5,6); //序列：4 5 6</span><br><span class="line">var cf = function(d1,d2)&#123; return d1 + &apos;-&apos; + d2;&#125;;</span><br><span class="line">var target = Rx.Observable.zip(source1,source2,cf); //序列： 1-4 2-5 3-6</span><br></pre></td></tr></table></figure>
<h3 id="forkJoin-将多个序列的最后一个元素组合为一个数组后，作为目标序列的唯一元素"><a href="#forkJoin-将多个序列的最后一个元素组合为一个数组后，作为目标序列的唯一元素" class="headerlink" title="forkJoin()  将多个序列的最后一个元素组合为一个数组后，作为目标序列的唯一元素"></a>forkJoin()  将多个序列的最后一个元素组合为一个数组后，作为目标序列的唯一元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var source1 = Rx.Observable.of(1,2,3); //序列： 1 2 3</span><br><span class="line">var source2 = Rx.Observable.of(4,5,6); //序列： 4 5 6</span><br><span class="line">var target = Rz.Observable.forkJoin(source1,source2); //序列：[3,6]</span><br></pre></td></tr></table></figure>
<h3 id="combineLatest-将多个序列的最后一个元素，使用组合函数构成目标序列的一个新元素"><a href="#combineLatest-将多个序列的最后一个元素，使用组合函数构成目标序列的一个新元素" class="headerlink" title="combineLatest() 将多个序列的最后一个元素，使用组合函数构成目标序列的一个新元素"></a>combineLatest() 将多个序列的最后一个元素，使用组合函数构成目标序列的一个新元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var source1 = Rx.Observable.interval(200).map(x =&gt; &apos;First:&apos; + x)</span><br><span class="line">var source2 = Rx.Observable.interval(100).map(x =&gt; &apos;Second:&apos; + x)</span><br><span class="line">var source = Rx.Observable.combineLatest(</span><br><span class="line">    source1,</span><br><span class="line">    source2</span><br><span class="line">).take(4);   // [&quot;First:0&quot;, &quot;Second:0&quot;]  [&quot;First:0&quot;, &quot;Second:1&quot;]  [&quot;First:0&quot;, &quot;Second:2&quot;]   [&quot;First:1&quot;, &quot;Second:2&quot;]</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vernvn.github.io/2016/11/21/ng1%E4%B8%8Eng2%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E6%AF%94%E8%BE%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/17755520?s=400&u=9f444bfe70cd719b9bf43ed5fedac2f1d005ff5a&v=4">
      <meta itemprop="name" content="Lee_Ran">
      <meta itemprop="description" content="保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力混迹江湖的前端小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/11/21/ng1%E4%B8%8Eng2%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E6%AF%94%E8%BE%83/" class="post-title-link" itemprop="url">依赖注入</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-11-21 09:35:40" itemprop="dateCreated datePublished" datetime="2016-11-21T09:35:40+08:00">2016-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-02-08 10:09:02" itemprop="dateModified" datetime="2018-02-08T10:09:02+08:00">2018-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="依赖注入是一种软件设计模式，他允许你移除软件组件的硬编码方式，替代的是通过依赖注入制造低耦合的组件不论在编译阶段还是在运行阶段。硬编码就是在程序中将代码写死，低耦合就是尽量让每个模块独立，相关的处理尽量在单个模块中完成。"><a href="#依赖注入是一种软件设计模式，他允许你移除软件组件的硬编码方式，替代的是通过依赖注入制造低耦合的组件不论在编译阶段还是在运行阶段。硬编码就是在程序中将代码写死，低耦合就是尽量让每个模块独立，相关的处理尽量在单个模块中完成。" class="headerlink" title="依赖注入是一种软件设计模式，他允许你移除软件组件的硬编码方式，替代的是通过依赖注入制造低耦合的组件不论在编译阶段还是在运行阶段。硬编码就是在程序中将代码写死，低耦合就是尽量让每个模块独立，相关的处理尽量在单个模块中完成。"></a>依赖注入是一种软件设计模式，他允许你移除软件组件的硬编码方式，替代的是通过依赖注入制造低耦合的组件不论在编译阶段还是在运行阶段。硬编码就是在程序中将代码写死，低耦合就是尽量让每个模块独立，相关的处理尽量在单个模块中完成。</h3><p><br></p>
<h3 id="AngularJs有一个内在的注入机制，他可以把你的App分成许多个可重复使用的组件，当需要的时候通过依赖注入把这些自减注入进你的App中去。在需要的地方进行参数传递，这种方法不仅对测试很有用，而且还不会污染全局变量，是很好的设计模式。"><a href="#AngularJs有一个内在的注入机制，他可以把你的App分成许多个可重复使用的组件，当需要的时候通过依赖注入把这些自减注入进你的App中去。在需要的地方进行参数传递，这种方法不仅对测试很有用，而且还不会污染全局变量，是很好的设计模式。" class="headerlink" title="AngularJs有一个内在的注入机制，他可以把你的App分成许多个可重复使用的组件，当需要的时候通过依赖注入把这些自减注入进你的App中去。在需要的地方进行参数传递，这种方法不仅对测试很有用，而且还不会污染全局变量，是很好的设计模式。"></a>AngularJs有一个内在的注入机制，他可以把你的App分成许多个可重复使用的组件，当需要的时候通过依赖注入把这些自减注入进你的App中去。在需要的地方进行参数传递，这种方法不仅对测试很有用，而且还不会污染全局变量，是很好的设计模式。</h3><p><br></p>
<h2 id="AngularJS依赖注入的方法"><a href="#AngularJS依赖注入的方法" class="headerlink" title="AngularJS依赖注入的方法"></a>AngularJS依赖注入的方法</h2><ol>
<li>通过函数的参数进行推断式注入声明<h3 id="如果没有明确的声明，AngularJS会假定名称就是依赖的名称。因此，它会在内部调用函数对象的toString-方法，分析并提取函数的参数列表，然后通过-injector将这些参数再注入进对象实例。下面是代码示例："><a href="#如果没有明确的声明，AngularJS会假定名称就是依赖的名称。因此，它会在内部调用函数对象的toString-方法，分析并提取函数的参数列表，然后通过-injector将这些参数再注入进对象实例。下面是代码示例：" class="headerlink" title="如果没有明确的声明，AngularJS会假定名称就是依赖的名称。因此，它会在内部调用函数对象的toString()方法，分析并提取函数的参数列表，然后通过$injector将这些参数再注入进对象实例。下面是代码示例："></a>如果没有明确的声明，AngularJS会假定名称就是依赖的名称。因此，它会在内部调用函数对象的toString()方法，分析并提取函数的参数列表，然后通过$injector将这些参数再注入进对象实例。下面是代码示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function myController($scope,$timeout)&#123;</span><br><span class="line">	var updateTime = function()&#123;</span><br><span class="line">		$scope.clock = &#123;</span><br><span class="line">			time: new Date()</span><br><span class="line">		&#125;;</span><br><span class="line">		$timeout(function()&#123;</span><br><span class="line">			$scope.clock.time = new Date();</span><br><span class="line">			updateTime();</span><br><span class="line">		&#125;,1000)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ng-controller=&apos;myController&apos;&gt;</span><br><span class="line">	&lt;span&gt;&#123;&#123;clock.time | data:&apos;yyyy-MM-dd hh:mm:ss&apos;&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="创建了一个可以自动更新时间的应用，看看是如何进行依赖注入的。通过设置参数-scope和-timeout，angular会在内部调用函数的toString-方法，分析并提取函数的参数列表，然后通过-injector将这些参数注入到对象的实例。"><a href="#创建了一个可以自动更新时间的应用，看看是如何进行依赖注入的。通过设置参数-scope和-timeout，angular会在内部调用函数的toString-方法，分析并提取函数的参数列表，然后通过-injector将这些参数注入到对象的实例。" class="headerlink" title="创建了一个可以自动更新时间的应用，看看是如何进行依赖注入的。通过设置参数$scope和$timeout，angular会在内部调用函数的toString()方法，分析并提取函数的参数列表，然后通过$injector将这些参数注入到对象的实例。"></a>创建了一个可以自动更新时间的应用，看看是如何进行依赖注入的。通过设置参数$scope和$timeout，angular会在内部调用函数的toString()方法，分析并提取函数的参数列表，然后通过$injector将这些参数注入到对象的实例。</h3><br><br><font color="#f00" size=5 face='黑体'>注意：</font><br><br></li>
</ol>
<ul>
<li>此方法只适合未经压缩混淆的代码，因为angular需要解析未经压缩混淆的参数列表。<br><br></li>
</ul>
<ol start="2">
<li>显式的注入声明<h3 id="显式的明确定义一个函数在被调用时需要用到的依赖关系，通过这种方法声明依赖，即使在源代码被压缩，参数名称发生改变的情况下依然可以工作。代码示例："><a href="#显式的明确定义一个函数在被调用时需要用到的依赖关系，通过这种方法声明依赖，即使在源代码被压缩，参数名称发生改变的情况下依然可以工作。代码示例：" class="headerlink" title="显式的明确定义一个函数在被调用时需要用到的依赖关系，通过这种方法声明依赖，即使在源代码被压缩，参数名称发生改变的情况下依然可以工作。代码示例："></a>显式的明确定义一个函数在被调用时需要用到的依赖关系，通过这种方法声明依赖，即使在源代码被压缩，参数名称发生改变的情况下依然可以工作。代码示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var mycontrollerFactory = function mycontroller($scope,$timeout)&#123;</span><br><span class="line">	var updateTime = function () &#123;</span><br><span class="line">        $scope.clock = &#123;</span><br><span class="line">            time: new Date()</span><br><span class="line">        &#125;;</span><br><span class="line">        $timeout(function () &#123;</span><br><span class="line">            $scope.clock.time = new Date();</span><br><span class="line">            updateTime();</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">    &#125;</span><br><span class="line">    updateTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mycontrollerFactory.$inject = [&apos;$scope&apos;,&apos;$timeout&apos;];</span><br></pre></td></tr></table></figure>
<h3 id="显式的将我们需要的依赖注入到函数中，所以在函数中参数也可以分别换成其他字段。"><a href="#显式的将我们需要的依赖注入到函数中，所以在函数中参数也可以分别换成其他字段。" class="headerlink" title="显式的将我们需要的依赖注入到函数中，所以在函数中参数也可以分别换成其他字段。"></a>显式的将我们需要的依赖注入到函数中，所以在函数中参数也可以分别换成其他字段。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var mycontrollerFactory = function mycontroller(s,t)&#123;.....&#125;</span><br></pre></td></tr></table></figure>
<font color="#f00" size=5 face='黑体'>注意：</font><br><br></li>
</ol>
<ul>
<li>对于这种声明方式，参数的顺序是十分重要的，因为$inject数组元素的顺序必须和注入的参数顺序一一对应。<br><br></li>
</ul>
<ol start="3">
<li>行内注入声明<h3 id="angular提供的行内注入方法实际上是一种语法糖，它与前面的提到的通过-inject属性进行声明的原理是一样的，但是允许我们在函数定义的时候从行内将参数传入，这种方法方便简洁，而且避免了在定义的过程中使用临时变量。"><a href="#angular提供的行内注入方法实际上是一种语法糖，它与前面的提到的通过-inject属性进行声明的原理是一样的，但是允许我们在函数定义的时候从行内将参数传入，这种方法方便简洁，而且避免了在定义的过程中使用临时变量。" class="headerlink" title="angular提供的行内注入方法实际上是一种语法糖，它与前面的提到的通过$inject属性进行声明的原理是一样的，但是允许我们在函数定义的时候从行内将参数传入，这种方法方便简洁，而且避免了在定义的过程中使用临时变量。"></a>angular提供的行内注入方法实际上是一种语法糖，它与前面的提到的通过$inject属性进行声明的原理是一样的，但是允许我们在函数定义的时候从行内将参数传入，这种方法方便简洁，而且避免了在定义的过程中使用临时变量。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">angular.module(&apos;app&apos;,[])</span><br><span class="line">.controller(&apos;mycontroller&apos;,[&apos;$scope&apos;,&apos;$timeout&apos;,function($scope,$timeout)&#123;</span><br><span class="line">	var updateTime = function () &#123;</span><br><span class="line">        $scope.clock = &#123;</span><br><span class="line">            time: new Date()</span><br><span class="line">        &#125;;</span><br><span class="line">        $timeout(function () &#123;</span><br><span class="line">            $scope.clock.time = new Date();</span><br><span class="line">            updateTime();</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">    &#125;</span><br><span class="line">    updateTime();</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure>
<font color="#f00" size=5 face='黑体'>注意：</font><br><br></li>
</ol>
<ul>
<li>行内声明的方式允许我们直接传入一个参数数组，而不是一个函数，数组的元素是字符串，他们代表的是可以被注入到对象中的依赖名字，最后一个参数就是依赖注入的目标函数对象本身。</li>
</ul>
<h2 id="下面来对比一下ng1与ng2的依赖注入的区别，以login组件为例"><a href="#下面来对比一下ng1与ng2的依赖注入的区别，以login组件为例" class="headerlink" title="下面来对比一下ng1与ng2的依赖注入的区别，以login组件为例"></a>下面来对比一下ng1与ng2的依赖注入的区别，以login组件为例</h2><h2 id="先来看一下angular2的架构图"><a href="#先来看一下angular2的架构图" class="headerlink" title="先来看一下angular2的架构图"></a>先来看一下angular2的架构图</h2><p><img src="http://upload-images.jianshu.io/upload_images/949077-ce2193b397ce7ee8.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="providerToservice"><br><br><br><em>Angular1</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Login&#123;</span><br><span class="line">    formValue : &#123;login:string,password:string&#125; = &#123;login:&apos;&apos;,password:&apos;&apos;&#125;;</span><br><span class="line">    onSubmit()&#123;</span><br><span class="line">        const service = new LoginService();</span><br><span class="line">        service.login(this.formValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.component(&apos;login&apos;,&#123;</span><br><span class="line">    controller: Login,</span><br><span class="line">    controllerAs ; &apos;ctrl&apos;,</span><br><span class="line">    template:`</span><br><span class="line">        &lt;form ng-submit = &quot;ctrl.onSubmit()&quot;&gt;</span><br><span class="line">        Text &lt;input type=&quot;text&quot; ng-model=&quot;ctrl.formValue.login&gt;</span><br><span class="line">        password  &lt;input type=&quot;password&quot; ng-model=&quot;ctrl.formValue.password&quot;&gt;</span><br><span class="line">        &lt;button&gt;submit&lt;/button&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br><em>Angular2</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector:&apos;login&apos;,</span><br><span class="line">    template:`</span><br><span class="line">        .....</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br><span class="line">class Login&#123;</span><br><span class="line">    onSubmit(formValue:&#123;login:string,password:string&#125;)&#123;</span><br><span class="line">        const service = new LoginService();</span><br><span class="line">        service.login(formValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="在这里直接把login组件绑定在login-service上的，很难进行独立测试，也降低了它复用的可能性"><a href="#在这里直接把login组件绑定在login-service上的，很难进行独立测试，也降低了它复用的可能性" class="headerlink" title="在这里直接把login组件绑定在login service上的，很难进行独立测试，也降低了它复用的可能性"></a>在这里直接把login组件绑定在login service上的，很难进行独立测试，也降低了它复用的可能性</h3><p><br></p>
<h2 id="with-DI"><a href="#with-DI" class="headerlink" title="with DI"></a>with DI</h2><h3 id="在构造函数里面注射一个LoginService的实例，而不是直接创建"><a href="#在构造函数里面注射一个LoginService的实例，而不是直接创建" class="headerlink" title="在构造函数里面注射一个LoginService的实例，而不是直接创建"></a>在构造函数里面注射一个LoginService的实例，而不是直接创建</h3><p><em>Angular1</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Login&#123;</span><br><span class="line">    formValue : &#123;login:string,password:string&#125; = &#123;login:&apos;&apos;,password:&apos;&apos;&#125;;</span><br><span class="line">    constructor(public service:LoginService)&#123;&#125;</span><br><span class="line">    onSubmit()&#123;</span><br><span class="line">        this.service.login(this.formValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="我们还需要告诉框架应该创建这个service的实例"><a href="#我们还需要告诉框架应该创建这个service的实例" class="headerlink" title="我们还需要告诉框架应该创建这个service的实例"></a>我们还需要告诉框架应该创建这个service的实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.service(&apos;login&apos;,LoginService);</span><br></pre></td></tr></table></figure>
<p><br><br><em>Angular2</em></p>
<h3 id="同样，在构造函数里面注射一个LoginSerivce的实例"><a href="#同样，在构造函数里面注射一个LoginSerivce的实例" class="headerlink" title="同样，在构造函数里面注射一个LoginSerivce的实例"></a>同样，在构造函数里面注射一个LoginSerivce的实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Login&#123;</span><br><span class="line">    constructor(public service: LoginService)&#123;&#125;</span><br><span class="line">    onSubmit(formValue:&#123;login:string,password:string&#125;)&#123;</span><br><span class="line">        this.service.login(formValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不同于ng1，我们需要将这个service添加到providers列表里面来实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@NgModule(&#123;</span><br><span class="line">    bootstrap:[Login],</span><br><span class="line">    providers:[LoginService],</span><br><span class="line">    declarations:[Login]</span><br><span class="line">&#125;)</span><br><span class="line">class AppModule&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如果注入到它的根模块，则整个应用都可以调用，也可以注入到使用它的组件元数据里面-只需在装饰器加上一个providers配置项-这样注入的服务只对自己和后代可用"><a href="#如果注入到它的根模块，则整个应用都可以调用，也可以注入到使用它的组件元数据里面-只需在装饰器加上一个providers配置项-这样注入的服务只对自己和后代可用" class="headerlink" title="如果注入到它的根模块，则整个应用都可以调用，也可以注入到使用它的组件元数据里面,只需在装饰器加上一个providers配置项,这样注入的服务只对自己和后代可用"></a>如果注入到它的根模块，则整个应用都可以调用，也可以注入到使用它的组件元数据里面,只需在装饰器加上一个providers配置项,这样注入的服务只对自己和后代可用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector:&apos;lr&apos;,</span><br><span class="line">    providers:[LoginService]</span><br><span class="line">&#125;)</span><br><span class="line">class APPLr&#123;&#125;</span><br></pre></td></tr></table></figure>
<font color="#f00" size=5 face='黑体'>注意：</font></li>
<li>ng1依赖于字符串来配置DI，而ng2则默认使用注解的方式<h3 id="ng1里面有好几个Api可以用来给指令注入依赖，有些是根据名称注入的（LoginService）-有些依赖会一直自动提供（link函数里面的），有些需要使用require进行配置"><a href="#ng1里面有好几个Api可以用来给指令注入依赖，有些是根据名称注入的（LoginService）-有些依赖会一直自动提供（link函数里面的），有些需要使用require进行配置" class="headerlink" title="ng1里面有好几个Api可以用来给指令注入依赖，有些是根据名称注入的（LoginService）,有些依赖会一直自动提供（link函数里面的），有些需要使用require进行配置"></a>ng1里面有好几个Api可以用来给指令注入依赖，有些是根据名称注入的（LoginService）,有些依赖会一直自动提供（link函数里面的），有些需要使用require进行配置</h3><br><h3 id="ng2提供了统一的Api用来注入服务，指令等，所有这些内容都会被注入到组件的构造函数里面"><a href="#ng2提供了统一的Api用来注入服务，指令等，所有这些内容都会被注入到组件的构造函数里面" class="headerlink" title="ng2提供了统一的Api用来注入服务，指令等，所有这些内容都会被注入到组件的构造函数里面"></a>ng2提供了统一的Api用来注入服务，指令等，所有这些内容都会被注入到组件的构造函数里面</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li>
<li>DI是ng的核心机制之一</li>
<li>他可以使你的代码更加松耦合</li>
<li>提升了可测试性</li>
<li>ng2采用了统一的Api来给组件注入依赖</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vernvn.github.io/2016/11/18/%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4%EF%BC%8C%E6%9C%8D%E5%8A%A1%EF%BC%8C%E6%8E%A7%E5%88%B6%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/17755520?s=400&u=9f444bfe70cd719b9bf43ed5fedac2f1d005ff5a&v=4">
      <meta itemprop="name" content="Lee_Ran">
      <meta itemprop="description" content="保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力混迹江湖的前端小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/11/18/%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4%EF%BC%8C%E6%9C%8D%E5%8A%A1%EF%BC%8C%E6%8E%A7%E5%88%B6%E5%99%A8/" class="post-title-link" itemprop="url">何时使用指令，服务，控制器</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-11-18 15:13:33" itemprop="dateCreated datePublished" datetime="2016-11-18T15:13:33+08:00">2016-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-02-08 10:09:02" itemprop="dateModified" datetime="2018-02-08T10:09:02+08:00">2018-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>Directive(指令)</li>
<li>Controller(控制器)</li>
<li>Service(服务)<br>以上为angular1的核心概念，我们究竟什么以什么样的方式去使用它们。<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h3 id="Service是单例对象，会经常被传来传去，但是可以保证每次访问的都是同一个实例。所以很多Controler和Directive可以访问它内部的数值，所以它是一个存放数据，实现数据共享的好地方"><a href="#Service是单例对象，会经常被传来传去，但是可以保证每次访问的都是同一个实例。所以很多Controler和Directive可以访问它内部的数值，所以它是一个存放数据，实现数据共享的好地方" class="headerlink" title="Service是单例对象，会经常被传来传去，但是可以保证每次访问的都是同一个实例。所以很多Controler和Directive可以访问它内部的数值，所以它是一个存放数据，实现数据共享的好地方;"></a>Service是单例对象，会经常被传来传去，但是可以保证每次访问的都是同一个实例。所以很多Controler和Directive可以访问它内部的数值，所以它是一个存放数据，实现数据共享的好地方;</h3><br><h3 id="首先创建一个module"><a href="#首先创建一个module" class="headerlink" title="首先创建一个module,"></a>首先创建一个module,</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var module = angular.module(&apos;myModule,[]&apos;);</span><br></pre></td></tr></table></figure>
<br><br>下一步，创建一个服务，用来管理图书的BookService;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module.factory(&apos;BookService&apos;,[&apos;rootScope&apos;,function($rootScope)&#123;</span><br><span class="line">	var service = &#123;</span><br><span class="line">		books:[</span><br><span class="line">			&#123; title: &quot;Magician&quot;, author: &quot;Raymond E. Feist&quot; &#125;,</span><br><span class="line">			&#123; title: &quot;The Hobbit&quot;, author: &quot;J.R.R Tolkien&quot; &#125;</span><br><span class="line">		],</span><br><span class="line">		addbook : function(book)&#123;</span><br><span class="line">			service.books.push(book);</span><br><span class="line">			$rootScope.$broadcast(&apos;books.updata&apos;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return service;</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure>
<h3 id="这里很好理解，一个对象里面有我要存放的书的集合，还有一个添加图书的方法，这个方法还会在应用上广播一个事件，告诉所有使用我们的服务的人，存放书的集合已经更新了，接下来就是要使用它的东西需要接收这个广播了。"><a href="#这里很好理解，一个对象里面有我要存放的书的集合，还有一个添加图书的方法，这个方法还会在应用上广播一个事件，告诉所有使用我们的服务的人，存放书的集合已经更新了，接下来就是要使用它的东西需要接收这个广播了。" class="headerlink" title="这里很好理解，一个对象里面有我要存放的书的集合，还有一个添加图书的方法，这个方法还会在应用上广播一个事件，告诉所有使用我们的服务的人，存放书的集合已经更新了，接下来就是要使用它的东西需要接收这个广播了。"></a>这里很好理解，一个对象里面有我要存放的书的集合，还有一个添加图书的方法，这个方法还会在应用上广播一个事件，告诉所有使用我们的服务的人，存放书的集合已经更新了，接下来就是要使用它的东西需要接收这个广播了。</h3><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.controller(&apos;books.list&apos;,[&apos;$scope&apos;,&apos;BookService&apos;,function($scope,BookServie)&#123;</span><br><span class="line">	$scope.$on(&apos;books.updata&apos;,function(event)&#123;</span><br><span class="line">		$scope.books = BookService.books;</span><br><span class="line">		$scope.$apply();</span><br><span class="line">	&#125;);</span><br><span class="line">	$scope.books = BookService.books;</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure>
<h3 id="这里就是将前面创建的BookService中存放的books赋值给了controller内部的scope对象。如果我们在controller上创建一个数组，其他地方也要处理书籍的信息，通过scope来维护数据会很麻烦，scope很容易变得混乱不堪，通过一种集中的途径进行数据的管理，更容易理解也可以使代码模块化。所以当需要在不同的地方共享数据的时候，就要依靠服务了，谁要用就注入到谁那里，就这么容易。"><a href="#这里就是将前面创建的BookService中存放的books赋值给了controller内部的scope对象。如果我们在controller上创建一个数组，其他地方也要处理书籍的信息，通过scope来维护数据会很麻烦，scope很容易变得混乱不堪，通过一种集中的途径进行数据的管理，更容易理解也可以使代码模块化。所以当需要在不同的地方共享数据的时候，就要依靠服务了，谁要用就注入到谁那里，就这么容易。" class="headerlink" title="这里就是将前面创建的BookService中存放的books赋值给了controller内部的scope对象。如果我们在controller上创建一个数组，其他地方也要处理书籍的信息，通过scope来维护数据会很麻烦，scope很容易变得混乱不堪，通过一种集中的途径进行数据的管理，更容易理解也可以使代码模块化。所以当需要在不同的地方共享数据的时候，就要依靠服务了，谁要用就注入到谁那里，就这么容易。"></a>这里就是将前面创建的BookService中存放的books赋值给了controller内部的scope对象。如果我们在controller上创建一个数组，其他地方也要处理书籍的信息，通过scope来维护数据会很麻烦，scope很容易变得混乱不堪，通过一种集中的途径进行数据的管理，更容易理解也可以使代码模块化。所以当需要在不同的地方共享数据的时候，就要依靠服务了，谁要用就注入到谁那里，就这么容易。</h3><br><h3 id="形容服务有一个例子特别的形象，A团A连和B团B连去执行任务，"><a href="#形容服务有一个例子特别的形象，A团A连和B团B连去执行任务，" class="headerlink" title="形容服务有一个例子特别的形象，A团A连和B团B连去执行任务，"></a>形容服务有一个例子特别的形象，A团A连和B团B连去执行任务，</h3>A团A连发现敌情，要报告给B团B连，军队里只有服从上级，所以他只能报告给A团A营，在一直向上报告直到A、B共同的长官C旅，C旅在下发给B团，直到B连，要是有个特殊情况，相信这时候B连已经死光了，所以才有了通信部门的存在，而这里的通信部门也就是angular中的服务。<h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><h3 id="Controller应该纯粹的把Service，依赖关系，以及其他对象串连在一起，通过scope关联到view上。Dom操作的部分最好把它放入指令里面"><a href="#Controller应该纯粹的把Service，依赖关系，以及其他对象串连在一起，通过scope关联到view上。Dom操作的部分最好把它放入指令里面" class="headerlink" title="Controller应该纯粹的把Service，依赖关系，以及其他对象串连在一起，通过scope关联到view上。Dom操作的部分最好把它放入指令里面;"></a>Controller应该纯粹的把Service，依赖关系，以及其他对象串连在一起，通过scope关联到view上。Dom操作的部分最好把它放入指令里面;</h3><br><h2 id="Directive"><a href="#Directive" class="headerlink" title="Directive"></a>Directive</h2><h3 id="应用中最复杂的部分应该在指令中，下面来扩展前面的例子，提供一个按钮，通过这个按钮向服务里面添加一本书。"><a href="#应用中最复杂的部分应该在指令中，下面来扩展前面的例子，提供一个按钮，通过这个按钮向服务里面添加一本书。" class="headerlink" title="应用中最复杂的部分应该在指令中，下面来扩展前面的例子，提供一个按钮，通过这个按钮向服务里面添加一本书。"></a>应用中最复杂的部分应该在指令中，下面来扩展前面的例子，提供一个按钮，通过这个按钮向服务里面添加一本书。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module.directive(&apos;addBookButton&apos;,[&apos;BookService&apos;,function(BookService)&#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		restrict:&apos;EA&apos;,</span><br><span class="line">		replace:true,</span><br><span class="line">		link:function(scope,ele,attrs)&#123;</span><br><span class="line">			ele.bind(&apos;click&apos;,function()&#123;</span><br><span class="line">				BookService.addbook(&#123; title: &quot;Star Wars&quot;, author: &quot;George Lucas&quot; &#125;);</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure>
<h3 id="创建了一个指令，目的是向books集合里面添加一本书，books已经注册在服务中，所以可以直接注入服务进行使用。下面将指令应用到视图中"><a href="#创建了一个指令，目的是向books集合里面添加一本书，books已经注册在服务中，所以可以直接注入服务进行使用。下面将指令应用到视图中" class="headerlink" title="创建了一个指令，目的是向books集合里面添加一本书，books已经注册在服务中，所以可以直接注入服务进行使用。下面将指令应用到视图中"></a>创建了一个指令，目的是向books集合里面添加一本书，books已经注册在服务中，所以可以直接注入服务进行使用。下面将指令应用到视图中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button add-book-button&gt;Add Book&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<br><h3 id="每当点击按钮的时候都会添加那本书，如果将控制器上面添加一个addBook方法呢，"><a href="#每当点击按钮的时候都会添加那本书，如果将控制器上面添加一个addBook方法呢，" class="headerlink" title="每当点击按钮的时候都会添加那本书，如果将控制器上面添加一个addBook方法呢，"></a>每当点击按钮的时候都会添加那本书，如果将控制器上面添加一个addBook方法呢，</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$scope.addBook = function()&#123;</span><br><span class="line">	 BookService.addBook( &#123; title: &quot;Star Wars&quot;, author: &quot;George Lucas&quot; &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可以得到同样的结果，但是如果需要复用的话，只能copy这段代码，但是通过指令的方式，就会很方便了"><a href="#可以得到同样的结果，但是如果需要复用的话，只能copy这段代码，但是通过指令的方式，就会很方便了" class="headerlink" title="可以得到同样的结果，但是如果需要复用的话，只能copy这段代码，但是通过指令的方式，就会很方便了"></a>可以得到同样的结果，但是如果需要复用的话，只能copy这段代码，但是通过指令的方式，就会很方便了</h3></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lee_Ran"
      src="https://avatars3.githubusercontent.com/u/17755520?s=400&u=9f444bfe70cd719b9bf43ed5fedac2f1d005ff5a&v=4">
  <p class="site-author-name" itemprop="name">Lee_Ran</p>
  <div class="site-description" itemprop="description">保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/vernvn" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;vernvn" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/LeeRan_6924" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;LeeRan_6924" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lee_Ran</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">NaNm</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">NaN:aN</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>













  

  

</body>
</html>
