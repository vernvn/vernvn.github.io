<!doctype html>



  


<html class="theme-next muse use-motion">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lee/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lee/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2">






<meta name="description" content="my blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://vernvn.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="my blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="my blog">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://vernvn.github.io/">


  <title> Hexo </title>
</head>

<body itemscope="" itemtype="//schema.org/WebPage" lang="zh-CN">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Hexo</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule" rel="section">
            
            Schedule
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/06/12/Flutter新的状态管理方案/" itemprop="url">
                  Flutter新的状态管理方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-06-12T14:21:51+08:00" content="2019-06-12">
              2019-06-12
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在Google IO 2019大会上提出了新的状态管理方案Provider用来替代之前的状态管理方案Provide，针对不同类型对象提供了多种不同的Provider;Provider借助了InheritWidget，将共享状态放到顶层Widget。</p>
</blockquote>
<ul>
<li>借助了InheritWidget，允许将有效信息传递到组件树下的小组件</li>
<li>提供DI</li>
<li>创建和销毁实例</li>
<li>结合Bloc等进行状态管理</li>
</ul>
<h4 id="Let’s-Code"><a href="#Let’s-Code" class="headerlink" title="Let’s Code"></a>Let’s Code</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const Provider.value(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    @required T value,</span><br><span class="line">    this.updateShouldNotify,</span><br><span class="line">    this.child</span><br><span class="line">&#125;) : dispose = null, super.value(key: key, value: value);</span><br></pre></td></tr></table></figure>
<p>上面的源码value的类型为范型，并没有进行限制，所以可以绑定任意数据类型</p>
<h5 id="如何绑定数据"><a href="#如何绑定数据" class="headerlink" title="如何绑定数据"></a>如何绑定数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">    @override</span><br><span class="line">    Widget build (BuildContext context) &#123;</span><br><span class="line">        return MaterialApp(</span><br><span class="line">            title: &apos;demo&apos;,</span><br><span class="line">            home: Provider&lt;String&gt;.value(</span><br><span class="line">                value: &apos;demo&apos;,</span><br><span class="line">                child: Demo()</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Provider.of()在Provider窗口小部件对应的后代中BuildContext是必需的；获取BuildContext麻烦时Consumer()是很好的替代方式</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">    @override</span><br><span class="line">    Widget build (BuildContext context) &#123;</span><br><span class="line">        return MaterialApp(</span><br><span class="line">            title: &apos;demo&apos;,</span><br><span class="line">            home: Provider&lt;String&gt;.value(</span><br><span class="line">                value: &apos;demo&apos;,</span><br><span class="line">                child: Consumer&lt;String&gt;(</span><br><span class="line">                    builder: (context, value, child) &#123;</span><br><span class="line">                        return Center(</span><br><span class="line">                            child: Text(value)</span><br><span class="line">                        )</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="如何获取数据"><a href="#如何获取数据" class="headerlink" title="如何获取数据"></a>如何获取数据</h5><p>provider需要在绑定的子widget中获取数据，使用静态方法Provider.of(BuildContext context),此方法将从关联的widget树中查找<font face="黑体" color="#f00" size="4">最近的相同类型的数据</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class Demo extends StatelessWidget &#123;</span><br><span class="line">    @override</span><br><span class="line">    Widget build (BuildContext context) &#123;</span><br><span class="line">        final value = Provider.of&lt;String&gt;(context);</span><br><span class="line">        return Center(</span><br><span class="line">            child: Text(value)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#####以上简述了Provider的数据绑定几获取的方法，下面在应用场景里实现Provider的作用，以官方的计数器的例子来举例</p>
<p>首先创建一个Counter类，并封装他的增和减的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Counter with ChangeNotifier&#123;</span><br><span class="line">    int _counter;</span><br><span class="line">    Counter(this._counter);</span><br><span class="line">    getCouonter =&gt; _counter;</span><br><span class="line">    setCounter(int counter) =&gt; _counter = counter;</span><br><span class="line">    void increment() &#123;</span><br><span class="line">        _counter ++;</span><br><span class="line">        notifyListeners();</span><br><span class="line">    &#125;</span><br><span class="line">    void decrement() &#123;</span><br><span class="line">        _counter --;</span><br><span class="line">        notifyListeners();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在Counter类拥有了监听的功能，我们需要调用notifyListeners()去通知监听器数据变化，并更新UI</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">    @override</span><br><span class="line">    Widget build (BuildContext context) &#123;</span><br><span class="line">        return MaterialApp(</span><br><span class="line">            title: &apos;demo&apos;,</span><br><span class="line">            home: ChangeNotifierProvider&lt;Counter&gt;(</span><br><span class="line">                builder: (_) =&gt; Counter(0),</span><br><span class="line">                child: HomePage()</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class HomePage extends StatelessWidget &#123;</span><br><span class="line">    @override</span><br><span class="line">    Widget build (BuildContext context) &#123;</span><br><span class="line">        final counter = Provider.of&lt;Counter&gt;(context);</span><br><span class="line">        return Scaffold(</span><br><span class="line">            appBar: AppBar(</span><br><span class="line">                title: Text(&apos;ChangeNotifierProvider demo&apos;)</span><br><span class="line">            ),</span><br><span class="line">            body: Center(</span><br><span class="line">                child: Text(counter.getCounter())</span><br><span class="line">            ),</span><br><span class="line">            floatingActionButton: Column(</span><br><span class="line">                children: &lt;Widget&gt;[</span><br><span class="line">                    FloatingActionButton(</span><br><span class="line">                        onPressed: counter.increment,</span><br><span class="line">                        child: Icon(Icons.add)</span><br><span class="line">                    ),</span><br><span class="line">                    FloatingActionButton(</span><br><span class="line">                        onPressed: counter.decrement,</span><br><span class="line">                        child: Icon(Icons.remove)</span><br><span class="line">                    ),</span><br><span class="line">                ]</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Provider结合Bloc模式进行状态管理"><a href="#Provider结合Bloc模式进行状态管理" class="headerlink" title="Provider结合Bloc模式进行状态管理"></a>Provider结合Bloc模式进行状态管理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class CounterBloc &#123;</span><br><span class="line">    final _valueController = StreamController&lt;String&gt;();</span><br><span class="line">    Stream&lt;String&gt; get stream =&gt; _valueController.stream;</span><br><span class="line">    int _number = 0;</span><br><span class="line">    void increment() &#123;</span><br><span class="line">        _number++;</span><br><span class="line">        _valueController.sink.add(_number.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    void dispose() &#123;</span><br><span class="line">        _valueController.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProviderPage extends StatelessWidget &#123;</span><br><span class="line">    @override</span><br><span class="line">    Widget build (BuildContext context) &#123;</span><br><span class="line">        return Provider&lt;CounterBloc&gt;(</span><br><span class="line">            builder: (_) =&gt; CounterBloc(),</span><br><span class="line">            dispose: (_, bloc) =&gt; bloc.dispose(),</span><br><span class="line">            child: Scaffold(</span><br><span class="line">                body: CounterText(),</span><br><span class="line">                floatingActionButton: _floatingButton(),</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Widget _floatingButton() &#123;</span><br><span class="line">        return Consumer&lt;CounterBloc&gt;(</span><br><span class="line">            builder: (context, value, child) &#123;</span><br><span class="line">                return FloatingActionButton(</span><br><span class="line">                    onPressed: value.increment,</span><br><span class="line">                    child: const Icon(Icons.add),</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class CounterText extends StatelessWidget &#123;</span><br><span class="line">    @override</span><br><span class="line">    Widget build (BuildContext context) &#123;</span><br><span class="line">        final bloc = Provider.of&lt;CounterBloc&gt;(context);</span><br><span class="line">        return StreamBuilder&lt;String&gt;(</span><br><span class="line">            stream: bloc.stream,</span><br><span class="line">            builder: (context, snapshot) &#123;</span><br><span class="line">                return Center(</span><br><span class="line">                    child: Text(snapshot.data ?? &apos;0&apos;)</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="以上可以用Provder-value-实现，引入简单值传播"><a href="#以上可以用Provder-value-实现，引入简单值传播" class="headerlink" title="以上可以用Provder.value()实现，引入简单值传播"></a>以上可以用Provder.value()实现，引入简单值传播</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class ProviderValuePage extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  ProviderValueState createState() =&gt; ProviderValueState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProviderValueState extends State&lt;ProviderValuePage&gt; &#123;</span><br><span class="line">  final _bloc = CounterBloc();</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Scaffold(</span><br><span class="line">      body: Provider&lt;CounterBloc&gt;.value(</span><br><span class="line">        value: _bloc,</span><br><span class="line">        child: CounterText(),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: bloc.increment,</span><br><span class="line">        child: const Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void dispose() &#123;</span><br><span class="line">    _bloc.dispose();</span><br><span class="line">    super.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CounterText extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    final bloc = Provider.of&lt;CounterBloc&gt;(context);</span><br><span class="line"></span><br><span class="line">    return StreamBuilder&lt;String&gt;(</span><br><span class="line">      stream: bloc.stream,</span><br><span class="line">      builder: (context, snapshot) &#123;</span><br><span class="line">        return Center(</span><br><span class="line">          child: Text(snapshot.data ?? &apos;0&apos;)</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ChangeNotifierProvider与ChangeNotifierProvider.value()等提供商的唯一区别在于<font face="黑体" color="#f00" size="4">ChangeNotifierProvider.value()创建和销毁模型实例需要自行处理</font></p>
<p>多提供商的场景</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Provider&lt;Foo&gt;.value(</span><br><span class="line">    value: foo,</span><br><span class="line">    child: Provider&lt;Bar&gt;.value(</span><br><span class="line">        value: bar,</span><br><span class="line">        child: Provider&lt;Baz&gt;.value(</span><br><span class="line">            value: baz,</span><br><span class="line">            child: someWidget</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>一层一层的嵌套导致代码可读性降低，所以产生了MultiProvider</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MultiProvider(</span><br><span class="line">    providers: [</span><br><span class="line">        Provider&lt;Foo&gt;.value(value: foo),</span><br><span class="line">        Provider&lt;Bar&gt;.value(value: bar),</span><br><span class="line">        Provider&lt;Baz&gt;.value(value: baz),</span><br><span class="line">    ],</span><br><span class="line">    child: someWidget</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<font face="黑体" color="#f00" size="4">注意的是需要指定不同的类型，如果是相同的类型，将保留最后一个Provider的值</font>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/06/12/flutter中可以携带参数的命名路由/" itemprop="url">
                  flutter中可以携带参数的命名路由
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-06-12T11:22:17+08:00" content="2019-06-12">
              2019-06-12
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="创建一个可以携带参数的flutter命名路由"><a href="#创建一个可以携带参数的flutter命名路由" class="headerlink" title="创建一个可以携带参数的flutter命名路由"></a>创建一个可以携带参数的flutter命名路由</h2><p>MaterialApp提供了一个属性<font face="黑体" color="#f00" size="4">onGenerateRoute</font>,需要一个返回<code>Route&lt;dynamic&gt;</code>,并接受<code>RouteSettings</code>参数的函数</p>
<p>首先创建一个Router类，并且创建一个静态函数,settings包括路由的名称和参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Router &#123;</span><br><span class="line">    static Route&lt;dynamic&gt; generateRoute(RouteSettings settings) &#123;</span><br><span class="line">        switch(settings.name) &#123;</span><br><span class="line">            case &apos;/&apos;: return MaterialPageRoute(</span><br><span class="line">                builder: (_) =&gt; Home()</span><br><span class="line">            ),</span><br><span class="line">            case &apos;/feed&apos;: return MaterialPageRoute(</span><br><span class="line">                builder: (_) =&gt; Feed()</span><br><span class="line">            ),</span><br><span class="line">            default: return MaterialPageRoute(</span><br><span class="line">                builder: (_) =&gt; Scaffold(</span><br><span class="line">                    body: Center(</span><br><span class="line">                        child: Text(&apos;没有路由&apos;)</span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了避免我们的代码出现错误，我们将采用硬编码的方式定义路由名称，并放到全局可以访问的constant.dart文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const String homeRoute = &apos;/&apos;;</span><br><span class="line">const String feedRoute = &apos;/feed&apos;;</span><br></pre></td></tr></table></figure></p>
<p>switch case语句之后更改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">case homeRoute: return MaterialPageRoute(</span><br><span class="line">    builder: (_) =&gt; Home()</span><br><span class="line">),</span><br><span class="line">case feedRoute: return MaterialPageRoute(</span><br><span class="line">    builder: (_) =&gt; Feed()</span><br><span class="line">),</span><br></pre></td></tr></table></figure></p>
<p>之后，在定义MaterialApp应用程序时，generateRoute函数传递给onGenerateRoute,通过initialRoute配置起始视图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">    @override</span><br><span class="line">    Widget build (BuildContext context) &#123;</span><br><span class="line">        return MaterialApp (</span><br><span class="line">            onGenerateRoute: Router.generateRoute,</span><br><span class="line">            initialRoute: homeRoute</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时，当你需要导航时，只需要使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Navigator.pushNamed(context, feedRoute);</span><br></pre></td></tr></table></figure></p>
<p>如果需要传递参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Navigator.pushNamed(context, feedRoute, arguments: &apos;传递的参数&apos;);</span><br><span class="line">case feedRoute: </span><br><span class="line">    var data = settins.arguments as String;</span><br><span class="line">    return MaterialPageRoute(</span><br><span class="line">        builder: (_) =&gt; Feed(data)</span><br><span class="line">    ),</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/26/steam in dart/" itemprop="url">
                  Dart Streams
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-02-26T15:02:52+08:00" content="2019-02-26">
              2019-02-26
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是Streams"><a href="#什么是Streams" class="headerlink" title="什么是Streams?"></a>什么是Streams?</h3><blockquote>
<p>streams就好比传送带，将物品放到一侧，他将自动运送到另一侧。我们可以将数据对象放在传送带上，他会被传送带传输。如果传送带不是无限长的（它不是一个无限的流， 例如rxjs里的interval，如果不取消订阅，他会随着时间一直流动），那么传送带的物品终会掉落。</p>
</blockquote>
<p><img src="https://cdn-images-1.medium.com/max/1600/0*z_EhYGu-2XQ5AwST.gif" alt="avatar"></p>
<blockquote>
<p>为了避免传送带上的物品无辜掉落，我们可以做一些事情，使得物品在掉落之前实现某些价值。</p>
</blockquote>
<p><img src="https://cdn-images-1.medium.com/max/1600/0*2LOUvyESiTySjwwU.gif" alt="avatar"></p>
<h3 id="Dart-Streams-和-Rx"><a href="#Dart-Streams-和-Rx" class="headerlink" title="Dart Streams 和 Rx"></a>Dart Streams 和 Rx</h3><ul>
<li><p>Rx里面的可观察对象命名未Observable，它与Dart Streams里的Stream是同等的意义，所以在可以使用Stream的任何地方赋予Observable的含义</p>
</li>
<li><p>listen / subscribe, 进行序列订阅，同等意义</p>
</li>
<li><p>listen()返回一个StreamSubscription对象，调用cancel()释放订阅</p>
</li>
<li><p>StreamController / Subject, 发布值，相当于在传送带的左侧添加物品，同等意义</p>
</li>
</ul>
<h3 id="使用StreamBuilder"><a href="#使用StreamBuilder" class="headerlink" title="使用StreamBuilder"></a>使用StreamBuilder</h3><p>不用使用initState()和setState(),flutter提供了一个方便的widget称之为StreamBuilder,它需要一个Stream和一个builder函数，只要Stream发出一个新值就会调用他,不再需要initState或dispose.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">body: Center(</span><br><span class="line">	child: Column(</span><br><span class="line">		mainAxisAligment: MainAxisAlignment.center,</span><br><span class="line">		children: &lt;Widget&gt;[</span><br><span class="line">			Text(&apos;demo&apos;),</span><br><span class="line">			StreamBuilder&lt;int&gt;(</span><br><span class="line">				initialData: 0,</span><br><span class="line">				stream: _stream,</span><br><span class="line">				builder: (context, snappShot) &#123;</span><br><span class="line">					String valueString = &apos;NoData&apos;;</span><br><span class="line">					if (snappShot != null &amp;&amp; snappShot.hasData) &#123;</span><br><span class="line">						valueString = snappShot.data.toString();</span><br><span class="line">					&#125;</span><br><span class="line">					return Text(</span><br><span class="line">						valueString,</span><br><span class="line">						style: Theme.of(context).textTheme.display1</span><br><span class="line">					)</span><br><span class="line">				&#125;</span><br><span class="line">			)</span><br><span class="line">		]</span><br><span class="line">	)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>相对于直接订阅，使用StreamBuilder有几个明显的区别：</p>
<ul>
<li>setState()在listen()时接受新值时会重建整页，而StreamBuilder只会重建他自己的widget</li>
<li>snappShot包含从Stream接收的最新数据</li>
<li>含有一个initialData,用于第一次构建，即屏幕的第一帧，解决StreamBuilder不能在第一帧期间接收值的问题,如果snappShot无效,则返回默认Widget，适用于某些业务场景</li>
</ul>
<h3 id="flutter中使用BLOC模式"><a href="#flutter中使用BLOC模式" class="headerlink" title="flutter中使用BLOC模式"></a>flutter中使用BLOC模式</h3><h4 id="什么是bloc模式？"><a href="#什么是bloc模式？" class="headerlink" title="什么是bloc模式？"></a>什么是bloc模式？</h4><p>bloc[Business Logic Component]翻译过来就是业务逻辑组件，把业务逻辑抽出来，数据和ui解耦，一处改动，多处更新</p>
<blockquote>
<p><img src="https://ask.qcloudimg.com/http-save/1203298/sb707akvgg.png?imageView2/2/w/1620" alt="avatar"></p>
</blockquote>
<blockquote>
<p>上面描述的是组件的一些基本行为，【展示数据】，【发送事件】,flutter中实现Bloc的精髓就是stream，严格遵守了单一职责原则，代码解耦更好。</p>
</blockquote>
<p>UI<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void main() =&gt; runApp(MyApp());</span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">class CounterPage extends StateLessWidget &#123;</span><br><span class="line">	@override</span><br><span class="line">	Widget build(BuildContext context) &#123;</span><br><span class="line">		final IncrementBloc bloc = BlocProvider.of&lt;IncrementBloc&gt;(context);</span><br><span class="line">		return Scaffod(</span><br><span class="line">			appBar: AppBar(</span><br><span class="line">				title: Text(&apos;block&apos;)</span><br><span class="line">			),</span><br><span class="line">			body: Center(</span><br><span class="line">				child: StreamBuilder&lt;int&gt;(</span><br><span class="line">					stream: bloc._counterStream,</span><br><span class="line">					initialData: 0,</span><br><span class="line">					builder: (BuildContext context, AsyncSnapShot&lt;int&gt; snapshot) &#123;</span><br><span class="line">						return Text(&apos;clicked $&#123;snapshot.data&#125; times&apos;)</span><br><span class="line">					&#125;</span><br><span class="line">				)</span><br><span class="line">			),</span><br><span class="line">			floatingActionButton: FloatingActionButton(</span><br><span class="line">				child: Icon(Icons.add),</span><br><span class="line">				onPressed: () &#123;</span><br><span class="line">					bloc._actionSink.add(null);  // 发送事件</span><br><span class="line">				&#125;</span><br><span class="line">			)</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Bloc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class IncrementBloc &#123;</span><br><span class="line">	int _counter;</span><br><span class="line">	StreamController&lt;int&gt; _counterController = StreamController&lt;int&gt;();</span><br><span class="line">	StreamSink&lt;int&gt; _counterSink =&gt; _counterController.sink;  		// 发送数据</span><br><span class="line">	Stream&lt;int&gt; _counterStream =&gt; _counterController.stream;   		// stream</span><br><span class="line"></span><br><span class="line">	StreamController _actionController = StreamController();</span><br><span class="line">	StreamSink _actionSink =&gt; _actionController.sink;</span><br><span class="line">	Stream _actionStream =&gt; _actionController.stream; </span><br><span class="line"></span><br><span class="line">	void IncrementBloc() &#123;</span><br><span class="line">		_counter = 0;</span><br><span class="line">		_actionStream.listen((data)&#123;</span><br><span class="line">			_counter = _counter + 1;</span><br><span class="line">			_counterSink.add(_counter);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/21/flutter/" itemprop="url">
                  flutter 学习笔记与问题总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-02-21T10:26:33+08:00" content="2019-02-21">
              2019-02-21
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Flutter框架结构"><a href="#Flutter框架结构" class="headerlink" title="Flutter框架结构"></a>Flutter框架结构</h4><p><img src="https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/framework.png" alt="avatar"></p>
<ul>
<li><p>底下两层（Foundation和Animation、Painting、Gestures被合并为一个dart UI层，它是Flutter引擎暴露的底层UI库，提供动画、手势及绘制能力。</p>
</li>
<li><p>Rendering层，这一层是一个抽象的布局层，它依赖于dart UI层，Rendering层会构建一个UI树，当UI树有变化时，会计算出有变化的部分，然后更新UI树，最终将UI树绘制到屏幕上，这个过程类似于React中的虚拟DOM。Rendering层可以说是Flutter UI框架最核心的部分，它除了确定每个UI元素的位置、大小之外还要进行坐标变换、绘制(调用底层dart:ui)。</p>
</li>
<li><p>Widgets层是Flutter提供的的一套基础组件库，在基础组件库之上，Flutter还提供了 Material 和Cupertino两种视觉风格的组件库。而我们Flutter开发的大多数场景，只是和这两层打交道。</p>
</li>
</ul>
<h4 id="primarySwatch-和-primaryColor-的区别"><a href="#primarySwatch-和-primaryColor-的区别" class="headerlink" title="primarySwatch 和 primaryColor 的区别"></a>primarySwatch 和 primaryColor 的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Widget build (BuildContext context) &#123;</span><br><span class="line">	return MaterialApp(</span><br><span class="line">		title: &apos;myApp&apos;,</span><br><span class="line">		theme: ThemeData(</span><br><span class="line">			primaryColor: Colors.white   // primarySwatch  </span><br><span class="line">		)</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用primaryColor可以Colors.white,使用primarySwatch不可以设置白色和黑色，primarySwatch中的颜色是调用MaterialColor这种颜色类</p>
<h4 id="listView"><a href="#listView" class="headerlink" title="listView"></a>listView</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Widget _buildSuggestions() &#123;</span><br><span class="line">	return ListView.builder(</span><br><span class="line">		padding: EdgeInsets.all(16.0),</span><br><span class="line">		itemCount: 100,</span><br><span class="line">		itemBuilder: (BuildContext context, i) &#123;   //itemBuilder callback </span><br><span class="line">			if (i.isOdd) &#123;</span><br><span class="line">				return Something();</span><br><span class="line">			&#125;</span><br><span class="line">			return Another()</span><br><span class="line">		&#125;</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h4><p>与js一样，dart支持单线程执行，js中Promise对象表示异步操作的最终结果，dart中用Future对象来处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_getIpAddress() &#123;</span><br><span class="line">	final url = &apos;http://www.google.com&apos;;</span><br><span class="line">	HttpRequest.reqeust(url).then((value) =&gt; &#123;</span><br><span class="line">		print(json.decode(value.responseText)[&apos;origin&apos;]);</span><br><span class="line">	&#125;).catchError((error) =&gt; print(error))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>async函数返回Future,await等待Future</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_getIpAddress() &#123;</span><br><span class="line">	final url = &apos;http://www.google.com&apos;;</span><br><span class="line">	var request = await HttpRequest.reqeust(url);</span><br><span class="line">	String ip = json.decode(request.responseText)[&apos;origin&apos;];</span><br><span class="line">	print(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Contianer(</span><br><span class="line">	child: Center(</span><br><span class="line">		child: Container(</span><br><span class="line">			child: Text(&apos;demo&apos;),</span><br><span class="line">			decoration: BoxDecoration(    // color, borderRadius, boxShadow, shape 通过BoxDecoration装饰</span><br><span class="line">				color: Colors.red,</span><br><span class="line">				borderRadius: BorderRadius.all(</span><br><span class="line">					Radius.circular(8.0)</span><br><span class="line">				),</span><br><span class="line">				boxshadow: &lt;BoxShadow&gt;[</span><br><span class="line">					BoxShadow(</span><br><span class="line">						color: Color(0xcc000000),</span><br><span class="line">						offset: Offset(0.0, 2.0)</span><br><span class="line">					),</span><br><span class="line">					BoxShadow(</span><br><span class="line">						color: Color(0000000000),</span><br><span class="line">						offset: Offset(0.0, 2.0)</span><br><span class="line">					)</span><br><span class="line">				],</span><br><span class="line">				shape: BoxShape.circle  </span><br><span class="line">			),</span><br><span class="line">			padding: EdgesInsets.all(16.0),</span><br><span class="line">			width: 240.0</span><br><span class="line">		)</span><br><span class="line">	)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>Positioned widget and Stack widget</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">	child: Stack(</span><br><span class="line">		children: [</span><br><span class="line">			Positioned(</span><br><span class="line">				child: Container(</span><br><span class="line">					child: Text(&apos;demo&apos;),</span><br><span class="line">					decoration: BoxDecoration(</span><br><span class="line">						color: Colors.red</span><br><span class="line">					)</span><br><span class="line">				),</span><br><span class="line">				left: 24.0,</span><br><span class="line">				top: 24.0</span><br><span class="line">			)</span><br><span class="line">		]</span><br><span class="line">	),</span><br><span class="line">	width: 320.0,</span><br><span class="line">	height: 320.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>Transform widget and Scaling widget</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">	child: Transform(</span><br><span class="line">		child: Container(</span><br><span class="line">			child: Text(&apos;demo&apos;)</span><br><span class="line">		),</span><br><span class="line">		alignment: Alignment.center,</span><br><span class="line">		transform: Matrix4.identity()..rotateZ(15 * 3.1415926 / 180)  // rotate</span><br><span class="line">		transform: Matrix4.identity()..scale(1.5)   // scale</span><br><span class="line">	),</span><br><span class="line">	width: 320.0,</span><br><span class="line">	height: 320.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>ellipsis</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">	child: Container(</span><br><span class="line">		child: Text(</span><br><span class="line">			child: Text(&apos;demo&apos;),</span><br><span class="line">			overflow: TextOverflow.ellipsis,</span><br><span class="line">			maxLines: 1</span><br><span class="line">		),</span><br><span class="line">	),</span><br><span class="line">	width: 320.0,</span><br><span class="line">	height: 320.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="GestureDetector-处理手势"><a href="#GestureDetector-处理手势" class="headerlink" title="GestureDetector 处理手势"></a>GestureDetector 处理手势</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MyButton extends StatelessWidget &#123;</span><br><span class="line">	@override</span><br><span class="line">	Widget build (BuildContext context) &#123;</span><br><span class="line">		return GestureDetector(     		// IconButton等使用GestureDetector提供onPressed回调</span><br><span class="line">			onTap: () &#123;   					// onLongPress...</span><br><span class="line">				print(&apos;tapped&apos;)</span><br><span class="line">			&#125;,</span><br><span class="line">			child: Container(</span><br><span class="line">				child: Text(&apos;demo&apos;)</span><br><span class="line">			)</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="final-const-var-static-in-Dart"><a href="#final-const-var-static-in-Dart" class="headerlink" title="final const var static in Dart"></a>final const var static in Dart</h4><blockquote>
<p>static: 表示一个成员属于类而不是对象，修饰成员</p>
</blockquote>
<blockquote>
<p>final: 必须初始化，且值不可变，编译时不能确定值，修饰变量  //  final list = [1,2,3];  list[0] = 4;  =&gt; [4,2,3]</p>
</blockquote>
<blockquote>
<p>const: 编译时可确定，并且不能修改    // var list = const [1,2,3];  list[0] = 4;  error</p>
</blockquote>
<h4 id="typedef-类型定义，通过用来检查函数类型"><a href="#typedef-类型定义，通过用来检查函数类型" class="headerlink" title="typedef 类型定义，通过用来检查函数类型"></a>typedef 类型定义，通过用来检查函数类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef int Compart(int a, int b);</span><br><span class="line">int sort(int a, int b) =&gt; a - b;</span><br><span class="line">main() &#123;</span><br><span class="line">	assert(sort is Compare);   // True</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/11/06/rxjs常用操作符及项目应用/" itemprop="url">
                  rxjs常用操作符及项目应用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2018-11-06T17:20:07+08:00" content="2018-11-06">
              2018-11-06
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>RXJS全名Reactive Extensions for JavaScript，是JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。ReactiveX结合了观察者模式、迭代器模式和函数式编程构建一个管理事件序列的理想方式。</p>
<h4 id="RxJS所能解决的问题："><a href="#RxJS所能解决的问题：" class="headerlink" title="RxJS所能解决的问题："></a>RxJS所能解决的问题：</h4><p>时刻保持响应。这对于一个应用来说意味着当他处理用户的输入或者凭借AJAX从服务器接受一些数据时停止是一件不可能接受的事情。在JavaScript中解决问题的方案始终是大量运用回调函数来进行一些应用的处理。但回调的使用使内容丰富的大型应用变得凌乱，一旦你需要多块数据时你就陷入了回调地狱。Angular2中，组件间通讯@Output对应的EventEmitter实际上就是一个Subject；Http模块中Observable作为大部分API的交互对象使用。但是这只是官方推荐的外部扩展并不必须，也可以使用Promise,之后会介绍Observable和Promise的区别。</p>
<h4 id="RxJS初探："><a href="#RxJS初探：" class="headerlink" title="RxJS初探："></a>RxJS初探：</h4><h5 id="首先尝试一个简单的小例子："><a href="#首先尝试一个简单的小例子：" class="headerlink" title="首先尝试一个简单的小例子："></a>首先尝试一个简单的小例子：</h5><ul>
<li>存在一个数组，里面含有多种数据类型的元素</li>
<li>找到其中的数字及字数组成的字符串</li>
<li>每一个符合标准的元素乘以2</li>
<li>累加</li>
</ul>
<p>需要同时满足以上四个要求，可以通过循环列表来筛选满足要求的元素在进一步操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const source = [1, 5, 9, 3, &apos;hi&apos;, &apos;tb&apos;, 456, &apos;11&apos;, &apos;yoyoyo&apos;];</span><br><span class="line">let total = 0;</span><br><span class="line">for (let i = 0; i &lt; source.length; i++) &#123;</span><br><span class="line">    const num = parseInt(source[i], 10);</span><br><span class="line">    if (!isNaN(num)) &#123;</span><br><span class="line">        total += num * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果拥有函数式编程的经验，相信大家一定会通过es6的映射函数进行操作,接下来通过这个例子说明一下命令式编程和函数式编程的区别。</p>
<blockquote>
<p>声明式编程发轫于人工智能的研究，主要包括函数式编程（functional programming，简称FP）和逻辑式编程（logic programming，简称LP）;<br>如果想探究声明式编程与函数式编程的具体关系请访问：<a href="https://www.cnblogs.com/doit8791/p/8232821.html" target="_blank" rel="noopener">函数式与声明式的关系</a>，在此不是本篇的重点</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const source = [1, 5, 9, 3, &apos;hi&apos;, &apos;tb&apos;, 456, &apos;11&apos;, &apos;yoyoyo&apos;];</span><br><span class="line">let total = source  </span><br><span class="line">    .map(x =&gt; parseInt(x as any, 10))</span><br><span class="line">    .filter(x =&gt; !isNaN(x))</span><br><span class="line">    .map(x =&gt; x * 2)</span><br><span class="line">    .reduce((total, value) =&gt; total + value);</span><br></pre></td></tr></table></figure>
<p>函数式编程中的函数这个术语不是指计算机中的函数，而是指数学中的函数，即自变量的映射。也就是说一个函数返回的值仅决定于函数参数的值，不依赖其他状态。命令式编程注重的是函数执行的细节，函数式编程注重的是函数执行的结果。<br>函数式编程对函数的使用有一些特殊要求：</p>
<ul>
<li>声明式函数</li>
<li>纯函数</li>
<li>数据不可变性</li>
</ul>
<p>声明式编程是人脑思维方式的抽象，即利用数理逻辑或既定规范对已知条件进行推理或运算。声明式的函数，让开发者只需要表达”想要做什么”，而不需要表达“怎么去做”。<br>纯函数指的是执行结果由输入参数决定，参数相同时结果相同，不受其他数据影响，并且不会带来副作用的函数。副作用指的是函数做了和本身运算返回值没有关系的事情，如修改外部变量或传入的参数对象，甚至是执行console.log都算是副作用。前端中常见的副作用有发送http请求、操作DOM、调用alert或者confirm函数等。<br>数据不可变就是指这个数据一旦产生，它的值就永远不会变。JavaScript中字符串类型和数字类型就是不可改变的，而对象基本都是可变的，可能会带来各种副作用。</p>
<h4 id="函数式编程带来的好处主要可以总结为以下两点："><a href="#函数式编程带来的好处主要可以总结为以下两点：" class="headerlink" title="函数式编程带来的好处主要可以总结为以下两点："></a>函数式编程带来的好处主要可以总结为以下两点：</h4><ul>
<li>相比命令式编程，少了非常多的状态变量的声明与维护</li>
<li>代码更为简洁，可读性更强</li>
</ul>
<h3 id="进入RxJS"><a href="#进入RxJS" class="headerlink" title="进入RxJS"></a>进入RxJS</h3><p>流（Stream）无非是随<strong>时间</strong>流逝的一系列事件。流可以用来处理任何类型的事件，如：鼠标点击，键盘按下等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。Stream在其时间轴中发出三样东西，一个值，一个错误和完整的信号。我们必须捕获此异步事件并相应地执行函数。</p>
<p><img src="https://s1.ax1x.com/2018/09/20/im7Ry9.gif" alt=""></p>
<p>想要抓取事件，一般可以用 callback 或是 Promise 来达成，promise和observable都是为解决异步问题而设计的（避免“回调地狱”）, 然而 Promise 主要設设计一次性的事件与单一回傳=传值，而RxJS除了包含Promise外，提供了observable可观察对象，以惰性的方式推送多值的集合</p>
<h4 id="Pull拉取-VS-Push推送"><a href="#Pull拉取-VS-Push推送" class="headerlink" title="Pull拉取 VS Push推送"></a>Pull拉取 VS Push推送</h4><p>拉和推是数据生产者和数据的消费者两种不同的交流协议;什么是”pull”？在”pull”体系中，数据的消费者决定何时从数据生产者那里获取数据，而生产者自身并不会意识到什么时候数据将会被发送给消费者。每一个JS函数都是一个“pull”体系.<br>什么是”push”？在push体系中，数据的生产者决定何时发送数据给消费者，消费者不会在接收数据之前意识到它将要接收这个数据。<br>Promise(承诺))是当今JS中最常见的Push体系，一个Promise(数据的生产者)发送一个resolved value(成功状态的值)来注册一个回调(数据消费者)，但是不同于函数的地方的是：Promise决定着何时数据才被推送至这个回调函数。<br>RxJS引入了Observables(可观察对象)，一个全新的”推体系”。一个可观察对象是一个产生多值的生产者，并”推送给”Observer(观察者)。</p>
<h4 id="单值与多值"><a href="#单值与多值" class="headerlink" title="单值与多值"></a>单值与多值</h4><p>如果您通过Promise提出请求并等待回复。您可以确定对同一请求不会有多个响应。Observables允许您在调用observer.complete()函数之前解析多个值</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*ThbKddqq1qC4a1pDDjHNoQ.jpeg" alt=""></p>
<h4 id="总结RxJS-VS-Promise-——-三个最重要的区别"><a href="#总结RxJS-VS-Promise-——-三个最重要的区别" class="headerlink" title="总结RxJS VS Promise —— 三个最重要的区别"></a>总结RxJS VS Promise —— 三个最重要的区别</h4><table>
<thead>
<tr>
<th>区别</th>
<th style="text-align:center">Rxjs</th>
<th style="text-align:right">Promise</th>
</tr>
</thead>
<tbody>
<tr>
<td>动作是否可以取消？</td>
<td style="text-align:center">是</td>
<td style="text-align:right">否</td>
</tr>
<tr>
<td>是否可以发射多个值？</td>
<td style="text-align:center">是</td>
<td style="text-align:right">否</td>
</tr>
<tr>
<td>各种工具函数？</td>
<td style="text-align:center">是</td>
<td style="text-align:right">否</td>
</tr>
</tbody>
</table>
<h4 id="开始了解RxJS中的几个重要成员"><a href="#开始了解RxJS中的几个重要成员" class="headerlink" title="开始了解RxJS中的几个重要成员"></a>开始了解RxJS中的几个重要成员</h4><ul>
<li>Observable(可观察对象)：表示一个可调用的未来值或者时间序列上的事件集合</li>
<li>Observer(观察者)：一个回调函数集合,它知道怎样去监听被Observable发送的值</li>
<li>Subscription(订阅)： 表示一个可观察对象的执行，主要用于取消执行</li>
<li>Subject(主题)：等同于一个事件驱动器，是将一个值或者事件广播到多个观察者的唯一途径</li>
<li>Operators(操作符)： 纯函数，使得以函数编程的方式处理集合</li>
</ul>
<h4 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h4><p><img src="https://cdn-images-1.medium.com/max/1600/1*lq9uxKQpQZllnc-vNgzITg.jpeg" alt=""></p>
<p>Observable是一个具有一些特殊的特征的函数。它接收一个“观察者”（一个带有“next”，“error”和“complete”方法的对象）</p>
<ul>
<li>Observable支持在应用程序中的发布者和订阅者之间传递消息。</li>
<li>Observable很懒惰。它不会开始生成数据，直到您订阅它为止。</li>
<li>subscribe()返回一个订阅，消费者可以在unsubscribe()取消订阅并销毁生产者。</li>
<li>RxJS提供了许多可用于创建Observable的函数。这些函数可以简化创建可观察对象的过程</li>
</ul>
<h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h4><p>什么是Observer？Observer是Observable传递过来的数据的消费者。Observers由一个带有“next”，“error”和“complete”方法的对象构成，next、error、和 complete用来传递数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var observer = &#123;</span><br><span class="line">    next: x =&gt; console.log(&apos;Observable got a next value: &apos; + x),</span><br><span class="line">    error: err =&gt; console.log(&apos;Observable got and error: &apos; + err),</span><br><span class="line">    complete: () =&gt; console.log(&apos;Observable got a complete notification&apos;)</span><br><span class="line">&#125;;</span><br><span class="line">observable.subscribe(observer)</span><br></pre></td></tr></table></figure>
<h4 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h4><p>一个Subscription代表了一个一次性的资源，通常表示的是一个Observable执行。一个Subscription有一个重要的方法，unsubscribe，它不需要参数，仅仅是取消订阅释放资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const observable = interval(1000);</span><br><span class="line">const subscription = observable.subscribe(x =&gt; console.log(x));</span><br><span class="line">subscription.unsubscribe();</span><br></pre></td></tr></table></figure></p>
<p>Subscriptions也可以放在一起，这样会导致使用一个unsubscribe()将取消多个Observable执行，通过add、remove方法维护关联的Subscription</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const observable1 = interval(400);</span><br><span class="line">const observable2 = interval(300);</span><br><span class="line">const subscription = observable1.subscribe(x =&gt; console.log(&apos;first: &apos; + x));</span><br><span class="line">const childSubscription = observable2.subscribe(x =&gt; console.log(&apos;second: &apos; + x));</span><br><span class="line">subscription.add(childSubscription);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>
<h4 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h4><p><img src="https://cdn-images-1.medium.com/max/1600/1*pZ4lHOGYFBZUPHQJVpGrzg.jpeg" alt=""></p>
<ul>
<li><p>Subject是一种特殊类型的Observable，允许将值多播到许多观察者。虽然普通的Observable是单播的（每个订阅的Observer都拥有Observable的独立执行），但Subject是多播的</p>
</li>
<li><p><font color="#f00" size="2">每一个Subject都是一个observable可观察对象，</font>给定一个Subject后，你可以订阅它，提供的观察者将会正常的开始接收值。从观察者的角度来看，它不能判断一个可观察对象的执行时来自于单播的Observable还是来自于一个Subject.<br>在Subject的内部，subscribe并不调用一个新的发送值得执行。它仅仅在观察者注册表中注册给定的观察者，类似addEventListener的工作方式。</p>
</li>
<li><p><font color="#f00" size="2">每一个Subject都是一个Observer观察者对象。</font>它是一个拥有next()/error()/complete()方法的对象。要想Subject提供一个新的值，只需调用next()，它将会被多播至用来监听Subject的观察者。</p>
</li>
</ul>
<blockquote>
<p>Subject就是一个可观察对象，只不过可以被多播至多个观察者。同时Subject也类似于EventEmitter:维护者着众多事件监听器的注册表。</p>
</blockquote>
<h4 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h4><p>Subjects的一个变体是BehaviorSubject,其有”当前值”的概念。它储存着要发射给消费者的最新的值。无论何时一个新的观察者订阅它，都会立即接受到这个来自BehaviorSubject的”当前值”</p>
<blockquote>
<p>BehaviorSubject对于表示”随时间的值”是很有用的。举个例子，人的生日的事件流是一个Subject,然而人的年龄的流是一个BehaviorSubject。</p>
</blockquote>
<h4 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h4><p>一个ReplaySubject类似于一个BehaviorSubject，因为它可以发送一个过去的值(old values)给一个新的订阅者，但是它也可以记录可观察对象的一部分执行。</p>
<blockquote>
<p>一个ReplaySubject 从一个可观察对象的执行中记录多个值，并且可以重新发送给新的订阅者。</p>
</blockquote>
<h4 id="AsyncSubject"><a href="#AsyncSubject" class="headerlink" title="AsyncSubject"></a>AsyncSubject</h4><p>AsyncSubject是另一个变体，它只发送给观察者可观察对象执行的最新值，并且仅在执行结束时。AsyncSubject类似于last()操作符,因为它为了发送单一值而等待complete通知。</p>
<h4 id="常用的操作符"><a href="#常用的操作符" class="headerlink" title="常用的操作符"></a>常用的操作符</h4><p>每一个操作符都会产生一个新的Observable，不会对上游的Observable做任何修改，这完全符合函数式编程“数据不可变”的要求。pipe方法就是数据管道，会对数据流进行处理，可以添加操作符作为参数。</p>
<p><strong>interval</strong> 创建一个无限长度的周期性序列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interval(1000)  // 输出: 0,1,2...</span><br></pre></td></tr></table></figure></p>
<p><strong>timer</strong> 指定一个额外的参数来调节第一值的静默时长，第二个参数可选，若无则仅仅在规定的静默时长后输出一个值，然后结束序列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer(0,1000) // 输出:0,1,2...</span><br></pre></td></tr></table></figure></p>
<p><strong>from</strong> 可以将已有的数据转化为Observable,参数为iterable数据集对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from([1,2,3,4])   // 输出:1,2,3,4</span><br></pre></td></tr></table></figure></p>
<p><strong>of</strong> 不在同一个数据集中的多个来源的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">of([1,2,3])    //    [1,2,3]</span><br><span class="line">from([1,2,3])  //    1,2,3</span><br></pre></td></tr></table></figure></p>
<p><strong>fromEvent</strong> 将事件流转化为Observable,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const el = document.getElementById(&quot;btn&quot;); </span><br><span class="line">fromEvent(el,&quot;click&quot;);</span><br></pre></td></tr></table></figure></p>
<p><strong>delay</strong> 推迟   参数为数字或Date对象</p>
<p><strong>startWith</strong> 可以在源序列之前添加额外的元素</p>
<p><strong>map</strong> 对源序列进行变换，并返回新的序列(改变了源)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const source = of(1,2,3); // 输出： 1 2 3</span><br><span class="line">const target = source.map(x =&gt; x * 2);   //输出： 2 4 6</span><br></pre></td></tr></table></figure>
<p>concat<strong>有序</strong>拼接 ， merge<strong>无序</strong>拼接</p>
<p><img src="https://github.com/vernvn/hexoBlog/blob/master/decImg/concat.jpg?raw=true" alt=""></p>
<p><img src="https://github.com/vernvn/hexoBlog/blob/master/decImg/merge.jpg?raw=true" alt=""></p>
<p><strong>mergeMap</strong> 平坦化映射:首先将一个序列的各元素映射为序列，然后将各序列融合，参数是一个映射函数，返回值为序列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const source = fromEvent(document, &apos;click&apos;);</span><br><span class="line">    const target = source.pipe(</span><br><span class="line">    mapTo(1),</span><br><span class="line">    mergeMap(() =&gt; interval(1000).pipe(take(3)))</span><br><span class="line">    ).subscribe(res =&gt; console.log(res));   //输出： 0 1 2 0 ...</span><br></pre></td></tr></table></figure>
<p><strong>switchMap</strong>  与mergeMap的区别在于将最新的序列中的元素输出</p>
<p><strong>concatMap</strong>  将源序列各元素映射为序列，然后按顺序拼接 (与mergeMap的区别所在)</p>
<p><strong>filter</strong> 筛选源序列中满足条件的元素，并返回新的序列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const source = of(1,2,3,4,5); //序列： 1 2 3 4 5</span><br><span class="line">const target = source.filter(x =&gt; x &lt; 4)  //序列： 1 2 3</span><br></pre></td></tr></table></figure>
<p><strong>take</strong> 截取序列头部元素数量输出</p>
<p><strong>distinct</strong> 去重,并返回一个新序列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const source = of(1,2,2,3,4,2,1); //序列： 1 2 2 3 4 2 1</span><br><span class="line">const target = source.distinct(); //序列：1 2 3 4</span><br></pre></td></tr></table></figure></p>
<p><strong>distinctUntilChanged</strong> 相邻元素去重,并返回一个新序列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const source = of(1,2,2,3,4,2,1); //序列： 1 2 2 3 4 2 1</span><br><span class="line">const target = source.distinctUntilChanged(); //序列：1 2 3 4 2 1</span><br></pre></td></tr></table></figure></p>
<p><strong>debounce</strong>  去抖动,一段时间内只取最新数据作为一次发射数据，其他数据取消发射</p>
<p><strong>throttle</strong> (和debounce唯一区别是debounce取一段时间内最新的，而throttle忽略这段时间后，发现新值才发送, 通俗讲，都设定一个时间周期，持续触发事件，throttle为每到时间周期便会触发一次，bebounce为触发周期小于设定时间周期不予事件触发）</p>
<p><strong>zip</strong> 支持可变数量的序列作为参数，最后一个参数应当是一个组合函数， 其返回值将作为目标序列的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const source1 = of(1, 2, 3);</span><br><span class="line">const source2 = of(4, 5, 6);</span><br><span class="line">const target = zip(source1, source2).subscribe(([val1, val2]) =&gt; &#123;      // 序列： 1-4  2-5  3-6</span><br><span class="line">    console.log(val1 + &apos;-&apos; + val2)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>forkJoin</strong>  将多个序列的最后一个元素组合为一个数组后，作为目标序列的唯一元素,一个常见用例是在页面加载时你希望发起多个请求，并在所有请求都响应后再采取行动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const source1 = of(1, 2, 3);</span><br><span class="line">const source2 = of(4, 5, 6);</span><br><span class="line">const target = forkJoin(source1, source2).subscribe(([val1, val2]) =&gt; &#123;   // 序列： 3-6</span><br><span class="line">    console.log(val1 + &apos;-&apos; + val2)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>combineLatest</strong> 将多个序列的最后一个元素，使用组合函数构成目标序列的一个新元素</p>
<pre><code>const setHtml = id =&gt; val =&gt; document.getElementById(id).innerHTML = val;
const addOneClick$ = id =&gt; fromEvent(document.getElementById(id), &apos;click&apos;)
    .pipe(
        mapTo(1),
        startWith(0),
        scan((acc, curr) =&gt; acc + curr, 0),
        tap(setHtml(`${id}Total`))
    );
    const combineTotal$ = combineLatest(
        addOneClick$(&apos;red&apos;),
        addOneClick$(&apos;black&apos;)
    ).pipe(
        map(([val1, val2]) =&gt; val1 + val2)
    )
    .subscribe(setHtml(&apos;total&apos;));
</code></pre><p>map用于对自身对象数值进行映射，将发射对象转换成另一个发射对象发射， <font color="#f00" size="2">返回一个包含映射结果的Observable对象</font> 而mergeMap是把自身对象里的数值进行映射并转换成一个新的Observable对象.<font color="#f00" size="2">返回一个内部元素为映射的Observable对象的Observable对象</font></p>
<h4 id="marble-diagrams"><a href="#marble-diagrams" class="headerlink" title="marble diagrams"></a>marble diagrams</h4><p>为了解释operators是如何工作的，光是文本解释是不够的。许多operators和时间有关，它们可能会延迟执行，例如，throttle等。图标往往能够比文字更多表达清楚。Marble Diagrams能够可视化的表现出operators是如何工作的，包括输入的Observable(s)，operator和它的参数，以及输出的Observable.  <a href="http://rxmarbles.com/" target="_blank" rel="noopener">Marble diagrams</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/01/git新的指令/" itemprop="url">
                  git新的指令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2018-03-01T14:22:58+08:00" content="2018-03-01">
              2018-03-01
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="使用Git管理项目总结"><a href="#使用Git管理项目总结" class="headerlink" title="使用Git管理项目总结"></a>使用Git管理项目总结</h2><h4 id="导语："><a href="#导语：" class="headerlink" title="导语："></a>导语：</h4><blockquote>
<p>使用git已经一段时间了，总结一下我的理解关于使用git进行团队协作开发的流程。首先master分支作为主分支应该承担版本发布的责任。开发任务应该在develop分支上。不论当前分支是从哪个分支分离开来，都需要合并到那个分支上。根据需求的不同以及开发人员的指派，应该创建一系列feature-<em>分支，一旦开发完毕后，进行代码的review，确认无误后合并分支到develop分支上，之后删除相应的feature-</em>分支。在进行版本的发布前，需要从develop分支分离并创建对应的预发布分支，进行当前版本的测试，完成后，需要合并进develop分支和master分支，之后切换分支到master分支，生成版本节点标签并删除对应预发布分支，进行版本的发布。如果遇到bug问题，需要从master分支分离出修复bug分支，修复完成后合并进develop和master分支，之后切换分支到master分支，生成节点标签并删除对应bug分支。</p>
</blockquote>
<h3 id="一般的git命令已经用的很多了，今天记录几个很重要但是我自己在日常工作中很少使用的几个命令。"><a href="#一般的git命令已经用的很多了，今天记录几个很重要但是我自己在日常工作中很少使用的几个命令。" class="headerlink" title="一般的git命令已经用的很多了，今天记录几个很重要但是我自己在日常工作中很少使用的几个命令。"></a>一般的git命令已经用的很多了，今天记录几个很重要但是我自己在日常工作中很少使用的几个命令。</h3><h4 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h4><p>正在feature分支开发，master分支报了一个bug错误，此时需要即时修复bug,但是开发还没有完成，此时提交不太友好。Git提供的stash功能正好适用这个场景。可以把当前工作储存起来，处理完事情后继续工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash    // order code</span><br><span class="line">Saved working directory and index state WIP on feature-**: 4966d2d bingo</span><br></pre></td></tr></table></figure>
<p>此时git status查看工作区是干净的。此时可以创建临时分支处理bug。处理完bug后切换回feature-分支继续开发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list // order code</span><br><span class="line">stash@&#123;0&#125;: WIP on feature-**: 4966d2d bingo</span><br></pre></td></tr></table></figure>
<p>工作现场存在，现在需要恢复现场。两个办法：</p>
<ul>
<li><p>git stash apply &amp;&amp; git stash drop  // 前者恢复现场不删除stash内容，后者为补充删除stash内容</p>
</li>
<li><p>git stash pop  // 恢复现场同时删除stash内容</p>
</li>
</ul>
<p>如果多次stash的情况下，可以git stash list查看，然后恢复指定的stash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply stash@&#123;0&#125;  // 括号内为指定stash内容</span><br></pre></td></tr></table></figure>
<h4 id="–no-ff"><a href="#–no-ff" class="headerlink" title="–no-ff"></a>–no-ff</h4><p>这个参数的意思是保留原分支记录，默认情况下，执行fast-forward merge,直接将master分支指向develop分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff develop // 把develop合并进master分支</span><br></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/Kt1rngH.png" alt="fast-forward"></p>
<p><img src="http://i.imgur.com/rDt0UhJ.png" alt="--no-ff"></p>
<h4 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h4><p>比较两次修改的差异</p>
<h3 id="工作区-VS-暂存区"><a href="#工作区-VS-暂存区" class="headerlink" title="工作区 VS 暂存区"></a>工作区 VS 暂存区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git diff &lt;filename&gt;  </span><br><span class="line"></span><br><span class="line">$ git diff &lt;branch&gt; &lt;filename&gt; // 和另一分支的区别</span><br></pre></td></tr></table></figure>
<h3 id="暂存区-VS-Git仓库"><a href="#暂存区-VS-Git仓库" class="headerlink" title="暂存区 VS Git仓库"></a>暂存区 VS Git仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached &lt;filename&gt;  </span><br><span class="line"></span><br><span class="line">$ git diff --cached &lt;commit&gt; &lt;filename&gt; // 和指定commit的区别</span><br></pre></td></tr></table></figure>
<h3 id="工作目录-VS-Git仓库"><a href="#工作目录-VS-Git仓库" class="headerlink" title="工作目录 VS Git仓库"></a>工作目录 VS Git仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff &lt;commit&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Git仓库-VS-Git仓库"><a href="#Git仓库-VS-Git仓库" class="headerlink" title="Git仓库 VS Git仓库"></a>Git仓库 VS Git仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff &lt;commit&gt; &lt;commit&gt;  // git仓库任意两次commit的差别</span><br></pre></td></tr></table></figure>
<h2 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h2><p>以上命令可以不指定<filename>,则对应全部文件操作<br>以上命令涉及git仓库对比的，均可指定commit版本</filename></p>
<ul>
<li><p>HEAD 最近一次commit</p>
</li>
<li><p>HEAD^ 上次提交</p>
</li>
<li><p>HEAD～100 上100次提交</p>
</li>
<li><p>每次提交产生的哈希值</p>
</li>
</ul>
<h4 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h4><h3 id="将某个分支上的所有提交记录移植到另一个分支上，清除不必要的提交记录"><a href="#将某个分支上的所有提交记录移植到另一个分支上，清除不必要的提交记录" class="headerlink" title="将某个分支上的所有提交记录移植到另一个分支上，清除不必要的提交记录"></a>将某个分支上的所有提交记录移植到另一个分支上，清除不必要的提交记录</h3><h3 id="永远不要rebase一个已经分享的分支"><a href="#永远不要rebase一个已经分享的分支" class="headerlink" title="永远不要rebase一个已经分享的分支"></a>永远不要rebase一个已经分享的分支</h3><p>一图以意之</p>
<p><img src="https://sfault-image.b0.upaiyun.com/206/854/2068544494-5783bdd025d80_articlex" alt="0"></p>
<h3 id="以下是一个例子讲解rebase的作用"><a href="#以下是一个例子讲解rebase的作用" class="headerlink" title="以下是一个例子讲解rebase的作用"></a>以下是一个例子讲解rebase的作用</h3><p><img src="https://backlog.com/git-tutorial/cn/img/post/stepup/capture_stepup2_8_1_1.png" alt="1"></p>
<p>切换到issue3分支后，对master执行rebase,解决冲突</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout issue3</span><br><span class="line">$ git rebase master</span><br></pre></td></tr></table></figure>
<p>冲突解决后不需要commit命令进行提交，而是执行rebase命令的continue选项或着abort选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git rebase --continue  /  --abort</span><br></pre></td></tr></table></figure>
<p><img src="https://backlog.com/git-tutorial/cn/img/post/stepup/capture_stepup2_8_1.png" alt="2"></p>
<p>master分支的issue3分支可以fast-forward了。切换到master分支执行合并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge issue3</span><br></pre></td></tr></table></figure>
<p>rebase的内容与merge的效果是一样的，但是历史记录会简洁</p>
<p><img src="https://backlog.com/git-tutorial/cn/img/post/stepup/capture_stepup2_8_2.png" alt="3"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/08/ng2-translate/" itemprop="url">
                  ng2-translate
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2018-02-08T15:56:40+08:00" content="2018-02-08">
              2018-02-08
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="i18n国际化，演示angular控件ng2-translate"><a href="#i18n国际化，演示angular控件ng2-translate" class="headerlink" title="i18n国际化，演示angular控件ng2-translate"></a>i18n国际化，演示angular控件ng2-translate</h2><p>app.module</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; TranslateModule, TranslateLoader, TranslateStaticLoader &#125; from &apos;ng2-translate&apos;;</span><br><span class="line">//..</span><br><span class="line">export function createTranslateStaticLoader(http: Http) &#123;</span><br><span class="line">    return new TranslateStaticLoader(http, &apos;./assets/i18n&apos;, &apos;.json&apos;);   // 发送请求，拿到i18n文件夹下的json后缀文件</span><br><span class="line">&#125;</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">    imports: [</span><br><span class="line">        TranslateModule.forRoot(&#123;</span><br><span class="line">            provide: TranslateLoader,</span><br><span class="line">            useFactory: createTranslateStaticLoader,</span><br><span class="line">            deps: [Http]</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>app.component</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import &#123; TranslateService &#125; from &apos;ng2-translate&apos;;</span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;app-root&apos;</span><br><span class="line">&#125;)</span><br><span class="line">export class AppComponent &#123;</span><br><span class="line">    constructor(</span><br><span class="line">        private translate: TranslateService</span><br><span class="line">    ) &#123;&#125;</span><br><span class="line">    ngOnInit() &#123;</span><br><span class="line">        this.translate.addLangs([&apos;zh&apos;, &apos;en&apos;]);</span><br><span class="line">        this.translate.setDefaultLang(&apos;zh&apos;);</span><br><span class="line">        const browserLang = this.translate.getBrowserLang();</span><br><span class="line">        this.translate.use(browserLang.match(/zh|en/) ? browserLang : &apos;zh&apos; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模版使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; word | trnaslate &#125;&#125;&lt;p&gt;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/08/NgZone/" itemprop="url">
                  NgZone
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2018-02-08T10:22:09+08:00" content="2018-02-08">
              2018-02-08
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p></p><h4 align="center">利用Angular本身ChangeDetectionStrategyAPI改变检查策略脱离变化检测器，即减少不必要的检测来提高应用的性能<p></p>
<h4>

<h3 id="zone是什么"><a href="#zone是什么" class="headerlink" title="zone是什么"></a>zone是什么</h3><p>对浏览器的异步api做了封装，并对外发出通知何时开始何时结束，angular在得到异步事件结束的通知后，执行变化检查。</p>
<h3 id="zone性能优化的重点在哪"><a href="#zone性能优化的重点在哪" class="headerlink" title="zone性能优化的重点在哪"></a>zone性能优化的重点在哪</h3><p>精确的控制哪些异步事件是应该在angular的zone以内运行的，哪些是应该在angular的zone之外运行的。显然在angular的zone之外运行的事件是不会进行变化检测的，减少不必要的变化检测则实现了性能上的优化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NgZone &#125; from &apos;@angular/core&apos;;</span><br><span class="line">constructor(private zone: NgZone) &#123;&#125;</span><br><span class="line">mouseDown(event) &#123;</span><br><span class="line">    this.zone.runOutsideAngular(() =&gt; &#123;</span><br><span class="line">        window.document.addEventListener(&apos;mouseover&apos;, this.mouseMove.bind(this));  // 此处应该尽量避免直接操纵dom,应该利用底层封装api(renderer, renderer2)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NgZone可以让代码继续回到zone里运行，会再次触发anuglar的变化检测，调用NgZone.run();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mouseUp(event) &#123;</span><br><span class="line">    this.zone.run(() =&gt; &#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;)</span><br><span class="line">    window.docuemnt.removeEventListener(&apos;mousemove&apos;, this.mouseMove);  // 移除mousemove绑定的回调</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>zone.js为javascript提供执行上下文，可以在异步任务之间进行持久性传递。采用了猴子补丁将javascript中的异步任务包裹了一层。使得异步任务运行在zone的上下文中。每一个异步任务都被当作一个task,并在task基础上提供钩子函数。</p>
<ul>
<li><p>onZoneCreated: 产生一个新的zone对象时的钩子函数，zone.fork也会产生一个继承基类zone的新zone,形成一个独立的zone上下文</p>
</li>
<li><p>beforeTask: zone Task 执行前的钩子函数</p>
</li>
<li><p>afterTask</p>
</li>
<li><p>onError: zone运行Task时候的异常钩子函数</p>
</li>
</ul>
<p>并且对大多数异步事件进行了包裹封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const log = (phase) =&gt; &#123;</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">        console.log(&apos;i am in zone.js&apos; + phase + &apos;!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">zone.fork(&#123;</span><br><span class="line">    onZoneCreated: log(&apos;onZoneCreated&apos;),</span><br><span class="line">    beforeTask: log(&apos;beforeTask&apos;),</span><br><span class="line">    afterTask: log(&apos;afterTask&apos;)</span><br><span class="line">&#125;).run(() =&gt; &#123;</span><br><span class="line">    const methodLog = (func) =&gt; &#123;</span><br><span class="line">        return () =&gt; &#123;</span><br><span class="line">            console.log(&apos;i am from&apos; + func + &apos;function&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    foo = methodLog(&apos;foo&apos;),</span><br><span class="line">    bar = methodLog(&apos;bar&apos;),</span><br><span class="line">    baz = () =&gt; &#123;</span><br><span class="line">        setTimeout( methodLog(&apos;baz in setTimeout&apos;), 0)</span><br><span class="line">    &#125;;</span><br><span class="line">    foo(); </span><br><span class="line">    baz();</span><br><span class="line">    bar();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">i am in zone.js beforeTask;</span><br><span class="line">i am from foo function;</span><br><span class="line">i am from bar function;</span><br><span class="line">i am in zone.js afterTask;</span><br><span class="line"></span><br><span class="line">i am in zone.js onZoneCreated;</span><br><span class="line">i am in zone.js beforeTask;</span><br><span class="line">i am from baz in setTimeout function;</span><br><span class="line">i am in zone.js afterTask;</span><br></pre></td></tr></table></figure>
<p>上述例子中将run方法分为了两个task，分别为同步task和异步task。fork方法会产生一个继承根zone的子类，并在fork函数中配置特定的钩子函数，形成独立的zone上下文，而run方法则是启动执行业务代码的对外接口。</p>
<h3 id="使用Observable优化脏检查"><a href="#使用Observable优化脏检查" class="headerlink" title="使用Observable优化脏检查"></a>使用Observable优化脏检查</h3><p>使用OnPush的检查策略，如果修改了对象内部的值，此时不会进行脏检查，不会进行视图更新。此时可以选择Observable对象，通过手动调用markForCheck()方法进行优化，当前组件到根组件的路径上的所有组件都会进行变化检测。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    ...,</span><br><span class="line">    changeDetection: ChangeDetectionStrategy.OnPush</span><br><span class="line">&#125;)</span><br><span class="line">export class TodosComponent implements OnInit&#123;</span><br><span class="line">    @Input() todos: Observable&lt;Todo[]&gt;;</span><br><span class="line">    constructor(private cd: ChangeDetectorRef) &#123;&#125;</span><br><span class="line">    ngOnInit() &#123;</span><br><span class="line">        this.todos.subscribe(todos =&gt; &#123;</span><br><span class="line">            业务代码；</span><br><span class="line">            this.cd.markForCheck();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h4></h4>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/07/everyNote/" itemprop="url">
                  EveryNote
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2018-02-07T11:09:10+08:00" content="2018-02-07">
              2018-02-07
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="记录每天学习中发现的知识点"><a href="#记录每天学习中发现的知识点" class="headerlink" title="记录每天学习中发现的知识点"></a>记录每天学习中发现的知识点</h2><font face="黑体" color="#f00" size="4">总结TemplateRef与ViewContainerRef</font>

<h4 id="TemplateRef-用于表示内嵌的template模板元素，可以创建内嵌视图（createEmbeddedView）-可以访问到封装后的nativeElement-模板经过渲染后会替换成comment元素"><a href="#TemplateRef-用于表示内嵌的template模板元素，可以创建内嵌视图（createEmbeddedView）-可以访问到封装后的nativeElement-模板经过渲染后会替换成comment元素" class="headerlink" title="TemplateRef: 用于表示内嵌的template模板元素，可以创建内嵌视图（createEmbeddedView）,可以访问到封装后的nativeElement,模板经过渲染后会替换成comment元素"></a>TemplateRef: 用于表示内嵌的template模板元素，可以创建内嵌视图（createEmbeddedView）,可以访问到封装后的nativeElement,模板经过渲染后会替换成comment元素</h4><h4 id="ViewContainerRef-用于表示一个视图容器，可添加一或多个视图，通过ViewContainerRef实例，可以基于TemplateRef创建内嵌视图，并指定插入位置，主要创建管理内嵌视图"><a href="#ViewContainerRef-用于表示一个视图容器，可添加一或多个视图，通过ViewContainerRef实例，可以基于TemplateRef创建内嵌视图，并指定插入位置，主要创建管理内嵌视图" class="headerlink" title="ViewContainerRef: 用于表示一个视图容器，可添加一或多个视图，通过ViewContainerRef实例，可以基于TemplateRef创建内嵌视图，并指定插入位置，主要创建管理内嵌视图"></a>ViewContainerRef: 用于表示一个视图容器，可添加一或多个视图，通过ViewContainerRef实例，可以基于TemplateRef创建内嵌视图，并指定插入位置，主要创建管理内嵌视图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template #tpl&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">@ViewChild(&apos;tpl&apos;) tplRef: TemplateRef&lt;any&gt;;</span><br><span class="line">@ViewChild(&apos;tpl&apos;, &#123; read: ViewContainerRef &#125;) tplVcRef: ViewContainerRef;</span><br><span class="line">ngAfterViewInit()&#123;</span><br><span class="line">    this.tplVcRef.createEmbeddedView(this.tplRef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意：-ViewChild属性装饰器若未设置read属性，默认返回ElementRef对象实例"><a href="#注意：-ViewChild属性装饰器若未设置read属性，默认返回ElementRef对象实例" class="headerlink" title="注意：@ViewChild属性装饰器若未设置read属性，默认返回ElementRef对象实例"></a>注意：@ViewChild属性装饰器若未设置read属性，默认返回ElementRef对象实例</h3><font face="黑体" color="#f00" size="4">指令的一般应用场景</font>

<h4 id="分类：内置指令，-自定义指令"><a href="#分类：内置指令，-自定义指令" class="headerlink" title="分类：内置指令， 自定义指令"></a>分类：内置指令， 自定义指令</h4><h4 id="主要考虑自定义指令的属性指令与结构指令"><a href="#主要考虑自定义指令的属性指令与结构指令" class="headerlink" title="主要考虑自定义指令的属性指令与结构指令"></a>主要考虑自定义指令的属性指令与结构指令</h4><h3 id="自定义属性指令实现简写"><a href="#自定义属性指令实现简写" class="headerlink" title="自定义属性指令实现简写"></a>自定义属性指令实现简写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Directive(&#123;</span><br><span class="line">    selector: &apos;[directivename]&apos;  // 这里定义的selector为什么使用中括号，是为了结合input装饰器获取属性值</span><br><span class="line">&#125;)</span><br><span class="line">export class SomeDirective &#123;</span><br><span class="line">    private _default = &apos;[someValue]&apos; // 旨在指令类内部定义默认值</span><br><span class="line">    @Input(directivename) directiveAnotherName;  // 输入属性</span><br><span class="line">    constructor(private el: ElementRef, private renderer: Renderer)&#123; // 引用类实例化，其中renderer对象提供许多api供渲染元素</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @HostListener(eventName) eventName()&#123;  // 监听宿主元素事件</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &lt;h1 [changeColor]=&quot;&apos;red&apos;&quot;&gt;&lt;/h1&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义结构指令是实现简写"><a href="#自定义结构指令是实现简写" class="headerlink" title="自定义结构指令是实现简写"></a>自定义结构指令是实现简写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Directive(&#123;</span><br><span class="line">    selector: &apos;[directivename]&apos;  // 这里定义的selector为什么使用中括号，是为了结合input装饰器获取属性值</span><br><span class="line">&#125;)</span><br><span class="line">export class SomeDirective &#123;</span><br><span class="line">    @Input(directivename)  </span><br><span class="line">    set condition(newCondition: boolean) &#123;  // 这里用了getter、setter存取器, 进行属性值的动态监听</span><br><span class="line">        if(newCondition)&#123;</span><br><span class="line">            this.tplVc.createEmbeddedView(this.tpl); // 创建内嵌视图,可以设置第二个参数&#123;$implicit: somevalue&#125;, 则angular提供了let模板语法，允许在生成的上下文是定义和传递</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            this.tplVc.clear();  // 清除内嵌视图</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(private tpf: TemplateRef, private tplVc: VireContainerRef)&#123; // 引用类实例化，用于创建内嵌视图</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &lt;h1 *structureDirective = true&gt;&lt;/h1&gt; // 这里用了angular结构性指令的语法糖，原理同*ngIf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结以上属性指令与结构指令"><a href="#总结以上属性指令与结构指令" class="headerlink" title="总结以上属性指令与结构指令"></a>总结以上属性指令与结构指令</h3><p><em>1 ElementRef与Renderer等的作用：支持跨平台，从底层封住，统一了api接口;
</em>2 TemplateRef与ViewContainerRef的作用： 前面有总结过他俩的作用;<br>*3 angular2中指令与组件的关系：组件继承与指令，并扩展了与视图的关系</p>
<h3 id="自定义debounceClick指令"><a href="#自定义debounceClick指令" class="headerlink" title="自定义debounceClick指令"></a>自定义debounceClick指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Directive(&#123;</span><br><span class="line">    selector: &apos;[directiveDebounceClick]&apos;</span><br><span class="line">&#125;)</span><br><span class="line">export class SomeDirective &#123;</span><br><span class="line">    @Input(&apos;debounceTime&apos;) debounceTime: string;</span><br><span class="line">    @Output(&apos;debounceClick&apos;)  debounceClick = new EventEmitter();</span><br><span class="line">    private clicks = new Subject&lt;any&gt;();  // 定义subject处理点击事件</span><br><span class="line">    constructor()&#123; &#125;</span><br><span class="line">    @HostListener(&apos;click&apos;,[&apos;$event&apos;])  // 监听宿主元素上的点击事件，第二个参数用于将事件传递给eventClick方法</span><br><span class="line">    eventClick(event)&#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">        event.stopPropagation();  // 阻止事件默认行为与事件冒泡</span><br><span class="line">        this.clicks.next(event);  // 发送新值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngOnInit()&#123;</span><br><span class="line">        this.clicks.debounceTime(this.debounceTime) // 去抖动,时间自定义</span><br><span class="line">        .subscribe(x =&gt; this.debounceClick.emit(x)); // 调用emit方法发出事件</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &lt;button directiveDebounceClick [debounceTime] =&apos;300&apos; (debounceClick)=&quot;log($event)&quot;&gt;&lt;/button&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font face="黑体" color="#f00" size="4">ng-content包装器</font>

<h4 id="如果你尝试在-Angular-中编写可重复使用的组件，则可能会接触到内容投射的概念"><a href="#如果你尝试在-Angular-中编写可重复使用的组件，则可能会接触到内容投射的概念" class="headerlink" title="如果你尝试在 Angular 中编写可重复使用的组件，则可能会接触到内容投射的概念:"></a>如果你尝试在 Angular 中编写可重复使用的组件，则可能会接触到内容投射的概念:<ng-content></ng-content></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;wrapper&apos;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">      &lt;ng-content&gt;&lt;/ng-content&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line">class Wrapper &#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;wrapper&apos;,</span><br><span class="line">  template: `</span><br><span class="line">  &lt;div class=&quot;box red&quot;&gt;</span><br><span class="line">    &lt;ng-content&gt;&lt;/ng-content&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;box blue&quot;&gt;</span><br><span class="line">    &lt;ng-content select=&quot;counter&quot;&gt;&lt;/ng-content&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  `,</span><br><span class="line">  styles: [`</span><br><span class="line">    .red &#123;background: red;&#125;</span><br><span class="line">    .blue &#123;background: blue;&#125;</span><br><span class="line">  `]</span><br><span class="line">&#125;)</span><br><span class="line">export class Wrapper &#123; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="将包装器的不同子项投影到模板的不同部分。-支持一个-select-属性，可以让你在特定的地方投射具体的内容。该属性支持-CSS-选择器（my-element，-my-class，-my-attribute-，…）来匹配你想要的内容。如果-ng-content-上没有设置-select-属性，它将接收全部内容，或接收不匹配任何其他-ng-content-元素的内容。"><a href="#将包装器的不同子项投影到模板的不同部分。-支持一个-select-属性，可以让你在特定的地方投射具体的内容。该属性支持-CSS-选择器（my-element，-my-class，-my-attribute-，…）来匹配你想要的内容。如果-ng-content-上没有设置-select-属性，它将接收全部内容，或接收不匹配任何其他-ng-content-元素的内容。" class="headerlink" title="将包装器的不同子项投影到模板的不同部分。 支持一个 select 属性，可以让你在特定的地方投射具体的内容。该属性支持 CSS 选择器（my-element，.my-class，[my-attribute]，…）来匹配你想要的内容。如果 ng-content 上没有设置 select 属性，它将接收全部内容，或接收不匹配任何其他 ng-content 元素的内容。"></a>将包装器的不同子项投影到模板的不同部分。<ng-content> 支持一个 select 属性，可以让你在特定的地方投射具体的内容。该属性支持 CSS 选择器（my-element，.my-class，[my-attribute]，…）来匹配你想要的内容。如果 ng-content 上没有设置 select 属性，它将接收全部内容，或接收不匹配任何其他 ng-content 元素的内容。</ng-content></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;wrapper&gt;</span><br><span class="line">  &lt;span&gt;This is not a counter&lt;/span&gt;</span><br><span class="line">  &lt;counter&gt;&lt;/counter&gt;</span><br><span class="line">&lt;/wrapper&gt;</span><br></pre></td></tr></table></figure>
<h4 id="counter组件被正确投影到第二个蓝色框中，而-span-元素最终会在全部红色框中。"><a href="#counter组件被正确投影到第二个蓝色框中，而-span-元素最终会在全部红色框中。" class="headerlink" title="counter组件被正确投影到第二个蓝色框中，而 span 元素最终会在全部红色框中。"></a>counter组件被正确投影到第二个蓝色框中，而 span 元素最终会在全部红色框中。</h4><h2 id="ngProjectAs"><a href="#ngProjectAs" class="headerlink" title="ngProjectAs"></a>ngProjectAs</h2><h4 id="内部组件会被隐藏在另一个更大的组件中。你只需要将其包装在额外的容器中即可应用-ngIf-或-ngSwitch。无论什么原因，通常情况下，你的内部组件不是包装器的直接子节点。所以需要使用ngProjectAs属性，将它用于指定的元素上。"><a href="#内部组件会被隐藏在另一个更大的组件中。你只需要将其包装在额外的容器中即可应用-ngIf-或-ngSwitch。无论什么原因，通常情况下，你的内部组件不是包装器的直接子节点。所以需要使用ngProjectAs属性，将它用于指定的元素上。" class="headerlink" title="内部组件会被隐藏在另一个更大的组件中。你只需要将其包装在额外的容器中即可应用 ngIf 或 ngSwitch。无论什么原因，通常情况下，你的内部组件不是包装器的直接子节点。所以需要使用ngProjectAs属性，将它用于指定的元素上。"></a>内部组件会被隐藏在另一个更大的组件中。你只需要将其包装在额外的容器中即可应用 ngIf 或 ngSwitch。无论什么原因，通常情况下，你的内部组件不是包装器的直接子节点。所以需要使用ngProjectAs属性，将它用于指定的元素上。</h4><font face="黑体" color="#f00" size="3">表单自定义验证规则</font>

<h4 id="举例：邮件匹配"><a href="#举例：邮件匹配" class="headerlink" title="举例：邮件匹配"></a>举例：邮件匹配</h4><p>定义用户类型接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export interface User &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    account: &#123;</span><br><span class="line">        email: string;</span><br><span class="line">        confirm: string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>邮件匹配规则函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export const emailMatcher = (control: AbstractControl): &#123;[key: string]: boolean&#125; =&gt; &#123;</span><br><span class="line">   const email = control.get(&apos;email&apos;);</span><br><span class="line">   const confirm = control.get(&apos;confirm&apos;);</span><br><span class="line">   if (!email || !confirm)&#123;</span><br><span class="line">       return;</span><br><span class="line">   &#125;</span><br><span class="line">   return email.value === confirm.value ? null : &#123; nomatch: true &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>表单模版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, OnInit&#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; FormBuilder, FormGroup, Validators &#125; from &apos;@angular/forms&apos;;</span><br><span class="line">import &#123; emailMatcher &#125; from &apos;./email-matcher&apos;;</span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;signup=form&apos;,</span><br><span class="line">    template: `</span><br><span class="line">        &lt;form novalidate (ngSubmit)=&quot;onSubmit(user)&quot; [formGroup]=&quot;user&quot;&gt;</span><br><span class="line">            &lt;label&gt;</span><br><span class="line">               name...</span><br><span class="line">            &lt;/label&gt;</span><br><span class="line">            &lt;div *ngIf=&quot;user.get(&apos;name&apos;).touched &amp;&amp; user.get(&apos;name&apos;).hasError(&apos;required&apos;)&quot;&gt;</span><br><span class="line">                name is required</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div formGroupName = &quot;account&quot;&gt;</span><br><span class="line">                &lt;label&gt;</span><br><span class="line">                    &lt;span&gt;Email address&lt;/span&gt;</span><br><span class="line">                    &lt;input type=&quot;email&quot; placeholder=&quot;Your email address&quot; formControlName=&quot;email&quot;&gt;</span><br><span class="line">                &lt;/label&gt;</span><br><span class="line">                &lt;label&gt;</span><br><span class="line">                    &lt;span&gt;Confirm address&lt;/span&gt;</span><br><span class="line">                    &lt;input type=&quot;email&quot; placeholder=&quot;Confirm your email address&quot; formControlName=&quot;confirm&quot;&gt;</span><br><span class="line">                &lt;/label&gt;</span><br><span class="line">                &lt;div *ngIf=&quot;user.get(&apos;account&apos;).touched &amp;&amp; user.get(&apos;name&apos;).hasError(&apos;nomatch&apos;)&quot;&gt;</span><br><span class="line">                    name is required</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;button type=&quot;submit&quot; [disabled]=&quot;user.invalid&quot;&gt;Sign up&lt;/button&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br><span class="line">export class SignUpFormCOmponent implements OnInit &#123;</span><br><span class="line">    user: FormGroup;</span><br><span class="line">    constructor(private fb: FormBuilder)&#123;&#125;</span><br><span class="line">    ngOnInit() &#123;</span><br><span class="line">        this.user = this.fb.group(&#123;</span><br><span class="line">            name: [&apos;&apos;, Validators.required],</span><br><span class="line">            account: this.fb.group(&#123;</span><br><span class="line">                email: [&apos;&apos;, Validators.required],</span><br><span class="line">                confirm: [&apos;&apos;, Validators.rquired],</span><br><span class="line">            &#125;, &#123;validator: emailMatcher&#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<font face="黑体" color="#f00" size="3">对比创建表单自定义验证指令</font>

<p>模版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name=&quot;password&quot; formControlName=&quot;password&quot; validateEqual=&quot;password&quot;&gt;</span><br><span class="line">&lt;input name=&quot;confirmpassword&quot; formControlName=&quot;confirmpassword&quot; validateEqual=&quot;password&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>validateEqual指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Directive, forwardRef, Attribute &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; Validator, AbstractControl, NG_VALIDATORS &#125; from &apos;@angular/forms&apos;;</span><br><span class="line">@DIrective(&#123;</span><br><span class="line">    selector: &apos;[validateEqual][formControlName], [validateEqual][formControl],[validateEqual][ngModel]&apos; ,</span><br><span class="line">    providers: [&#123;</span><br><span class="line">        provide: NG_VALIDATORS,</span><br><span class="line">        useExisting: forward(() =&gt; EqualValidator),</span><br><span class="line">        multi: true</span><br><span class="line">    &#125;]</span><br><span class="line">    扩展</span><br><span class="line">&#125;)</span><br><span class="line">export class EqualValidator implements Validator &#123;</span><br><span class="line">    constructor(@Attribute(&apos;validateEqual&apos;) public validateEqual: string)&#123;&#125;</span><br><span class="line">    validate(control: AbstractControl): &#123; [key:string]: boolean &#125; &#123;</span><br><span class="line">        let v  = control.value;  使用指令的控件自身值: confirmpassword</span><br><span class="line">        let e  = control.root.get(this.validateEqual);  指令指定的控件: passwordControl;</span><br><span class="line">        if (e &amp;&amp; v !== e.value) &#123;</span><br><span class="line">            return &#123; validateEqual: false&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="验证器添加到指定控件，造成只有该控件数值变化才会进行验证，先输入confirmPassword造成验证器失效，需要给验证器添加reverse属性"><a href="#验证器添加到指定控件，造成只有该控件数值变化才会进行验证，先输入confirmPassword造成验证器失效，需要给验证器添加reverse属性" class="headerlink" title="验证器添加到指定控件，造成只有该控件数值变化才会进行验证，先输入confirmPassword造成验证器失效，需要给验证器添加reverse属性"></a>验证器添加到指定控件，造成只有该控件数值变化才会进行验证，先输入confirmPassword造成验证器失效，需要给验证器添加reverse属性</h4><h3 id="Forward-Reference"><a href="#Forward-Reference" class="headerlink" title="Forward Reference"></a>Forward Reference</h3><h4 id="不论es6、es7、还是ts作为开发语言，现阶段最终都会编译为es5的代码。es5中只有function并没有class。造成js代码编译阶段只有变量声明和函数声明会自动提升，而函数表达式并不会自动提升。所以要解决此问题可以使用Angular2提供的forward-reference特性进行解决-Buffer顺序在Socket之前声明也可以，但是angular项目中模块组件化开发确认注入依赖的顺序性会带来更大负担-。"><a href="#不论es6、es7、还是ts作为开发语言，现阶段最终都会编译为es5的代码。es5中只有function并没有class。造成js代码编译阶段只有变量声明和函数声明会自动提升，而函数表达式并不会自动提升。所以要解决此问题可以使用Angular2提供的forward-reference特性进行解决-Buffer顺序在Socket之前声明也可以，但是angular项目中模块组件化开发确认注入依赖的顺序性会带来更大负担-。" class="headerlink" title="不论es6、es7、还是ts作为开发语言，现阶段最终都会编译为es5的代码。es5中只有function并没有class。造成js代码编译阶段只有变量声明和函数声明会自动提升，而函数表达式并不会自动提升。所以要解决此问题可以使用Angular2提供的forward reference特性进行解决(Buffer顺序在Socket之前声明也可以，但是angular项目中模块组件化开发确认注入依赖的顺序性会带来更大负担)。"></a>不论es6、es7、还是ts作为开发语言，现阶段最终都会编译为es5的代码。es5中只有function并没有class。造成js代码编译阶段只有变量声明和函数声明会自动提升，而函数表达式并不会自动提升。所以要解决此问题可以使用Angular2提供的forward reference特性进行解决(Buffer顺序在Socket之前声明也可以，但是angular项目中模块组件化开发确认注入依赖的顺序性会带来更大负担)。</h4><font face="黑体" color="#f00" size="3">es6+中的class不进行自动提升主要为了解决继承父类时，父类不可用的问题</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; forwardRef, Injectable &#125; from &apos;@angular2/core&apos;</span><br><span class="line">@Injectable()</span><br><span class="line">class Socket &#123;</span><br><span class="line">    constructor(@Inject(forwardRef(() =&gt; Buffer)) private buffer) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Buffer &#123;</span><br><span class="line">    constructor(@Inject(BUFFER_SIZE) private size: Number) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="OpaqueToken"><a href="#OpaqueToken" class="headerlink" title="OpaqueToken"></a>OpaqueToken</h3><h4 id="OpaqueToken允许创建基于字符串的Token类-在Provider中使用。只需导入Opaque类。"><a href="#OpaqueToken允许创建基于字符串的Token类-在Provider中使用。只需导入Opaque类。" class="headerlink" title="OpaqueToken允许创建基于字符串的Token类,在Provider中使用。只需导入Opaque类。"></a>OpaqueToken允许创建基于字符串的Token类,在Provider中使用。只需导入Opaque类。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; OpaqueToken &#125; from &apos;@angular/core&apos;;</span><br><span class="line">const CONFIG_TOKEN = new OpaqueToken(&apos;config&apos;);</span><br><span class="line">export const THIRDPARTYLIBPROVIDERS = [</span><br><span class="line">    &#123;</span><br><span class="line">        provide: CONFIG_TOKEN, useClass: ThirdPartyConfig</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>OpaqueToken类的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export class OpaqueToken &#123;</span><br><span class="line">    constructor(protected _desc: string) &#123;&#125;</span><br><span class="line">    toString() : string &#123;</span><br><span class="line">        return `Token$&#123;this._desc&#125;`</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>OpaqueToken类的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ReflectiveInjector, OpaquToken &#125; from &apos;@angular/core&apos;;</span><br><span class="line">const t = new OpaquToken(&apos;value&apos;);</span><br><span class="line">const injector = ReflectiveInjector.resolveAndCreate([</span><br><span class="line">    &#123;</span><br><span class="line">        provide: t,</span><br><span class="line">        useValue: &apos;bindingValue&apos;</span><br><span class="line">    &#125;</span><br><span class="line">]);</span><br><span class="line">injector.get(t)  // &apos;bindingValue&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="InjectionToken-Angular4"><a href="#InjectionToken-Angular4" class="headerlink" title="InjectionToken (Angular4+)"></a>InjectionToken (Angular4+)</h3><h4 id="使用ValueProvider"><a href="#使用ValueProvider" class="headerlink" title="使用ValueProvider"></a>使用ValueProvider</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@NgModule(&#123;</span><br><span class="line">    ...,</span><br><span class="line">    providers: [</span><br><span class="line">        &#123;</span><br><span class="line">            provide: &apos;apiUrl&apos;,</span><br><span class="line">            userValue: &apos;http://localhost:4200/heroes&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注入ProviderValue"><a href="#注入ProviderValue" class="headerlink" title="注入ProviderValue"></a>注入ProviderValue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Injectable()</span><br><span class="line">export class HeroService &#123;</span><br><span class="line">    constructor(</span><br><span class="line">        private loggerService: LoggerService,</span><br><span class="line">        @Inject(&apos;apiUrl&apos;) private apiUrl: String</span><br><span class="line">    )&#123;</span><br><span class="line">        console.log(apiUrl)  //  http://localhost:4200/heroes</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果引入了第三方库且名称相同就产生了问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export const THIRD_PARTY_PROVIDERS = [</span><br><span class="line">    &#123;</span><br><span class="line">        provide: &apos;apiUrl&apos;,   //  与localhost:4200相同</span><br><span class="line">        userValue: &apos;http://192.168.18.59:4200&apos;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>更新Provider配置信息则如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; THIRD_PARTY_PROVIDERS &#125; from &apos;./third-party&apos;;</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">    ...,</span><br><span class="line">    providers: [</span><br><span class="line">        &#123;</span><br><span class="line">        provide: &apos;apiUrl&apos;,</span><br><span class="line">        useValue: &apos;http://localhost:4200/heros&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        THIRD_PARTY_PROVIDERS</span><br><span class="line">    ],</span><br><span class="line">    bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<font face="黑体" color="#f00" size="3">localhost:4200被覆盖</font>

<h4 id="使用字符串作为Token起冲突了。所以利用InjectionToken-Angular4-统一管理Token信息。"><a href="#使用字符串作为Token起冲突了。所以利用InjectionToken-Angular4-统一管理Token信息。" class="headerlink" title="使用字符串作为Token起冲突了。所以利用InjectionToken(Angular4+)统一管理Token信息。"></a>使用字符串作为Token起冲突了。所以利用InjectionToken(Angular4+)统一管理Token信息。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; InjectionToken &#125; from &apos;@angular/core&apos;;</span><br><span class="line">export const API_URL = new InjectionToken&lt;string&gt;(&apos;apiUrl&apos;);</span><br></pre></td></tr></table></figure>
<h4 id="OpaqueToken-与-InjectionToken-异同点"><a href="#OpaqueToken-与-InjectionToken-异同点" class="headerlink" title="OpaqueToken 与 InjectionToken 异同点"></a>OpaqueToken 与 InjectionToken 异同点</h4><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ul>
<li>创建可在Provider中使用的Token</li>
</ul>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul>
<li>前者ng2的类，后者ng4+引入的类，继承自OpaqueToken，且引入了泛型用于定义所关联的依赖对象的类型</li>
</ul>
<h2 id="Es6-Set-Map"><a href="#Es6-Set-Map" class="headerlink" title="Es6 Set Map"></a>Es6 Set Map</h2><h3 id="Es6提供了新的数据结构Set。类似于数组，但是成员都是唯一的，没有重复的值。接受一个数组或类数组对象作为参数"><a href="#Es6提供了新的数据结构Set。类似于数组，但是成员都是唯一的，没有重复的值。接受一个数组或类数组对象作为参数" class="headerlink" title="Es6提供了新的数据结构Set。类似于数组，但是成员都是唯一的，没有重复的值。接受一个数组或类数组对象作为参数"></a>Es6提供了新的数据结构Set。类似于数组，但是成员都是唯一的，没有重复的值。接受一个数组或类数组对象作为参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set([1,2,3,4,2]);</span><br><span class="line">[...set]    // [1,2,3,4]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set();</span><br><span class="line">[1,2,2,2,3,4].map(x =&gt; set.add(x));</span><br><span class="line">set   // [1,2,3,4]</span><br></pre></td></tr></table></figure>
<h4 id="Set内部，两个对象不相等，两个NaN相等，用length检测-可以用for…of遍历"><a href="#Set内部，两个对象不相等，两个NaN相等，用length检测-可以用for…of遍历" class="headerlink" title="Set内部，两个对象不相等，两个NaN相等，用length检测,可以用for…of遍历"></a>Set内部，两个对象不相等，两个NaN相等，用length检测,可以用for…of遍历</h4><ul>
<li><p>add(value)</p>
</li>
<li><p>delete(value) </p>
</li>
<li><p>has(value)</p>
</li>
<li><p>clear()</p>
</li>
</ul>
<h3 id="Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键-初始化Map需要一个二维数组，或者直接初始化一个空Map"><a href="#Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键-初始化Map需要一个二维数组，或者直接初始化一个空Map" class="headerlink" title="Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键, 初始化Map需要一个二维数组，或者直接初始化一个空Map"></a>Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键, 初始化Map需要一个二维数组，或者直接初始化一个空Map</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);</span><br><span class="line">m.get(&apos;Michael&apos;); // 95</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map();</span><br><span class="line">var o = &#123;p: &quot;Hello World&quot;&#125;;</span><br><span class="line">m.set(o, &quot;content&quot;)</span><br><span class="line">m.get(o)    // &quot;content&quot;</span><br><span class="line">m.has(o)    // true</span><br><span class="line">m.delete(o) // true</span><br><span class="line">m.has(o)    // false</span><br></pre></td></tr></table></figure>
<font face="黑体" color="#f00" size="3">只有对同一个对象的引用，Map结构才视为同一个键</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var map = new Map();</span><br><span class="line">map.set([&apos;a&apos;], 555);</span><br><span class="line">map.get([&apos;a&apos;])   // undefined</span><br><span class="line">上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。</span><br></pre></td></tr></table></figure>
<h3 id="ModuleWithProviders"><a href="#ModuleWithProviders" class="headerlink" title="ModuleWithProviders"></a>ModuleWithProviders</h3><p>创建一个共享模块，包含部分功能性模块、管道、指令、和服务。对于服务，通常作为单例的服务可能被多次提供，可以通过在共享模块内部返回ModuleWithProviders对象的静态方法forRoot解决这类问题, (相对于将service注入在NgModule,通过forRoot方法返回具有NgModule属性的ModuleWithProviders对象，可以解决service多次提供的情况)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NgModule, ModuleWithProviders &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; someDirective, somePipe, someService &#125; from &apos;./functions&apos;;</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">    declarations: [</span><br><span class="line">        somePipe,</span><br><span class="line">        someDirective</span><br><span class="line">    ],</span><br><span class="line">    exports: [</span><br><span class="line">        somePipe,</span><br><span class="line">        someDirective </span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line">export class SharedModule &#123;</span><br><span class="line">    static forRoot() : ModuleWithProviders &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            ngModule: SharedModule,</span><br><span class="line">            providers: [ someService ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NgModule中并不提供服务，在模块类中定义forRoot静态方法，返回ModuleWithProviders接口对象，在应用模块中导入共享模块并调用静态方法forRoot来提供服务和其他指令管道等,这样根模块会把他得providers添加到根模块的服务提供商中，确切的说是angular会先累加所有的显式注入的提供商，然后进一步追加其他模块的提供商到@NgModule.providers中，可以确保显式添加的提供商优先级大于从其他模块导入的；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; SharedModule &#125; from &apos;./shared&apos;</span><br><span class="line">//:...</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">    imports: [</span><br><span class="line">        SharedModule.forRoot()</span><br><span class="line">    ],</span><br><span class="line">    //:...</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>不调用forRoot方法则会只访问共享的管道和指令，不在提供服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; SharedModule &#125; from &apos;./shared&apos;</span><br><span class="line">//:...</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">    imports: [</span><br><span class="line">        SharedModule、</span><br><span class="line">    ],</span><br><span class="line">    //:...</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123;&#125;</span><br></pre></td></tr></table></figure>
<font face="黑体" color="#f00" size="3">Angular2中没有模块级别的service,所有在NgModule中声明的Provider都是注册在跟级别的DI中</font>

<h3 id="shadow-DOM-选择器"><a href="#shadow-DOM-选择器" class="headerlink" title="shadow DOM 选择器"></a>shadow DOM 选择器</h3><p>使用emulated进行样式隔离时，可以访问适用于shadow DOM的css选择器</p>
<h4 id="宿主"><a href="#宿主" class="headerlink" title="宿主"></a>宿主</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:host &#123;</span><br><span class="line">    color: red;    // &lt;song-track&gt;</span><br><span class="line">&#125;</span><br><span class="line">:host(.selected) &#123;</span><br><span class="line">    color: red;    // &lt;song-track class=&quot;selected&quot;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="样式依赖于祖先元素"><a href="#样式依赖于祖先元素" class="headerlink" title="样式依赖于祖先元素"></a>样式依赖于祖先元素</h4><p>它会在组件的宿主元素的祖先元素中查找汽配的祖先元素直到文档的根</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:host-content(.selected) &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">:host-content(#selected) &#123;</span><br><span class="line">    color: red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="宿主元素或后代元素-跨边界"><a href="#宿主元素或后代元素-跨边界" class="headerlink" title="宿主元素或后代元素(跨边界)"></a>宿主元素或后代元素(跨边界)</h4><p>它会覆盖任何封装的宿主元素或者其子元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:host /deep/ .selected&#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">:host &gt;&gt;&gt; .selected&#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font face="黑体" color="#f00" size="3">angular-cli 启动的项目使用deep而不是&gt;&gt;&gt;</font>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/28/自定义表单/" itemprop="url">
                  自定义表单
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-12-28T13:47:16+08:00" content="2017-12-28">
              2017-12-28
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ControlValueAccessor"><a href="#ControlValueAccessor" class="headerlink" title="ControlValueAccessor"></a>ControlValueAccessor</h2><h3 id="它是一个接口用于连接表单模型和视图，自定义表单必须实现这个接口，来实现模型与视图的映射关系"><a href="#它是一个接口用于连接表单模型和视图，自定义表单必须实现这个接口，来实现模型与视图的映射关系" class="headerlink" title="它是一个接口用于连接表单模型和视图，自定义表单必须实现这个接口，来实现模型与视图的映射关系"></a>它是一个接口用于连接表单模型和视图，自定义表单必须实现这个接口，来实现模型与视图的映射关系</h3><p>Angular引入它的原因在于不同的输入控件更新数据方式不同，input或checkbox,但是可以通过ControlValueAccessor统一</p>
<ul>
<li><p>DefaultValueAccessor - text/textarea类型</p>
</li>
<li><p>SelectControlValueAccessor - selec类型</p>
</li>
<li><p>CheckboxControlValueAccessor - checkbox类型</p>
</li>
</ul>
<h2 id="实现ControlValueAccessor接口"><a href="#实现ControlValueAccessor接口" class="headerlink" title="实现ControlValueAccessor接口"></a>实现ControlValueAccessor接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export interface ControlValueAccessor &#123;</span><br><span class="line">    writeValue(obj: any): void;     // 将模型中的新值写入视图</span><br><span class="line">    registerOnChange(fn: any): void;    // 当控件接收到change事件后，调用的函数，通知外部组件发生变化</span><br><span class="line">    registerOnTouched(fn: any): void;    // 接收到touched事件后调用的函数</span><br><span class="line">    setDisabledState?(isDisabled: boolean): void;    // 当控件状态变成DISABLED或ENABLE时，调用该函数启用或禁用dom</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component(...)</span><br><span class="line">class CounterComponent implements ControlValueAccessor &#123;</span><br><span class="line">    ...</span><br><span class="line">    propagateChange = (_: any) =&gt; &#123;&#125;;</span><br><span class="line">    registerOnChange(fn: any) &#123;</span><br><span class="line">        this.propagateChange = fn;   //  view层的值发生改变，通知外部</span><br><span class="line">    &#125;</span><br><span class="line">    registerOnTouched...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注册成为表单控件"><a href="#注册成为表单控件" class="headerlink" title="注册成为表单控件"></a>注册成为表单控件</h2><ul>
<li><p>NG_VALUE_ACCESSOR: token类型为ControlValueAccessor,将控件本身注册到DI框架，使其可以被表单访问</p>
</li>
<li><p>NG_VALIDTORS: 将控件注册成为一个可以让表单得到其验证状态的控件，token为function或Validator,配合useExisting可以让控件只暴露出对应的function或Validator的validate方法</p>
</li>
<li><p>forwardRef: 向前引用，允许我们引用一个尚未定义的对象</p>
</li>
<li><p>multi: 设置为true,该token对应多个依赖项，使用相同的token获取依赖项的时候，获取的是已注册的依赖对象列表。如果不是true,那么对于相同的token的提供商来说，后定义的提供商会覆盖前面定义的</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;exe-demo&apos;,</span><br><span class="line">    ...</span><br><span class="line">    provides: [</span><br><span class="line">             // 创建Token为NG_VALUE_ACCESSOR的提供商</span><br><span class="line">        &#123;</span><br><span class="line">            provide: NG_VALUE_ACCESSOR,</span><br><span class="line">            useExisting: forwardRef(() =&gt; SomeComponent),</span><br><span class="line">            multi: true</span><br><span class="line">        &#125;,</span><br><span class="line">             // 创建Token为NG_VALIDATORS的表单验证验证器</span><br><span class="line">        &#123;</span><br><span class="line">            provide: NG_VALIDATORS,</span><br><span class="line">            useValue: validateCounterRange,</span><br><span class="line">            multi: true</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, forwardRef , Input &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; ControlValueAccessor, NG_VALUE_ACCESSOR, NG_VALIDATORS, </span><br><span class="line">FormControl, ValidatorFn, ValidationErrors, AbstractControl &#125; from &apos;@angular/forms&apos;;</span><br><span class="line">export const EXE_COUNTER_VALUE_ACCESSOR: any = &#123;</span><br><span class="line">    provide: NG_VALUE_ACCESSOR,</span><br><span class="line">    useExisting: forwardRef(() =&gt; CounterComponent),</span><br><span class="line">    multi: true</span><br><span class="line">&#125;</span><br><span class="line">export const validateCounterRange: ValidatorFn = (control: AbstractControl) : ValidationErrors =&gt; &#123;</span><br><span class="line">   return ( control.value &gt; 10 || control.value &lt; 0 ) ? </span><br><span class="line">   &#123;</span><br><span class="line">       &apos;rangeError&apos;: &#123; current: control.value, max: 10, min: 0&#125;</span><br><span class="line">   &#125; : null</span><br><span class="line">&#125;</span><br><span class="line">export const EXE_COUNTER_VALIDATOR = &#123;</span><br><span class="line">    provide: NG_VALIDATORS,</span><br><span class="line">    useValue: validateCounterRange,  </span><br><span class="line">    multi: true</span><br><span class="line">&#125;</span><br><span class="line">@Component(&#123;</span><br><span class="line">    ...</span><br><span class="line">    provides: [</span><br><span class="line">        EXE_COUNTER_VALUE_ACCESSOR,</span><br><span class="line">        EXE_COUNTER_VALIDATOR</span><br><span class="line">    ],</span><br><span class="line">    changeDetection: ChangeDetectionStrategy.OnPush</span><br><span class="line">&#125;)</span><br><span class="line">export class CounterComponent implements ControlValueAccessor &#123;</span><br><span class="line">    @Input() _count: number = 0;</span><br><span class="line">    get count() &#123;</span><br><span class="line">        return this._count;</span><br><span class="line">    &#125;</span><br><span class="line">    set count(value: number) &#123;</span><br><span class="line">        this._count = value;</span><br><span class="line">        this.propagateChange(this._count);</span><br><span class="line">    &#125;</span><br><span class="line">    propagateChange = (_: any) =&gt; &#123;&#125;;</span><br><span class="line">    writeValue(value: any) &#123;</span><br><span class="line">        if (value) &#123;</span><br><span class="line">            this.count = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    registerOnchange(fn: any) &#123;</span><br><span class="line">        this.propagateChange = fn;</span><br><span class="line">    &#125;</span><br><span class="line">    registerOnTouched(fn: any) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    increment() &#123;</span><br><span class="line">        this.count++;</span><br><span class="line">    &#125;</span><br><span class="line">    decrement() &#123;</span><br><span class="line">        this.count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在Angular中通过Provider来描述与Token相关联的依赖对象的创建方式，分为以下四种"><a href="#在Angular中通过Provider来描述与Token相关联的依赖对象的创建方式，分为以下四种" class="headerlink" title="在Angular中通过Provider来描述与Token相关联的依赖对象的创建方式，分为以下四种"></a>在Angular中通过Provider来描述与Token相关联的依赖对象的创建方式，分为以下四种</h3><ul>
<li><p>useClass</p>
</li>
<li><p>useValue</p>
</li>
<li><p>useExisting</p>
</li>
<li><p>useFactory</p>
</li>
</ul>
<p><img src="https://sfault-image.b0.upaiyun.com/299/404/2994048125-58cc9e6c17087_articlex" alt="relation"></p>
<font color="#f00">useClass</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">providers: [ </span><br><span class="line">    &#123; provide: ApiService, useClass: ApiService &#125;  // 简介写法直接 ApiService</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<font color="#f00">useValue</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">providers: [ </span><br><span class="line">    &#123; provide: API_URL, useValue: &apos;http://my.api.com/v1&apos; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<font color="#f00">useExisting</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">providers: [ </span><br><span class="line">    &#123; provide: &apos;ApiServiceAlias&apos;, useValue: ApiService &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<font color="#f00">useFactory</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export function configFactory(config: AppConfig) &#123;</span><br><span class="line">    return () =&gt; config.load();</span><br><span class="line">&#125;</span><br><span class="line">providers: [ </span><br><span class="line">    &#123; provide: APP_INITIALIZER, useFactory: configFactory,</span><br><span class="line">    deps: [AppConfig, multi: true] &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image" src="https://github.com/vernvn/hexoBlog/blob/master/avator/github.jpg?raw=true" alt="Lee">
          <p class="site-author-name" itemprop="name">Lee</p>
          <p class="site-description motion-element" itemprop="description">my blog</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">23</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lee</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lee/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lee/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lee/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lee/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lee/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lee/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

  


</body>
</html>
