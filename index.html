<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lee/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lee/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="my blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://vernvn.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="my blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="my blog">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://vernvn.github.io/"/>


  <title> Hexo </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-CN">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Hexo</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule" rel="section">
            
            Schedule
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/01/git新的指令/" itemprop="url">
                  git新的指令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2018-03-01T14:22:58+08:00" content="2018-03-01">
              2018-03-01
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="使用Git管理项目总结"><a href="#使用Git管理项目总结" class="headerlink" title="使用Git管理项目总结"></a>使用Git管理项目总结</h2><h4 id="导语："><a href="#导语：" class="headerlink" title="导语："></a>导语：</h4><blockquote>
<p>使用git已经一段时间了，总结一下我的理解关于使用git进行团队协作开发的流程。首先master分支作为主分支应该承担版本发布的责任。开发任务应该在develop分支上。不论当前分支是从哪个分支分离开来，都需要合并到那个分支上。根据需求的不同以及开发人员的指派，应该创建一系列feature-<em>分支，一旦开发完毕后，进行代码的review，确认无误后合并分支到develop分支上，之后删除相应的feature-</em>分支。在进行版本的发布前，需要从develop分支分离并创建对应的预发布分支，进行当前版本的测试，完成后，需要合并进develop分支和master分支，之后切换分支到master分支，生成版本节点标签并删除对应预发布分支，进行版本的发布。如果遇到bug问题，需要从master分支分离出修复bug分支，修复完成后合并进develop和master分支，之后切换分支到master分支，生成节点标签并删除对应bug分支。</p>
</blockquote>
<h3 id="一般的git命令已经用的很多了，今天记录几个很重要但是我自己在日常工作中很少使用的几个命令。"><a href="#一般的git命令已经用的很多了，今天记录几个很重要但是我自己在日常工作中很少使用的几个命令。" class="headerlink" title="一般的git命令已经用的很多了，今天记录几个很重要但是我自己在日常工作中很少使用的几个命令。"></a>一般的git命令已经用的很多了，今天记录几个很重要但是我自己在日常工作中很少使用的几个命令。</h3><h4 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h4><p>正在feature分支开发，master分支报了一个bug错误，此时需要即时修复bug,但是开发还没有完成，此时提交不太友好。Git提供的stash功能正好适用这个场景。可以把当前工作储存起来，处理完事情后继续工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git stash    // order code</div><div class="line">Saved working directory and index state WIP on feature-**: 4966d2d bingo</div></pre></td></tr></table></figure>
<p>此时git status查看工作区是干净的。此时可以创建临时分支处理bug。处理完bug后切换回feature-分支继续开发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git stash list // order code</div><div class="line">stash@&#123;0&#125;: WIP on feature-**: 4966d2d bingo</div></pre></td></tr></table></figure>
<p>工作现场存在，现在需要恢复现场。两个办法：</p>
<ul>
<li><p>git stash apply &amp;&amp; git stash drop  // 前者恢复现场不删除stash内容，后者为补充删除stash内容</p>
</li>
<li><p>git stash pop  // 恢复现场同时删除stash内容</p>
</li>
</ul>
<p>如果多次stash的情况下，可以git stash list查看，然后恢复指定的stash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git stash apply stash@&#123;0&#125;  // 括号内为指定stash内容</div></pre></td></tr></table></figure>
<h4 id="–no-ff"><a href="#–no-ff" class="headerlink" title="–no-ff"></a>–no-ff</h4><p>这个参数的意思是保留原分支记录，默认情况下，执行fast-forward merge,直接将master分支指向develop分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge --no-ff develop // 把develop合并进master分支</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/Kt1rngH.png" alt="fast-forward"></p>
<p><img src="http://i.imgur.com/rDt0UhJ.png" alt="--no-ff"></p>
<h4 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h4><p>比较两次修改的差异</p>
<h3 id="工作区-VS-暂存区"><a href="#工作区-VS-暂存区" class="headerlink" title="工作区 VS 暂存区"></a>工作区 VS 暂存区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git diff &lt;filename&gt;  </div><div class="line"></div><div class="line">$ git diff &lt;branch&gt; &lt;filename&gt; // 和另一分支的区别</div></pre></td></tr></table></figure>
<h3 id="暂存区-VS-Git仓库"><a href="#暂存区-VS-Git仓库" class="headerlink" title="暂存区 VS Git仓库"></a>暂存区 VS Git仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git diff --cached &lt;filename&gt;  </div><div class="line"></div><div class="line">$ git diff --cached &lt;commit&gt; &lt;filename&gt; // 和指定commit的区别</div></pre></td></tr></table></figure>
<h3 id="工作目录-VS-Git仓库"><a href="#工作目录-VS-Git仓库" class="headerlink" title="工作目录 VS Git仓库"></a>工作目录 VS Git仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git diff &lt;commit&gt; &lt;filename&gt;</div></pre></td></tr></table></figure>
<h3 id="Git仓库-VS-Git仓库"><a href="#Git仓库-VS-Git仓库" class="headerlink" title="Git仓库 VS Git仓库"></a>Git仓库 VS Git仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git diff &lt;commit&gt; &lt;commit&gt;  // git仓库任意两次commit的差别</div></pre></td></tr></table></figure>
<h2 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h2><p>以上命令可以不指定<filename>,则对应全部文件操作<br>以上命令涉及git仓库对比的，均可指定commit版本</filename></p>
<ul>
<li><p>HEAD 最近一次commit</p>
</li>
<li><p>HEAD^ 上次提交</p>
</li>
<li><p>HEAD～100 上100次提交</p>
</li>
<li><p>每次提交产生的哈希值</p>
</li>
</ul>
<h4 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h4><h3 id="将某个分支上的所有提交记录移植到另一个分支上，清除不必要的提交记录"><a href="#将某个分支上的所有提交记录移植到另一个分支上，清除不必要的提交记录" class="headerlink" title="将某个分支上的所有提交记录移植到另一个分支上，清除不必要的提交记录"></a>将某个分支上的所有提交记录移植到另一个分支上，清除不必要的提交记录</h3><h3 id="永远不要rebase一个已经分享的分支"><a href="#永远不要rebase一个已经分享的分支" class="headerlink" title="永远不要rebase一个已经分享的分支"></a>永远不要rebase一个已经分享的分支</h3><p>一图以意之</p>
<p><img src="https://sfault-image.b0.upaiyun.com/206/854/2068544494-5783bdd025d80_articlex" alt="0"></p>
<h3 id="以下是一个例子讲解rebase的作用"><a href="#以下是一个例子讲解rebase的作用" class="headerlink" title="以下是一个例子讲解rebase的作用"></a>以下是一个例子讲解rebase的作用</h3><p><img src="https://backlog.com/git-tutorial/cn/img/post/stepup/capture_stepup2_8_1_1.png" alt="1"></p>
<p>切换到issue3分支后，对master执行rebase,解决冲突</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout issue3</div><div class="line">$ git rebase master</div></pre></td></tr></table></figure>
<p>冲突解决后不需要commit命令进行提交，而是执行rebase命令的continue选项或着abort选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add .</div><div class="line">$ git rebase --continue  /  --abort</div></pre></td></tr></table></figure>
<p><img src="https://backlog.com/git-tutorial/cn/img/post/stepup/capture_stepup2_8_1.png" alt="2"></p>
<p>master分支的issue3分支可以fast-forward了。切换到master分支执行合并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">$ git merge issue3</div></pre></td></tr></table></figure>
<p>rebase的内容与merge的效果是一样的，但是历史记录会简洁</p>
<p><img src="https://backlog.com/git-tutorial/cn/img/post/stepup/capture_stepup2_8_2.png" alt="3"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/08/ng2-translate/" itemprop="url">
                  ng2-translate
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2018-02-08T15:56:40+08:00" content="2018-02-08">
              2018-02-08
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="i18n国际化，演示angular控件ng2-translate"><a href="#i18n国际化，演示angular控件ng2-translate" class="headerlink" title="i18n国际化，演示angular控件ng2-translate"></a>i18n国际化，演示angular控件ng2-translate</h2><p>app.module</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import &#123; TranslateModule, TranslateLoader, TranslateStaticLoader &#125; from &apos;ng2-translate&apos;;</div><div class="line">//..</div><div class="line">export function createTranslateStaticLoader(http: Http) &#123;</div><div class="line">    return new TranslateStaticLoader(http, &apos;./assets/i18n&apos;, &apos;.json&apos;);   // 发送请求，拿到i18n文件夹下的json后缀文件</div><div class="line">&#125;</div><div class="line">@NgModule(&#123;</div><div class="line">    imports: [</div><div class="line">        TranslateModule.forRoot(&#123;</div><div class="line">            provide: TranslateLoader,</div><div class="line">            useFactory: createTranslateStaticLoader,</div><div class="line">            deps: [Http]</div><div class="line">        &#125;)</div><div class="line">    ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>app.component</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import &#123; TranslateService &#125; from &apos;ng2-translate&apos;;</div><div class="line">@Component(&#123;</div><div class="line">    selector: &apos;app-root&apos;</div><div class="line">&#125;)</div><div class="line">export class AppComponent &#123;</div><div class="line">    constructor(</div><div class="line">        private translate: TranslateService</div><div class="line">    ) &#123;&#125;</div><div class="line">    ngOnInit() &#123;</div><div class="line">        this.translate.addLangs([&apos;zh&apos;, &apos;en&apos;]);</div><div class="line">        this.translate.setDefaultLang(&apos;zh&apos;);</div><div class="line">        const browserLang = this.translate.getBrowserLang();</div><div class="line">        this.translate.use(browserLang.match(/zh|en/) ? browserLang : &apos;zh&apos; );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>模版使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;p&gt;&#123;&#123; word | trnaslate &#125;&#125;&lt;p&gt;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/08/NgZone/" itemprop="url">
                  NgZone
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2018-02-08T10:22:09+08:00" content="2018-02-08">
              2018-02-08
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p></p><h4 align="center">利用Angular本身ChangeDetectionStrategyAPI改变检查策略脱离变化检测器，即减少不必要的检测来提高应用的性能<p></p>
<h4>

<h3 id="zone是什么"><a href="#zone是什么" class="headerlink" title="zone是什么"></a>zone是什么</h3><p>对浏览器的异步api做了封装，并对外发出通知何时开始何时结束，angular在得到异步事件结束的通知后，执行变化检查。</p>
<h3 id="zone性能优化的重点在哪"><a href="#zone性能优化的重点在哪" class="headerlink" title="zone性能优化的重点在哪"></a>zone性能优化的重点在哪</h3><p>精确的控制哪些异步事件是应该在angular的zone以内运行的，哪些是应该在angular的zone之外运行的。显然在angular的zone之外运行的事件是不会进行变化检测的，减少不必要的变化检测则实现了性能上的优化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import &#123; NgZone &#125; from &apos;@angular/core&apos;;</div><div class="line">constructor(private zone: NgZone) &#123;&#125;</div><div class="line">mouseDown(event) &#123;</div><div class="line">    this.zone.runOutsideAngular(() =&gt; &#123;</div><div class="line">        window.document.addEventListener(&apos;mouseover&apos;, this.mouseMove.bind(this));  // 此处应该尽量避免直接操纵dom,应该利用底层封装api(renderer, renderer2)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>NgZone可以让代码继续回到zone里运行，会再次触发anuglar的变化检测，调用NgZone.run();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mouseUp(event) &#123;</div><div class="line">    this.zone.run(() =&gt; &#123;</div><div class="line">        .....</div><div class="line">    &#125;)</div><div class="line">    window.docuemnt.removeEventListener(&apos;mousemove&apos;, this.mouseMove);  // 移除mousemove绑定的回调</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>zone.js为javascript提供执行上下文，可以在异步任务之间进行持久性传递。采用了猴子补丁将javascript中的异步任务包裹了一层。使得异步任务运行在zone的上下文中。每一个异步任务都被当作一个task,并在task基础上提供钩子函数。</p>
<ul>
<li><p>onZoneCreated: 产生一个新的zone对象时的钩子函数，zone.fork也会产生一个继承基类zone的新zone,形成一个独立的zone上下文</p>
</li>
<li><p>beforeTask: zone Task 执行前的钩子函数</p>
</li>
<li><p>afterTask</p>
</li>
<li><p>onError: zone运行Task时候的异常钩子函数</p>
</li>
</ul>
<p>并且对大多数异步事件进行了包裹封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">const log = (phase) =&gt; &#123;</div><div class="line">    return () =&gt; &#123;</div><div class="line">        console.log(&apos;i am in zone.js&apos; + phase + &apos;!&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">zone.fork(&#123;</div><div class="line">    onZoneCreated: log(&apos;onZoneCreated&apos;),</div><div class="line">    beforeTask: log(&apos;beforeTask&apos;),</div><div class="line">    afterTask: log(&apos;afterTask&apos;)</div><div class="line">&#125;).run(() =&gt; &#123;</div><div class="line">    const methodLog = (func) =&gt; &#123;</div><div class="line">        return () =&gt; &#123;</div><div class="line">            console.log(&apos;i am from&apos; + func + &apos;function&apos;)</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    foo = methodLog(&apos;foo&apos;),</div><div class="line">    bar = methodLog(&apos;bar&apos;),</div><div class="line">    baz = () =&gt; &#123;</div><div class="line">        setTimeout( methodLog(&apos;baz in setTimeout&apos;), 0)</div><div class="line">    &#125;;</div><div class="line">    foo(); </div><div class="line">    baz();</div><div class="line">    bar();</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">输出结果：</div><div class="line">i am in zone.js beforeTask;</div><div class="line">i am from foo function;</div><div class="line">i am from bar function;</div><div class="line">i am in zone.js afterTask;</div><div class="line"></div><div class="line">i am in zone.js onZoneCreated;</div><div class="line">i am in zone.js beforeTask;</div><div class="line">i am from baz in setTimeout function;</div><div class="line">i am in zone.js afterTask;</div></pre></td></tr></table></figure>
<p>上述例子中将run方法分为了两个task，分别为同步task和异步task。fork方法会产生一个继承根zone的子类，并在fork函数中配置特定的钩子函数，形成独立的zone上下文，而run方法则是启动执行业务代码的对外接口。</p>
<h3 id="使用Observable优化脏检查"><a href="#使用Observable优化脏检查" class="headerlink" title="使用Observable优化脏检查"></a>使用Observable优化脏检查</h3><p>使用OnPush的检查策略，如果修改了对象内部的值，此时不会进行脏检查，不会进行视图更新。此时可以选择Observable对象，通过手动调用markForCheck()方法进行优化，当前组件到根组件的路径上的所有组件都会进行变化检测。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@Component(&#123;</div><div class="line">    ...,</div><div class="line">    changeDetection: ChangeDetectionStrategy.OnPush</div><div class="line">&#125;)</div><div class="line">export class TodosComponent implements OnInit&#123;</div><div class="line">    @Input() todos: Observable&lt;Todo[]&gt;;</div><div class="line">    constructor(private cd: ChangeDetectorRef) &#123;&#125;</div><div class="line">    ngOnInit() &#123;</div><div class="line">        this.todos.subscribe(todos =&gt; &#123;</div><div class="line">            业务代码；</div><div class="line">            this.cd.markForCheck();</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></h4></h4>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/07/everyNote/" itemprop="url">
                  EveryNote
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2018-02-07T11:09:10+08:00" content="2018-02-07">
              2018-02-07
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="记录每天学习中发现的知识点"><a href="#记录每天学习中发现的知识点" class="headerlink" title="记录每天学习中发现的知识点"></a>记录每天学习中发现的知识点</h2><font face="黑体" color="#f00" size="4">总结TemplateRef与ViewContainerRef</font>

<h4 id="TemplateRef-用于表示内嵌的template模板元素，可以创建内嵌视图（createEmbeddedView）-可以访问到封装后的nativeElement-模板经过渲染后会替换成comment元素"><a href="#TemplateRef-用于表示内嵌的template模板元素，可以创建内嵌视图（createEmbeddedView）-可以访问到封装后的nativeElement-模板经过渲染后会替换成comment元素" class="headerlink" title="TemplateRef: 用于表示内嵌的template模板元素，可以创建内嵌视图（createEmbeddedView）,可以访问到封装后的nativeElement,模板经过渲染后会替换成comment元素"></a>TemplateRef: 用于表示内嵌的template模板元素，可以创建内嵌视图（createEmbeddedView）,可以访问到封装后的nativeElement,模板经过渲染后会替换成comment元素</h4><h4 id="ViewContainerRef-用于表示一个视图容器，可添加一或多个视图，通过ViewContainerRef实例，可以基于TemplateRef创建内嵌视图，并指定插入位置，主要创建管理内嵌视图"><a href="#ViewContainerRef-用于表示一个视图容器，可添加一或多个视图，通过ViewContainerRef实例，可以基于TemplateRef创建内嵌视图，并指定插入位置，主要创建管理内嵌视图" class="headerlink" title="ViewContainerRef: 用于表示一个视图容器，可添加一或多个视图，通过ViewContainerRef实例，可以基于TemplateRef创建内嵌视图，并指定插入位置，主要创建管理内嵌视图"></a>ViewContainerRef: 用于表示一个视图容器，可添加一或多个视图，通过ViewContainerRef实例，可以基于TemplateRef创建内嵌视图，并指定插入位置，主要创建管理内嵌视图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;template #tpl&gt;</div><div class="line">    ...</div><div class="line">&lt;/template&gt;</div><div class="line">@ViewChild(&apos;tpl&apos;) tplRef: TemplateRef&lt;any&gt;;</div><div class="line">@ViewChild(&apos;tpl&apos;, &#123; read: ViewContainerRef &#125;) tplVcRef: ViewContainerRef;</div><div class="line">ngAfterViewInit()&#123;</div><div class="line">    this.tplVcRef.createEmbeddedView(this.tplRef);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="注意：-ViewChild属性装饰器若未设置read属性，默认返回ElementRef对象实例"><a href="#注意：-ViewChild属性装饰器若未设置read属性，默认返回ElementRef对象实例" class="headerlink" title="注意：@ViewChild属性装饰器若未设置read属性，默认返回ElementRef对象实例"></a>注意：@ViewChild属性装饰器若未设置read属性，默认返回ElementRef对象实例</h3><font face="黑体" color="#f00" size="4">指令的一般应用场景</font>

<h4 id="分类：内置指令，-自定义指令"><a href="#分类：内置指令，-自定义指令" class="headerlink" title="分类：内置指令， 自定义指令"></a>分类：内置指令， 自定义指令</h4><h4 id="主要考虑自定义指令的属性指令与结构指令"><a href="#主要考虑自定义指令的属性指令与结构指令" class="headerlink" title="主要考虑自定义指令的属性指令与结构指令"></a>主要考虑自定义指令的属性指令与结构指令</h4><h3 id="自定义属性指令实现简写"><a href="#自定义属性指令实现简写" class="headerlink" title="自定义属性指令实现简写"></a>自定义属性指令实现简写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Directive(&#123;</div><div class="line">    selector: &apos;[directivename]&apos;  // 这里定义的selector为什么使用中括号，是为了结合input装饰器获取属性值</div><div class="line">&#125;)</div><div class="line">export class SomeDirective &#123;</div><div class="line">    private _default = &apos;[someValue]&apos; // 旨在指令类内部定义默认值</div><div class="line">    @Input(directivename) directiveAnotherName;  // 输入属性</div><div class="line">    constructor(private el: ElementRef, private renderer: Renderer)&#123; // 引用类实例化，其中renderer对象提供许多api供渲染元素</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    @HostListener(eventName) eventName()&#123;  // 监听宿主元素事件</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    &lt;h1 [changeColor]=&quot;&apos;red&apos;&quot;&gt;&lt;/h1&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="自定义结构指令是实现简写"><a href="#自定义结构指令是实现简写" class="headerlink" title="自定义结构指令是实现简写"></a>自定义结构指令是实现简写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@Directive(&#123;</div><div class="line">    selector: &apos;[directivename]&apos;  // 这里定义的selector为什么使用中括号，是为了结合input装饰器获取属性值</div><div class="line">&#125;)</div><div class="line">export class SomeDirective &#123;</div><div class="line">    @Input(directivename)  </div><div class="line">    set condition(newCondition: boolean) &#123;  // 这里用了getter、setter存取器, 进行属性值的动态监听</div><div class="line">        if(newCondition)&#123;</div><div class="line">            this.tplVc.createEmbeddedView(this.tpl); // 创建内嵌视图,可以设置第二个参数&#123;$implicit: somevalue&#125;, 则angular提供了let模板语法，允许在生成的上下文是定义和传递</div><div class="line">        &#125;else&#123;</div><div class="line">            this.tplVc.clear();  // 清除内嵌视图</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    constructor(private tpf: TemplateRef, private tplVc: VireContainerRef)&#123; // 引用类实例化，用于创建内嵌视图</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    &lt;h1 *structureDirective = true&gt;&lt;/h1&gt; // 这里用了angular结构性指令的语法糖，原理同*ngIf</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结以上属性指令与结构指令"><a href="#总结以上属性指令与结构指令" class="headerlink" title="总结以上属性指令与结构指令"></a>总结以上属性指令与结构指令</h3><p><em>1 ElementRef与Renderer等的作用：支持跨平台，从底层封住，统一了api接口;
</em>2 TemplateRef与ViewContainerRef的作用： 前面有总结过他俩的作用;<br>*3 angular2中指令与组件的关系：组件继承与指令，并扩展了与视图的关系</p>
<h3 id="自定义debounceClick指令"><a href="#自定义debounceClick指令" class="headerlink" title="自定义debounceClick指令"></a>自定义debounceClick指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">@Directive(&#123;</div><div class="line">    selector: &apos;[directiveDebounceClick]&apos;</div><div class="line">&#125;)</div><div class="line">export class SomeDirective &#123;</div><div class="line">    @Input(&apos;debounceTime&apos;) debounceTime: string;</div><div class="line">    @Output(&apos;debounceClick&apos;)  debounceClick = new EventEmitter();</div><div class="line">    private clicks = new Subject&lt;any&gt;();  // 定义subject处理点击事件</div><div class="line">    constructor()&#123; &#125;</div><div class="line">    @HostListener(&apos;click&apos;,[&apos;$event&apos;])  // 监听宿主元素上的点击事件，第二个参数用于将事件传递给eventClick方法</div><div class="line">    eventClick(event)&#123;</div><div class="line">        event.preventDefault();</div><div class="line">        event.stopPropagation();  // 阻止事件默认行为与事件冒泡</div><div class="line">        this.clicks.next(event);  // 发送新值</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ngOnInit()&#123;</div><div class="line">        this.clicks.debounceTime(this.debounceTime) // 去抖动,时间自定义</div><div class="line">        .subscribe(x =&gt; this.debounceClick.emit(x)); // 调用emit方法发出事件</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    &lt;button directiveDebounceClick [debounceTime] =&apos;300&apos; (debounceClick)=&quot;log($event)&quot;&gt;&lt;/button&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<font face="黑体" color="#f00" size="4">ng-content包装器</font>

<h4 id="如果你尝试在-Angular-中编写可重复使用的组件，则可能会接触到内容投射的概念"><a href="#如果你尝试在-Angular-中编写可重复使用的组件，则可能会接触到内容投射的概念" class="headerlink" title="如果你尝试在 Angular 中编写可重复使用的组件，则可能会接触到内容投射的概念:"></a>如果你尝试在 Angular 中编写可重复使用的组件，则可能会接触到内容投射的概念:<ng-content></ng-content></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import &#123; Component &#125; from &apos;@angular/core&apos;;</div><div class="line"></div><div class="line">@Component(&#123;</div><div class="line">  selector: &apos;wrapper&apos;,</div><div class="line">  template: `</div><div class="line">    &lt;div class=&quot;box&quot;&gt;</div><div class="line">      &lt;ng-content&gt;&lt;/ng-content&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  `</div><div class="line">&#125;)</div><div class="line">class Wrapper &#123;&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import &#123; Component &#125; from &apos;@angular/core&apos;;</div><div class="line"></div><div class="line">@Component(&#123;</div><div class="line">  selector: &apos;wrapper&apos;,</div><div class="line">  template: `</div><div class="line">  &lt;div class=&quot;box red&quot;&gt;</div><div class="line">    &lt;ng-content&gt;&lt;/ng-content&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">  &lt;div class=&quot;box blue&quot;&gt;</div><div class="line">    &lt;ng-content select=&quot;counter&quot;&gt;&lt;/ng-content&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">  `,</div><div class="line">  styles: [`</div><div class="line">    .red &#123;background: red;&#125;</div><div class="line">    .blue &#123;background: blue;&#125;</div><div class="line">  `]</div><div class="line">&#125;)</div><div class="line">export class Wrapper &#123; &#125;</div></pre></td></tr></table></figure>
<h4 id="将包装器的不同子项投影到模板的不同部分。-支持一个-select-属性，可以让你在特定的地方投射具体的内容。该属性支持-CSS-选择器（my-element，-my-class，-my-attribute-，…）来匹配你想要的内容。如果-ng-content-上没有设置-select-属性，它将接收全部内容，或接收不匹配任何其他-ng-content-元素的内容。"><a href="#将包装器的不同子项投影到模板的不同部分。-支持一个-select-属性，可以让你在特定的地方投射具体的内容。该属性支持-CSS-选择器（my-element，-my-class，-my-attribute-，…）来匹配你想要的内容。如果-ng-content-上没有设置-select-属性，它将接收全部内容，或接收不匹配任何其他-ng-content-元素的内容。" class="headerlink" title="将包装器的不同子项投影到模板的不同部分。 支持一个 select 属性，可以让你在特定的地方投射具体的内容。该属性支持 CSS 选择器（my-element，.my-class，[my-attribute]，…）来匹配你想要的内容。如果 ng-content 上没有设置 select 属性，它将接收全部内容，或接收不匹配任何其他 ng-content 元素的内容。"></a>将包装器的不同子项投影到模板的不同部分。<ng-content> 支持一个 select 属性，可以让你在特定的地方投射具体的内容。该属性支持 CSS 选择器（my-element，.my-class，[my-attribute]，…）来匹配你想要的内容。如果 ng-content 上没有设置 select 属性，它将接收全部内容，或接收不匹配任何其他 ng-content 元素的内容。</ng-content></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;wrapper&gt;</div><div class="line">  &lt;span&gt;This is not a counter&lt;/span&gt;</div><div class="line">  &lt;counter&gt;&lt;/counter&gt;</div><div class="line">&lt;/wrapper&gt;</div></pre></td></tr></table></figure>
<h4 id="counter组件被正确投影到第二个蓝色框中，而-span-元素最终会在全部红色框中。"><a href="#counter组件被正确投影到第二个蓝色框中，而-span-元素最终会在全部红色框中。" class="headerlink" title="counter组件被正确投影到第二个蓝色框中，而 span 元素最终会在全部红色框中。"></a>counter组件被正确投影到第二个蓝色框中，而 span 元素最终会在全部红色框中。</h4><h2 id="ngProjectAs"><a href="#ngProjectAs" class="headerlink" title="ngProjectAs"></a>ngProjectAs</h2><h4 id="内部组件会被隐藏在另一个更大的组件中。你只需要将其包装在额外的容器中即可应用-ngIf-或-ngSwitch。无论什么原因，通常情况下，你的内部组件不是包装器的直接子节点。所以需要使用ngProjectAs属性，将它用于指定的元素上。"><a href="#内部组件会被隐藏在另一个更大的组件中。你只需要将其包装在额外的容器中即可应用-ngIf-或-ngSwitch。无论什么原因，通常情况下，你的内部组件不是包装器的直接子节点。所以需要使用ngProjectAs属性，将它用于指定的元素上。" class="headerlink" title="内部组件会被隐藏在另一个更大的组件中。你只需要将其包装在额外的容器中即可应用 ngIf 或 ngSwitch。无论什么原因，通常情况下，你的内部组件不是包装器的直接子节点。所以需要使用ngProjectAs属性，将它用于指定的元素上。"></a>内部组件会被隐藏在另一个更大的组件中。你只需要将其包装在额外的容器中即可应用 ngIf 或 ngSwitch。无论什么原因，通常情况下，你的内部组件不是包装器的直接子节点。所以需要使用ngProjectAs属性，将它用于指定的元素上。</h4><font face="黑体" color="#f00" size="3">表单自定义验证规则</font>

<h4 id="举例：邮件匹配"><a href="#举例：邮件匹配" class="headerlink" title="举例：邮件匹配"></a>举例：邮件匹配</h4><p>定义用户类型接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">export interface User &#123;</div><div class="line">    name: string;</div><div class="line">    account: &#123;</div><div class="line">        email: string;</div><div class="line">        confirm: string;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>邮件匹配规则函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">export const emailMatcher = (control: AbstractControl): &#123;[key: string]: boolean&#125; =&gt; &#123;</div><div class="line">   const email = control.get(&apos;email&apos;);</div><div class="line">   const confirm = control.get(&apos;confirm&apos;);</div><div class="line">   if (!email || !confirm)&#123;</div><div class="line">       return;</div><div class="line">   &#125;</div><div class="line">   return email.value === confirm.value ? null : &#123; nomatch: true &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>表单模版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">import &#123; Component, OnInit&#125; from &apos;@angular/core&apos;;</div><div class="line">import &#123; FormBuilder, FormGroup, Validators &#125; from &apos;@angular/forms&apos;;</div><div class="line">import &#123; emailMatcher &#125; from &apos;./email-matcher&apos;;</div><div class="line">@Component(&#123;</div><div class="line">    selector: &apos;signup=form&apos;,</div><div class="line">    template: `</div><div class="line">        &lt;form novalidate (ngSubmit)=&quot;onSubmit(user)&quot; [formGroup]=&quot;user&quot;&gt;</div><div class="line">            &lt;label&gt;</div><div class="line">               name...</div><div class="line">            &lt;/label&gt;</div><div class="line">            &lt;div *ngIf=&quot;user.get(&apos;name&apos;).touched &amp;&amp; user.get(&apos;name&apos;).hasError(&apos;required&apos;)&quot;&gt;</div><div class="line">                name is required</div><div class="line">            &lt;/div&gt;</div><div class="line">            &lt;div formGroupName = &quot;account&quot;&gt;</div><div class="line">                &lt;label&gt;</div><div class="line">                    &lt;span&gt;Email address&lt;/span&gt;</div><div class="line">                    &lt;input type=&quot;email&quot; placeholder=&quot;Your email address&quot; formControlName=&quot;email&quot;&gt;</div><div class="line">                &lt;/label&gt;</div><div class="line">                &lt;label&gt;</div><div class="line">                    &lt;span&gt;Confirm address&lt;/span&gt;</div><div class="line">                    &lt;input type=&quot;email&quot; placeholder=&quot;Confirm your email address&quot; formControlName=&quot;confirm&quot;&gt;</div><div class="line">                &lt;/label&gt;</div><div class="line">                &lt;div *ngIf=&quot;user.get(&apos;account&apos;).touched &amp;&amp; user.get(&apos;name&apos;).hasError(&apos;nomatch&apos;)&quot;&gt;</div><div class="line">                    name is required</div><div class="line">                &lt;/div&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">            &lt;button type=&quot;submit&quot; [disabled]=&quot;user.invalid&quot;&gt;Sign up&lt;/button&gt;</div><div class="line">        &lt;/form&gt;</div><div class="line">    `</div><div class="line">&#125;)</div><div class="line">export class SignUpFormCOmponent implements OnInit &#123;</div><div class="line">    user: FormGroup;</div><div class="line">    constructor(private fb: FormBuilder)&#123;&#125;</div><div class="line">    ngOnInit() &#123;</div><div class="line">        this.user = this.fb.group(&#123;</div><div class="line">            name: [&apos;&apos;, Validators.required],</div><div class="line">            account: this.fb.group(&#123;</div><div class="line">                email: [&apos;&apos;, Validators.required],</div><div class="line">                confirm: [&apos;&apos;, Validators.rquired],</div><div class="line">            &#125;, &#123;validator: emailMatcher&#125;)</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<font face="黑体" color="#f00" size="3">对比创建表单自定义验证指令</font>

<p>模版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;input name=&quot;password&quot; formControlName=&quot;password&quot; validateEqual=&quot;password&quot;&gt;</div><div class="line">&lt;input name=&quot;confirmpassword&quot; formControlName=&quot;confirmpassword&quot; validateEqual=&quot;password&quot;&gt;</div></pre></td></tr></table></figure></p>
<p>validateEqual指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">import &#123; Directive, forwardRef, Attribute &#125; from &apos;@angular/core&apos;;</div><div class="line">import &#123; Validator, AbstractControl, NG_VALIDATORS &#125; from &apos;@angular/forms&apos;;</div><div class="line">@DIrective(&#123;</div><div class="line">    selector: &apos;[validateEqual][formControlName], [validateEqual][formControl],[validateEqual][ngModel]&apos; ,</div><div class="line">    providers: [&#123;</div><div class="line">        provide: NG_VALIDATORS,</div><div class="line">        useExisting: forward(() =&gt; EqualValidator),</div><div class="line">        multi: true</div><div class="line">    &#125;]</div><div class="line">    扩展</div><div class="line">&#125;)</div><div class="line">export class EqualValidator implements Validator &#123;</div><div class="line">    constructor(@Attribute(&apos;validateEqual&apos;) public validateEqual: string)&#123;&#125;</div><div class="line">    validate(control: AbstractControl): &#123; [key:string]: boolean &#125; &#123;</div><div class="line">        let v  = control.value;  使用指令的控件自身值: confirmpassword</div><div class="line">        let e  = control.root.get(this.validateEqual);  指令指定的控件: passwordControl;</div><div class="line">        if (e &amp;&amp; v !== e.value) &#123;</div><div class="line">            return &#123; validateEqual: false&#125;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="验证器添加到指定控件，造成只有该控件数值变化才会进行验证，先输入confirmPassword造成验证器失效，需要给验证器添加reverse属性"><a href="#验证器添加到指定控件，造成只有该控件数值变化才会进行验证，先输入confirmPassword造成验证器失效，需要给验证器添加reverse属性" class="headerlink" title="验证器添加到指定控件，造成只有该控件数值变化才会进行验证，先输入confirmPassword造成验证器失效，需要给验证器添加reverse属性"></a>验证器添加到指定控件，造成只有该控件数值变化才会进行验证，先输入confirmPassword造成验证器失效，需要给验证器添加reverse属性</h4><h3 id="Forward-Reference"><a href="#Forward-Reference" class="headerlink" title="Forward Reference"></a>Forward Reference</h3><h4 id="不论es6、es7、还是ts作为开发语言，现阶段最终都会编译为es5的代码。es5中只有function并没有class。造成js代码编译阶段只有变量声明和函数声明会自动提升，而函数表达式并不会自动提升。所以要解决此问题可以使用Angular2提供的forward-reference特性进行解决-Buffer顺序在Socket之前声明也可以，但是angular项目中模块组件化开发确认注入依赖的顺序性会带来更大负担-。"><a href="#不论es6、es7、还是ts作为开发语言，现阶段最终都会编译为es5的代码。es5中只有function并没有class。造成js代码编译阶段只有变量声明和函数声明会自动提升，而函数表达式并不会自动提升。所以要解决此问题可以使用Angular2提供的forward-reference特性进行解决-Buffer顺序在Socket之前声明也可以，但是angular项目中模块组件化开发确认注入依赖的顺序性会带来更大负担-。" class="headerlink" title="不论es6、es7、还是ts作为开发语言，现阶段最终都会编译为es5的代码。es5中只有function并没有class。造成js代码编译阶段只有变量声明和函数声明会自动提升，而函数表达式并不会自动提升。所以要解决此问题可以使用Angular2提供的forward reference特性进行解决(Buffer顺序在Socket之前声明也可以，但是angular项目中模块组件化开发确认注入依赖的顺序性会带来更大负担)。"></a>不论es6、es7、还是ts作为开发语言，现阶段最终都会编译为es5的代码。es5中只有function并没有class。造成js代码编译阶段只有变量声明和函数声明会自动提升，而函数表达式并不会自动提升。所以要解决此问题可以使用Angular2提供的forward reference特性进行解决(Buffer顺序在Socket之前声明也可以，但是angular项目中模块组件化开发确认注入依赖的顺序性会带来更大负担)。</h4><font face="黑体" color="#f00" size="3">es6+中的class不进行自动提升主要为了解决继承父类时，父类不可用的问题</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import &#123; forwardRef, Injectable &#125; from &apos;@angular2/core&apos;</div><div class="line">@Injectable()</div><div class="line">class Socket &#123;</div><div class="line">    constructor(@Inject(forwardRef(() =&gt; Buffer)) private buffer) &#123;&#125;</div><div class="line">&#125;</div><div class="line">class Buffer &#123;</div><div class="line">    constructor(@Inject(BUFFER_SIZE) private size: Number) &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="OpaqueToken"><a href="#OpaqueToken" class="headerlink" title="OpaqueToken"></a>OpaqueToken</h3><h4 id="OpaqueToken允许创建基于字符串的Token类-在Provider中使用。只需导入Opaque类。"><a href="#OpaqueToken允许创建基于字符串的Token类-在Provider中使用。只需导入Opaque类。" class="headerlink" title="OpaqueToken允许创建基于字符串的Token类,在Provider中使用。只需导入Opaque类。"></a>OpaqueToken允许创建基于字符串的Token类,在Provider中使用。只需导入Opaque类。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import &#123; OpaqueToken &#125; from &apos;@angular/core&apos;;</div><div class="line">const CONFIG_TOKEN = new OpaqueToken(&apos;config&apos;);</div><div class="line">export const THIRDPARTYLIBPROVIDERS = [</div><div class="line">    &#123;</div><div class="line">        provide: CONFIG_TOKEN, useClass: ThirdPartyConfig</div><div class="line">    &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>OpaqueToken类的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">export class OpaqueToken &#123;</div><div class="line">    constructor(protected _desc: string) &#123;&#125;</div><div class="line">    toString() : string &#123;</div><div class="line">        return `Token$&#123;this._desc&#125;`</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>OpaqueToken类的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import &#123; ReflectiveInjector, OpaquToken &#125; from &apos;@angular/core&apos;;</div><div class="line">const t = new OpaquToken(&apos;value&apos;);</div><div class="line">const injector = ReflectiveInjector.resolveAndCreate([</div><div class="line">    &#123;</div><div class="line">        provide: t,</div><div class="line">        useValue: &apos;bindingValue&apos;</div><div class="line">    &#125;</div><div class="line">]);</div><div class="line">injector.get(t)  // &apos;bindingValue&apos;</div></pre></td></tr></table></figure></p>
<h3 id="InjectionToken-Angular4"><a href="#InjectionToken-Angular4" class="headerlink" title="InjectionToken (Angular4+)"></a>InjectionToken (Angular4+)</h3><h4 id="使用ValueProvider"><a href="#使用ValueProvider" class="headerlink" title="使用ValueProvider"></a>使用ValueProvider</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@NgModule(&#123;</div><div class="line">    ...,</div><div class="line">    providers: [</div><div class="line">        &#123;</div><div class="line">            provide: &apos;apiUrl&apos;,</div><div class="line">            userValue: &apos;http://localhost:4200/heroes&apos;</div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    bootstrap: [AppComponent]</div><div class="line">&#125;)</div><div class="line">export class AppModule &#123;&#125;</div></pre></td></tr></table></figure>
<h4 id="注入ProviderValue"><a href="#注入ProviderValue" class="headerlink" title="注入ProviderValue"></a>注入ProviderValue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Injectable()</div><div class="line">export class HeroService &#123;</div><div class="line">    constructor(</div><div class="line">        private loggerService: LoggerService,</div><div class="line">        @Inject(&apos;apiUrl&apos;) private apiUrl: String</div><div class="line">    )&#123;</div><div class="line">        console.log(apiUrl)  //  http://localhost:4200/heroes</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果引入了第三方库且名称相同就产生了问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">export const THIRD_PARTY_PROVIDERS = [</div><div class="line">    &#123;</div><div class="line">        provide: &apos;apiUrl&apos;,   //  与localhost:4200相同</div><div class="line">        userValue: &apos;http://192.168.18.59:4200&apos;</div><div class="line">    &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>更新Provider配置信息则如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import &#123; THIRD_PARTY_PROVIDERS &#125; from &apos;./third-party&apos;;</div><div class="line">@NgModule(&#123;</div><div class="line">    ...,</div><div class="line">    providers: [</div><div class="line">        &#123;</div><div class="line">        provide: &apos;apiUrl&apos;,</div><div class="line">        useValue: &apos;http://localhost:4200/heros&apos;</div><div class="line">        &#125;,</div><div class="line">        THIRD_PARTY_PROVIDERS</div><div class="line">    ],</div><div class="line">    bootstrap: [AppComponent]</div><div class="line">&#125;)</div><div class="line">export class AppModule &#123; &#125;</div></pre></td></tr></table></figure></p>
<font face="黑体" color="#f00" size="3">localhost:4200被覆盖</font>

<h4 id="使用字符串作为Token起冲突了。所以利用InjectionToken-Angular4-统一管理Token信息。"><a href="#使用字符串作为Token起冲突了。所以利用InjectionToken-Angular4-统一管理Token信息。" class="headerlink" title="使用字符串作为Token起冲突了。所以利用InjectionToken(Angular4+)统一管理Token信息。"></a>使用字符串作为Token起冲突了。所以利用InjectionToken(Angular4+)统一管理Token信息。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import &#123; InjectionToken &#125; from &apos;@angular/core&apos;;</div><div class="line">export const API_URL = new InjectionToken&lt;string&gt;(&apos;apiUrl&apos;);</div></pre></td></tr></table></figure>
<h4 id="OpaqueToken-与-InjectionToken-异同点"><a href="#OpaqueToken-与-InjectionToken-异同点" class="headerlink" title="OpaqueToken 与 InjectionToken 异同点"></a>OpaqueToken 与 InjectionToken 异同点</h4><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ul>
<li>创建可在Provider中使用的Token</li>
</ul>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul>
<li>前者ng2的类，后者ng4+引入的类，继承自OpaqueToken，且引入了泛型用于定义所关联的依赖对象的类型</li>
</ul>
<h2 id="Es6-Set-Map"><a href="#Es6-Set-Map" class="headerlink" title="Es6 Set Map"></a>Es6 Set Map</h2><h3 id="Es6提供了新的数据结构Set。类似于数组，但是成员都是唯一的，没有重复的值。接受一个数组或类数组对象作为参数"><a href="#Es6提供了新的数据结构Set。类似于数组，但是成员都是唯一的，没有重复的值。接受一个数组或类数组对象作为参数" class="headerlink" title="Es6提供了新的数据结构Set。类似于数组，但是成员都是唯一的，没有重复的值。接受一个数组或类数组对象作为参数"></a>Es6提供了新的数据结构Set。类似于数组，但是成员都是唯一的，没有重复的值。接受一个数组或类数组对象作为参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const set = new Set([1,2,3,4,2]);</div><div class="line">[...set]    // [1,2,3,4]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const set = new Set();</div><div class="line">[1,2,2,2,3,4].map(x =&gt; set.add(x));</div><div class="line">set   // [1,2,3,4]</div></pre></td></tr></table></figure>
<h4 id="Set内部，两个对象不相等，两个NaN相等，用length检测-可以用for…of遍历"><a href="#Set内部，两个对象不相等，两个NaN相等，用length检测-可以用for…of遍历" class="headerlink" title="Set内部，两个对象不相等，两个NaN相等，用length检测,可以用for…of遍历"></a>Set内部，两个对象不相等，两个NaN相等，用length检测,可以用for…of遍历</h4><ul>
<li><p>add(value)</p>
</li>
<li><p>delete(value) </p>
</li>
<li><p>has(value)</p>
</li>
<li><p>clear()</p>
</li>
</ul>
<h3 id="Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键-初始化Map需要一个二维数组，或者直接初始化一个空Map"><a href="#Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键-初始化Map需要一个二维数组，或者直接初始化一个空Map" class="headerlink" title="Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键, 初始化Map需要一个二维数组，或者直接初始化一个空Map"></a>Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键, 初始化Map需要一个二维数组，或者直接初始化一个空Map</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);</div><div class="line">m.get(&apos;Michael&apos;); // 95</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var m = new Map();</div><div class="line">var o = &#123;p: &quot;Hello World&quot;&#125;;</div><div class="line">m.set(o, &quot;content&quot;)</div><div class="line">m.get(o)    // &quot;content&quot;</div><div class="line">m.has(o)    // true</div><div class="line">m.delete(o) // true</div><div class="line">m.has(o)    // false</div></pre></td></tr></table></figure>
<font face="黑体" color="#f00" size="3">只有对同一个对象的引用，Map结构才视为同一个键</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var map = new Map();</div><div class="line">map.set([&apos;a&apos;], 555);</div><div class="line">map.get([&apos;a&apos;])   // undefined</div><div class="line">上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。</div></pre></td></tr></table></figure>
<h3 id="ModuleWithProviders"><a href="#ModuleWithProviders" class="headerlink" title="ModuleWithProviders"></a>ModuleWithProviders</h3><p>创建一个共享模块，包含部分功能性模块、管道、指令、和服务。对于服务，通常作为单例的服务可能被多次提供，可以通过在共享模块内部返回ModuleWithProviders对象的静态方法forRoot解决这类问题, (相对于将service注入在NgModule,通过forRoot方法返回具有NgModule属性的ModuleWithProviders对象，可以解决service多次提供的情况)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import &#123; NgModule, ModuleWithProviders &#125; from &apos;@angular/core&apos;;</div><div class="line">import &#123; someDirective, somePipe, someService &#125; from &apos;./functions&apos;;</div><div class="line">@NgModule(&#123;</div><div class="line">    declarations: [</div><div class="line">        somePipe,</div><div class="line">        someDirective</div><div class="line">    ],</div><div class="line">    exports: [</div><div class="line">        somePipe,</div><div class="line">        someDirective </div><div class="line">    ]</div><div class="line">&#125;)</div><div class="line">export class SharedModule &#123;</div><div class="line">    static forRoot() : ModuleWithProviders &#123;</div><div class="line">        return &#123;</div><div class="line">            ngModule: SharedModule,</div><div class="line">            providers: [ someService ]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>NgModule中并不提供服务，在模块类中定义forRoot静态方法，返回ModuleWithProviders接口对象，在应用模块中导入共享模块并调用静态方法forRoot来提供服务和其他指令管道等,这样根模块会把他得providers添加到根模块的服务提供商中，确切的说是angular会先累加所有的显式注入的提供商，然后进一步追加其他模块的提供商到@NgModule.providers中，可以确保显式添加的提供商优先级大于从其他模块导入的；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import &#123; SharedModule &#125; from &apos;./shared&apos;</div><div class="line">//:...</div><div class="line">@NgModule(&#123;</div><div class="line">    imports: [</div><div class="line">        SharedModule.forRoot()</div><div class="line">    ],</div><div class="line">    //:...</div><div class="line">&#125;)</div><div class="line">export class AppModule &#123;&#125;</div></pre></td></tr></table></figure>
<p>不调用forRoot方法则会只访问共享的管道和指令，不在提供服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import &#123; SharedModule &#125; from &apos;./shared&apos;</div><div class="line">//:...</div><div class="line">@NgModule(&#123;</div><div class="line">    imports: [</div><div class="line">        SharedModule、</div><div class="line">    ],</div><div class="line">    //:...</div><div class="line">&#125;)</div><div class="line">export class AppModule &#123;&#125;</div></pre></td></tr></table></figure>
<font face="黑体" color="#f00" size="3">Angular2中没有模块级别的service,所有在NgModule中声明的Provider都是注册在跟级别的DI中</font>

<h3 id="shadow-DOM-选择器"><a href="#shadow-DOM-选择器" class="headerlink" title="shadow DOM 选择器"></a>shadow DOM 选择器</h3><p>使用emulated进行样式隔离时，可以访问适用于shadow DOM的css选择器</p>
<h4 id="宿主"><a href="#宿主" class="headerlink" title="宿主"></a>宿主</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">:host &#123;</div><div class="line">    color: red;    // &lt;song-track&gt;</div><div class="line">&#125;</div><div class="line">:host(.selected) &#123;</div><div class="line">    color: red;    // &lt;song-track class=&quot;selected&quot;&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="样式依赖于祖先元素"><a href="#样式依赖于祖先元素" class="headerlink" title="样式依赖于祖先元素"></a>样式依赖于祖先元素</h4><p>它会在组件的宿主元素的祖先元素中查找汽配的祖先元素直到文档的根</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">:host-content(.selected) &#123;</div><div class="line">    color: red;</div><div class="line">&#125;</div><div class="line">:host-content(#selected) &#123;</div><div class="line">    color: red</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="宿主元素或后代元素-跨边界"><a href="#宿主元素或后代元素-跨边界" class="headerlink" title="宿主元素或后代元素(跨边界)"></a>宿主元素或后代元素(跨边界)</h4><p>它会覆盖任何封装的宿主元素或者其子元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">:host /deep/ .selected&#123;</div><div class="line">    color: red;</div><div class="line">&#125;</div><div class="line">:host &gt;&gt;&gt; .selected&#123;</div><div class="line">    color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<font face="黑体" color="#f00" size="3">angular-cli 启动的项目使用deep而不是&gt;&gt;&gt;</font>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/28/自定义表单/" itemprop="url">
                  自定义表单
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2017-12-28T13:47:16+08:00" content="2017-12-28">
              2017-12-28
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ControlValueAccessor"><a href="#ControlValueAccessor" class="headerlink" title="ControlValueAccessor"></a>ControlValueAccessor</h2><h3 id="它是一个接口用于连接表单模型和视图，自定义表单必须实现这个接口，来实现模型与视图的映射关系"><a href="#它是一个接口用于连接表单模型和视图，自定义表单必须实现这个接口，来实现模型与视图的映射关系" class="headerlink" title="它是一个接口用于连接表单模型和视图，自定义表单必须实现这个接口，来实现模型与视图的映射关系"></a>它是一个接口用于连接表单模型和视图，自定义表单必须实现这个接口，来实现模型与视图的映射关系</h3><p>Angular引入它的原因在于不同的输入控件更新数据方式不同，input或checkbox,但是可以通过ControlValueAccessor统一</p>
<ul>
<li><p>DefaultValueAccessor - text/textarea类型</p>
</li>
<li><p>SelectControlValueAccessor - selec类型</p>
</li>
<li><p>CheckboxControlValueAccessor - checkbox类型</p>
</li>
</ul>
<h2 id="实现ControlValueAccessor接口"><a href="#实现ControlValueAccessor接口" class="headerlink" title="实现ControlValueAccessor接口"></a>实现ControlValueAccessor接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">export interface ControlValueAccessor &#123;</div><div class="line">    writeValue(obj: any): void;     // 将模型中的新值写入视图</div><div class="line">    registerOnChange(fn: any): void;    // 当控件接收到change事件后，调用的函数，通知外部组件发生变化</div><div class="line">    registerOnTouched(fn: any): void;    // 接收到touched事件后调用的函数</div><div class="line">    setDisabledState?(isDisabled: boolean): void;    // 当控件状态变成DISABLED或ENABLE时，调用该函数启用或禁用dom</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Component(...)</div><div class="line">class CounterComponent implements ControlValueAccessor &#123;</div><div class="line">    ...</div><div class="line">    propagateChange = (_: any) =&gt; &#123;&#125;;</div><div class="line">    registerOnChange(fn: any) &#123;</div><div class="line">        this.propagateChange = fn;   //  view层的值发生改变，通知外部</div><div class="line">    &#125;</div><div class="line">    registerOnTouched...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="注册成为表单控件"><a href="#注册成为表单控件" class="headerlink" title="注册成为表单控件"></a>注册成为表单控件</h2><ul>
<li><p>NG_VALUE_ACCESSOR: token类型为ControlValueAccessor,将控件本身注册到DI框架，使其可以被表单访问</p>
</li>
<li><p>NG_VALIDTORS: 将控件注册成为一个可以让表单得到其验证状态的控件，token为function或Validator,配合useExisting可以让控件只暴露出对应的function或Validator的validate方法</p>
</li>
<li><p>forwardRef: 向前引用，允许我们引用一个尚未定义的对象</p>
</li>
<li><p>multi: 设置为true,该token对应多个依赖项，使用相同的token获取依赖项的时候，获取的是已注册的依赖对象列表。如果不是true,那么对于相同的token的提供商来说，后定义的提供商会覆盖前面定义的</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@Component(&#123;</div><div class="line">    selector: &apos;exe-demo&apos;,</div><div class="line">    ...</div><div class="line">    provides: [</div><div class="line">             // 创建Token为NG_VALUE_ACCESSOR的提供商</div><div class="line">        &#123;</div><div class="line">            provide: NG_VALUE_ACCESSOR,</div><div class="line">            useExisting: forwardRef(() =&gt; SomeComponent),</div><div class="line">            multi: true</div><div class="line">        &#125;,</div><div class="line">             // 创建Token为NG_VALIDATORS的表单验证验证器</div><div class="line">        &#123;</div><div class="line">            provide: NG_VALIDATORS,</div><div class="line">            useValue: validateCounterRange,</div><div class="line">            multi: true</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">import &#123; Component, forwardRef , Input &#125; from &apos;@angular/core&apos;;</div><div class="line">import &#123; ControlValueAccessor, NG_VALUE_ACCESSOR, NG_VALIDATORS, </div><div class="line">FormControl, ValidatorFn, ValidationErrors, AbstractControl &#125; from &apos;@angular/forms&apos;;</div><div class="line">export const EXE_COUNTER_VALUE_ACCESSOR: any = &#123;</div><div class="line">    provide: NG_VALUE_ACCESSOR,</div><div class="line">    useExisting: forwardRef(() =&gt; CounterComponent),</div><div class="line">    multi: true</div><div class="line">&#125;</div><div class="line">export const validateCounterRange: ValidatorFn = (control: AbstractControl) : ValidationErrors =&gt; &#123;</div><div class="line">   return ( control.value &gt; 10 || control.value &lt; 0 ) ? </div><div class="line">   &#123;</div><div class="line">       &apos;rangeError&apos;: &#123; current: control.value, max: 10, min: 0&#125;</div><div class="line">   &#125; : null</div><div class="line">&#125;</div><div class="line">export const EXE_COUNTER_VALIDATOR = &#123;</div><div class="line">    provide: NG_VALIDATORS,</div><div class="line">    useValue: validateCounterRange,  </div><div class="line">    multi: true</div><div class="line">&#125;</div><div class="line">@Component(&#123;</div><div class="line">    ...</div><div class="line">    provides: [</div><div class="line">        EXE_COUNTER_VALUE_ACCESSOR,</div><div class="line">        EXE_COUNTER_VALIDATOR</div><div class="line">    ],</div><div class="line">    changeDetection: ChangeDetectionStrategy.OnPush</div><div class="line">&#125;)</div><div class="line">export class CounterComponent implements ControlValueAccessor &#123;</div><div class="line">    @Input() _count: number = 0;</div><div class="line">    get count() &#123;</div><div class="line">        return this._count;</div><div class="line">    &#125;</div><div class="line">    set count(value: number) &#123;</div><div class="line">        this._count = value;</div><div class="line">        this.propagateChange(this._count);</div><div class="line">    &#125;</div><div class="line">    propagateChange = (_: any) =&gt; &#123;&#125;;</div><div class="line">    writeValue(value: any) &#123;</div><div class="line">        if (value) &#123;</div><div class="line">            this.count = value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    registerOnchange(fn: any) &#123;</div><div class="line">        this.propagateChange = fn;</div><div class="line">    &#125;</div><div class="line">    registerOnTouched(fn: any) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    increment() &#123;</div><div class="line">        this.count++;</div><div class="line">    &#125;</div><div class="line">    decrement() &#123;</div><div class="line">        this.count--;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="在Angular中通过Provider来描述与Token相关联的依赖对象的创建方式，分为以下四种"><a href="#在Angular中通过Provider来描述与Token相关联的依赖对象的创建方式，分为以下四种" class="headerlink" title="在Angular中通过Provider来描述与Token相关联的依赖对象的创建方式，分为以下四种"></a>在Angular中通过Provider来描述与Token相关联的依赖对象的创建方式，分为以下四种</h3><ul>
<li><p>useClass</p>
</li>
<li><p>useValue</p>
</li>
<li><p>useExisting</p>
</li>
<li><p>useFactory</p>
</li>
</ul>
<p><img src="https://sfault-image.b0.upaiyun.com/299/404/2994048125-58cc9e6c17087_articlex" alt="relation"></p>
<font color="#f00">useClass</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">providers: [ </div><div class="line">    &#123; provide: ApiService, useClass: ApiService &#125;  // 简介写法直接 ApiService</div><div class="line">]</div></pre></td></tr></table></figure>
<font color="#f00">useValue</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">providers: [ </div><div class="line">    &#123; provide: API_URL, useValue: &apos;http://my.api.com/v1&apos; &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<font color="#f00">useExisting</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">providers: [ </div><div class="line">    &#123; provide: &apos;ApiServiceAlias&apos;, useValue: ApiService &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<font color="#f00">useFactory</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">export function configFactory(config: AppConfig) &#123;</div><div class="line">    return () =&gt; config.load();</div><div class="line">&#125;</div><div class="line">providers: [ </div><div class="line">    &#123; provide: APP_INITIALIZER, useFactory: configFactory,</div><div class="line">    deps: [AppConfig, multi: true] &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/15/12-15  日常笔记/" itemprop="url">
                  12-15  日常笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2017-12-15T10:30:16+08:00" content="2017-12-15">
              2017-12-15
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="日常遗忘知识点总结"><a href="#日常遗忘知识点总结" class="headerlink" title="日常遗忘知识点总结"></a>日常遗忘知识点总结</h2><h3 id="利用伪类实现自定义title"><a href="#利用伪类实现自定义title" class="headerlink" title="利用伪类实现自定义title"></a>利用伪类实现自定义title</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;span mytitle=&quot;hello world&quot;&gt;Today is Friday&lt;/span&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">span[mytitle]:hover::after&#123;</div><div class="line">    content: attr(mytitle);</div><div class="line">    position: absolute;</div><div class="line">    right:0</div><div class="line">    color: #ff0;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="伪类清除浮动"><a href="#伪类清除浮动" class="headerlink" title="伪类清除浮动"></a>伪类清除浮动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;parent&quot;&gt;</div><div class="line">    &lt;div class=&quot;child1&quot; style=&quot;float:left;width:25%;&quot;&gt;&lt;/div&gt; </div><div class="line">    &lt;div class=&quot;child2&quot; style=&quot;float:right;width:25%;&quot;&gt;&lt;/div&gt; </div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.parent::after&#123;</div><div class="line">    content: &apos;\0020&apos;;</div><div class="line">    height: 0;</div><div class="line">    display: block;</div><div class="line">    clear: both;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h3><blockquote>
<p>引自 <font color="#f00" size="3">大漠老师的文章，进行flex布局的学习与记录总结</font>  <a href="https://www.w3cplus.com/css3/understanding-flexbox-everything-you-need-to-know.html" target="_blank" rel="noopener">原文地址</a></p>
</blockquote>
<p>显式声明flex容器后，启动了一个flexbox格式化上下文。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">    &lt;li&gt;&lt;/li&gt;</div><div class="line">    &lt;li&gt;&lt;/li&gt;</div><div class="line">    &lt;li&gt;&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ul&#123;</div><div class="line">    display: flex;   //或者inline-flex;</div><div class="line">    li &#123;</div><div class="line">        width: 100px;</div><div class="line">        height: 100px;</div><div class="line">        margin: 8px;</div><div class="line">        background-color: #8cacea;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-6.png" alt="flex"></p>
<p>display显示设置了flex属性后，自身变为flex容器，子元素变为了flex项目。</p>
<font color="#f00">容器属性: flex-direction || flex-wrap || flex-flow || justify-content || align-items || align-content</font>

<h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ul&#123;</div><div class="line">    flex-direction: row || column || row-reverse || column-reverse;   // default: row</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>row: 从左向右水平<br>…</p>
<h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ul&#123;</div><div class="line">    flex-wrap: wrap || norwrap || wrap-reverse;   // default: nowrap(不换行)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果拥有大量子元素，会自适应每个元素的大小，全部注入到一行内，即使宽度大于视窗宽度出现滚动条（nowrap）</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-15.png" alt="nowrap"></p>
<p>显示默认宽度都行排列，不会强迫一行有多少个flex项目（wrap）</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-16.png" alt="wrap"></p>
<h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p>是flex-direction和flex-wrap属性的速记属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ul&#123;</div><div class="line">    flex-flow: row wrap;</div><div class="line">    相当于  // flex-direction: row; flex-wrap: wrap;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><font color="#f00">接受属性值: flex-start || flex-end || center || space-between || space-around</font>


<p>flex-start: 左对齐 （default）</p>
<p>flex-end: 右对齐</p>
<p>center: 居中对齐</p>
<p>space-between: 两端对齐(除了第一个和最后一个部分，间距相等)</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-24.jpeg" alt="space-between"></p>
<p>space-around: 让每个flex元素都具有相同的空间</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-26.jpeg" alt="space-between"></p>
<h4 id="align-items-（不同于justify-content，它处理的是容器的纵向排列）"><a href="#align-items-（不同于justify-content，它处理的是容器的纵向排列）" class="headerlink" title="align-items （不同于justify-content，它处理的是容器的纵向排列）"></a>align-items （不同于justify-content，它处理的是容器的纵向排列）</h4><font color="#f00">接受属性值: flex-start || flex-end || center || stretch || baseline</font>


<p>stretch: 所有flex元素高度和容器高度一样 （default）</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-27.png" alt="stretch"></p>
<p>flex-start: 顶部对齐</p>
<p>flex-end: 底部对齐</p>
<p>center: 居中对齐</p>
<p>baseline: 沿着自身的基线对齐</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-32.jpeg" alt="baseline"></p>
<h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p>添加大量子元素，让其多行排列，该属性用于控制多行排列的flex容器的排列方式，效果类似align-items，expect baseline</p>
<font color="#f00">接受属性值: flex-start || flex-end || center || stretch</font>


<p>stretch: 纵向适应可用空间 （default）</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-33.png" alt="stretch"></p>
<p>flex-start: 沿着顶部到底部排列</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-34.png" alt="flex-start"></p>
<p>flex-end: 沿着低部到顶部排列</p>
<p>center: 居中</p>
<h2 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="未完待续。。。"></a>未完待续。。。</h2><h2 id="12-18-继续flex布局要点学习"><a href="#12-18-继续flex布局要点学习" class="headerlink" title="12.18 继续flex布局要点学习"></a>12.18 继续flex布局要点学习</h2><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p>允许flex项目在flex容器内重新排序，默认值为0，可以接受负值</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-38.png" alt="order=0"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">li:nth-child(1)&#123; </div><div class="line">    order: 1; /*设置一个比0更大的值*/ </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从低到高拍下</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-39.png" alt="order=1"></p>
<h4 id="flex-grow-flex-shrink"><a href="#flex-grow-flex-shrink" class="headerlink" title="flex-grow | flex-shrink"></a>flex-grow | flex-shrink</h4><p>控制flex项目在容器的空间上进行扩展; 接受0或者大于0的任何正数，默认为0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&lt;ul&gt; </div><div class="line">    &lt;li&gt;I am a simple list&lt;/li&gt; </div><div class="line">&lt;/ul&gt; </div><div class="line"></div><div class="line">ul &#123; </div><div class="line">    display: flex; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当把flex-grow设置为1的时候，填充多余空间</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-43.png" alt="flex-grow"></p>
<p>当有多个flex项目需要进行扩展比设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#main div:nth-of-type(1) &#123;flex-grow: 1;&#125;</div><div class="line">#main div:nth-of-type(2) &#123;flex-grow: 3;&#125;</div><div class="line">#main div:nth-of-type(3) &#123;flex-grow: 1;&#125;</div><div class="line">#main div:nth-of-type(4) &#123;flex-grow: 1;&#125;</div><div class="line">#main div:nth-of-type(5) &#123;flex-grow: 1;&#125;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/vernvn/hexoBlog/blob/master/decImg/222.png?raw=true" alt="flex-grow"></p>
<p>当把flex-shrink设置为大于1的时候，缩小flex项目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;ul class=&quot;flex&quot;&gt;</div><div class="line">    &lt;li&gt;a&lt;/li&gt;</div><div class="line">    &lt;li&gt;b&lt;/li&gt;</div><div class="line">    &lt;li&gt;c&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line"></div><div class="line">flex &#123;display:flex;width:400px;margin:0;padding:0;list-style:none;&#125;</div><div class="line">flex li&#123;width:200px;&#125;</div><div class="line">flex li:nth-child(3)&#123;flex-shrink:3;&#125;</div></pre></td></tr></table></figure>
<p>flex-shrink默认值为1，接受正整数，压缩空间比,c显式的定义了flex-shrink，a,b没有显式定义，但将根据默认值1来计算，可以看到总共将剩余空间分成了5份，其中a占1份，b占1份，c占3分，即1:1:3<br>我们可以看到父容器定义为400px，子项被定义为200px，相加之后即为600px，超出父容器200px。那么这么超出的200px需要被a,b,c消化<br>通过收缩因子，所以加权综合可得200 <em> 1+200 </em> 1+200 <em> 3=1000px；<br>于是我们可以计算a,b,c将被移除的溢出量是多少：<br>a被移除溢出量：(200</em>1/1000)<em>200，即约等于40px<br>b被移除溢出量：(200</em>1/1000)<em>200，即约等于40px<br>c被移除溢出量：(200</em>3/1000)*200，即约等于120px<br>最后a,b,c的实际宽度分别为：200-40=160px, 200-40=160px, 200-120=80px</p>
<h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>初始化flex项目的大小。默认值auto.接受任何用于width的值。px | % | rem | em; 如果为0也需要加单位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">li &#123;</div><div class="line">    flex-basis: 150px;   // 初始固定大小</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="flex速记"><a href="#flex速记" class="headerlink" title="flex速记"></a>flex速记</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">li&#123;</div><div class="line">    flex: 0 1 auto;  // flex-grow、flex-shrink、flex-basis </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p>改变一个弹性项目沿着侧轴的位置而不影响弹性项目</p>
<font color="#f0f">接受属性值: auto || flex-start || flex-end || center || stretch || baseline</font>

<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-55.png" alt="stretch"></p>
<font color="#f0f">auto为设置为父元素的align-items的值，若没有父元的话，设置为stretch</font>

<h3 id="绝对和相对flex项目"><a href="#绝对和相对flex项目" class="headerlink" title="绝对和相对flex项目"></a>绝对和相对flex项目</h3><p>二者区别在于间距的计算，相对flex项目的间距根据内容大小计算，绝对flex项目的间距根据flex属性计算，而不是内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">li&#123;</div><div class="line">    flex: 1 1 auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-59.png" alt="relative"></p>
<p>flex-basis: auto; 宽度自动计算; 此时为相对flex项目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">li&#123;</div><div class="line">    flex: 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>flex项目变为绝对的了，<font color="#f0f">宽度计算依据flex属性</font></p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1702/understanding-flexbox-61.png" alt="relative"></p>
<p>flex-basis: 0;  基于flex-grow共享可用空间</p>
<font color="#f00" size="3">所有Flexbox属性都是基于合适的flex-direction起作用。</font>


<font color="#f0f" size="3">当在Flex项目上使用 margin: auto 时，值为 auto 的方向（左、右或者二者都是）会占据所有剩余空间</font>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/11/路由守卫及加载策略/" itemprop="url">
                  路由守卫及加载策略
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2017-12-11T17:18:16+08:00" content="2017-12-11">
              2017-12-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><p>任何时候导航到任何地方往往不能满足业务需求，需要授权守护。返回值是boolean的三种形式</p>
<ul>
<li>Observable<boolean></boolean></li>
<li>Promise<boolean></boolean></li>
<li>boolean</li>
</ul>
<p>往往同步守卫不是一个好的选择，阻塞的情况时常发生。如果返回true，导航继续，否则，导航终止，停留原地</p>
<h4 id="The-router-supports-multiple-guard-interfaces"><a href="#The-router-supports-multiple-guard-interfaces" class="headerlink" title="The router supports multiple guard interfaces:"></a>The router supports multiple guard interfaces:</h4><ul>
<li><a href="https://www.angular.cn/api/router/CanActivate" target="_blank" rel="noopener">CanActivate</a>: 导航到某路由</li>
<li><a href="https://www.angular.cn/api/router/CanActivateChild" target="_blank" rel="noopener">CanActivateChild</a>: 导航到某子路由</li>
<li><a href="https://www.angular.cn/api/router/CanDeactivate" target="_blank" rel="noopener">CanDeactivate</a>: 处理当前路由离开情况</li>
<li><a href="https://www.angular.cn/api/router/Resolve" target="_blank" rel="noopener">Resolve</a>: 激活前获取路由数据</li>
<li><a href="https://www.angular.cn/api/router/CanLoad" target="_blank" rel="noopener">Canload</a>: 异步导航特性模块</li>
</ul>
<h4 id="在分层路由的每个级别上，我们都可以设置多个守卫。-路由器会先按照从最深的子路由由下往上检查的顺序来检查CanDeactivate-和CanActivateChild-守卫。-然后它会按照从上到下的顺序检查CanActivate-守卫。-如果特性模块是异步加载的，在加载它之前还会检查CanLoad-守卫。-如果任何一个守卫返回false，其它尚未完成的守卫会被取消，这样整个导航就被取消了。"><a href="#在分层路由的每个级别上，我们都可以设置多个守卫。-路由器会先按照从最深的子路由由下往上检查的顺序来检查CanDeactivate-和CanActivateChild-守卫。-然后它会按照从上到下的顺序检查CanActivate-守卫。-如果特性模块是异步加载的，在加载它之前还会检查CanLoad-守卫。-如果任何一个守卫返回false，其它尚未完成的守卫会被取消，这样整个导航就被取消了。" class="headerlink" title="在分层路由的每个级别上，我们都可以设置多个守卫。 路由器会先按照从最深的子路由由下往上检查的顺序来检查CanDeactivate()和CanActivateChild()守卫。 然后它会按照从上到下的顺序检查CanActivate()守卫。 如果特性模块是异步加载的，在加载它之前还会检查CanLoad()守卫。 如果任何一个守卫返回false，其它尚未完成的守卫会被取消，这样整个导航就被取消了。"></a>在分层路由的每个级别上，我们都可以设置多个守卫。 路由器会先按照从最深的子路由由下往上检查的顺序来检查CanDeactivate()和CanActivateChild()守卫。 然后它会按照从上到下的顺序检查CanActivate()守卫。 如果特性模块是异步加载的，在加载它之前还会检查CanLoad()守卫。 如果任何一个守卫返回false，其它尚未完成的守卫会被取消，这样整个导航就被取消了。</h4><h3 id="特性模块的授权验证"><a href="#特性模块的授权验证" class="headerlink" title="特性模块的授权验证"></a>特性模块的授权验证</h3><p>匿名用户会重定向到登录页，因为区分用户是否授权，所以创建在根目录下(auth-guard.ts)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import &#123; Injectable &#125; from &apos;@angular/core&apos;;</div><div class="line">import &#123; CanActivate, Router, ActivatedRouteSnapshot, RouterStateSnapshot &#125; from &apos;@angular/rotuer&apos;;</div><div class="line">@Injectable()</div><div class="line">export class AuthGuard implements CanActivate &#123;</div><div class="line">   constructor(private router: Router) &#123;&#125;</div><div class="line">   canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) &#123;</div><div class="line">        let url = state.url;</div><div class="line">        return this.checkLogin(url);</div><div class="line">   &#125;</div><div class="line">   checkLogin(url: string): boolean &#123;</div><div class="line">       if (&apos;登录成功标识&apos;) &#123;</div><div class="line">           reutrn true;</div><div class="line">       &#125;</div><div class="line">       this.router.navigate([&apos;/login&apos;]);</div><div class="line">       return false</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<font color="#f00" size="3">ActivatedRouteSnapshot包含即将被激活的路由，RouterStateSnapshot包含即将到达的状态</font>   

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import &#123; AuthGuard &#125; from &apos;../aut-guard.service&apos;;</div><div class="line">const routes : Routes = [</div><div class="line">    path: &apos;admin&apos;,</div><div class="line">    component: AdminComponent,</div><div class="line">    canActive: [AuthGuard],</div><div class="line">    ...</div><div class="line">]</div><div class="line">@NgModule(&#123;</div><div class="line">    providers: [</div><div class="line">        AuthGuard</div><div class="line">    ],</div><div class="line">    &apos;&apos;&apos;</div><div class="line">&#125;)</div><div class="line">...</div></pre></td></tr></table></figure>
<h3 id="CanActivateChild区别在于子路由被激活前的守卫"><a href="#CanActivateChild区别在于子路由被激活前的守卫" class="headerlink" title="CanActivateChild区别在于子路由被激活前的守卫"></a>CanActivateChild区别在于子路由被激活前的守卫</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import &#123; CanActivateChild &#125; from &apos;@angular/router&apos;;</div><div class="line">canActivateChild(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean &#123;</div><div class="line">    return this.canActivate(route, state);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">const routes : Routes = [</div><div class="line">    path: &apos;admin&apos;,</div><div class="line">    component: AdminComponent,</div><div class="line">    canActive: [AuthGuard],</div><div class="line">    children: [</div><div class="line">        &#123;</div><div class="line">            path: &apos;&apos;,</div><div class="line">            canActivateChild: [AuthGuard],</div><div class="line">            children: [</div><div class="line">                ...</div><div class="line">            ]</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">]</div><div class="line">...</div></pre></td></tr></table></figure>
<h3 id="CanDeactivate-处理未保存的更改-不保存并离开-true-保留更改并留下-false"><a href="#CanDeactivate-处理未保存的更改-不保存并离开-true-保留更改并留下-false" class="headerlink" title="CanDeactivate 处理未保存的更改;不保存并离开(true),保留更改并留下(false)"></a>CanDeactivate 处理未保存的更改;不保存并离开(true),保留更改并留下(false)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">canDeactivate(): Observable&lt;boolean&gt; | promise&lt;boolean&gt; | boolean &#123;</div><div class="line">    if (!this.changeStatus) &#123; </div><div class="line">        return true;   //如果没有改变直接导航，否则弹框</div><div class="line">    &#125;</div><div class="line">    return this.someService.confirm(&apos;discard changes?&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    path: &apos;:id&apos;,</div><div class="line">    component: CrisisDetailComponent,</div><div class="line">    canDeactivate: [CanDeactivateGuard]</div><div class="line">&#125;</div><div class="line">@NgModule(&#123;</div><div class="line">    providers: [</div><div class="line">        CanDeactivateGuard</div><div class="line">    ],</div><div class="line">    &apos;&apos;&apos;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="Resolve-预先获取数据"><a href="#Resolve-预先获取数据" class="headerlink" title="Resolve 预先获取数据"></a>Resolve 预先获取数据</h3><p>如果响应时间够长，就需要预先从服务器上获取数据，路由激活瞬间数据渲染完毕，此处需要Resolve守卫。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">resolve(route: activatedRouteSnapshot, state: RouterStateSnapshot):Observable&lt;any&gt;&#123;</div><div class="line">   const id = route.paramMap.get(&apos;id&apos;);</div><div class="line">   return this.someService.getDate(id).map(x =&gt; &#123;</div><div class="line">       if (x) &#123;</div><div class="line">           return x;</div><div class="line">       &#125;else &#123;</div><div class="line">           this.router.naviagte([&apos;./someWhere&apos;]);</div><div class="line">           return null;</div><div class="line">       &#125;</div><div class="line">   &#125;)</div><div class="line">&#125;</div><div class="line">// 此处可以阻止路由被加载，直到数据获取完毕,如果没有数据获取则导航回指定路由，并且NgModule的providers中需要注册</div></pre></td></tr></table></figure>
<h3 id="异步路由"><a href="#异步路由" class="headerlink" title="异步路由"></a>异步路由</h3><p>异步路由可以在获取请求时惰性加载特性模块，并且带来了一下好处</p>
<ul>
<li>对于体积庞大的特性模块可以在用户请求时进行加载</li>
<li>持续扩充特性模块的功能，不用增加初始加载的体积及速度</li>
<li>模块化开发提升开发效率，结构分明</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    path: &apos;admin&apos;,</div><div class="line">    loadChildren: &apos;app/admin/admin.module#AdminModule&apos;   // 相对于app目录</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<font color="#f00" size="3">惰性加载只会发生一次，在该路由首次被请求时，后续的请求是立即可用的</font>

<h3 id="Canload守卫-保护对特性模块的未授权加载"><a href="#Canload守卫-保护对特性模块的未授权加载" class="headerlink" title="Canload守卫 保护对特性模块的未授权加载"></a>Canload守卫 保护对特性模块的未授权加载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">canload(route: Route): boolean &#123;</div><div class="line">    let url = `$&#123;route.path&#125;`;   // route为准备访问的目标地址</div><div class="line">    return this.checkLogin(url);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    path: &apos;admin&apos;,</div><div class="line">    loadChildren: &apos;app/admin/admin.module#AdminModule&apos;,</div><div class="line">    canLoad: [AuthGuard]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<font color="#f00" size="3">路由加载形式:立即加载、惰性加载、预加载</font>

<h4 id="预加载好比后台加载，在保证了尽可能小的初始加载体积和首屏加载速度的同时，同样满足了特性模块的按需加载-理想情况下，首屏加载完毕后会有一个短暂的空档期，如果此时完成了接下来将要访问的模块的加载成功，体验会有很大提高。此时的加载就是预加载。"><a href="#预加载好比后台加载，在保证了尽可能小的初始加载体积和首屏加载速度的同时，同样满足了特性模块的按需加载-理想情况下，首屏加载完毕后会有一个短暂的空档期，如果此时完成了接下来将要访问的模块的加载成功，体验会有很大提高。此时的加载就是预加载。" class="headerlink" title="预加载好比后台加载，在保证了尽可能小的初始加载体积和首屏加载速度的同时，同样满足了特性模块的按需加载;理想情况下，首屏加载完毕后会有一个短暂的空档期，如果此时完成了接下来将要访问的模块的加载成功，体验会有很大提高。此时的加载就是预加载。"></a>预加载好比后台加载，在保证了尽可能小的初始加载体积和首屏加载速度的同时，同样满足了特性模块的按需加载;理想情况下，首屏加载完毕后会有一个短暂的空档期，如果此时完成了接下来将要访问的模块的加载成功，体验会有很大提高。此时的加载就是预加载。</h4><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>导航完成后，路由器会查找没有加载但是可以加载的模块，此时预加载策略决定了是否加载以及加载哪些模块。</p>
<h4 id="Router内置了两种预加载策略"><a href="#Router内置了两种预加载策略" class="headerlink" title="Router内置了两种预加载策略"></a>Router内置了两种预加载策略</h4><ul>
<li>完全不预加载，默认</li>
<li>预加载所有特性模块: PreloadAllModules</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import &#123; PreloadAllModules, RouterModule &#125; from &apos;@angular/router&apos;</div><div class="line">RouterModule.forRoot(appRoutes, &#123;</div><div class="line">    preloadingStrategy: PreloadAllModules</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<font color="#f00" size="3">CanLoad守卫会阻塞预加载策略，优先级高于预加载策略</font>

<h3 id="自定义预加载策略"><a href="#自定义预加载策略" class="headerlink" title="自定义预加载策略"></a>自定义预加载策略</h3><p>结合路由定义时的data属性，只预加载preload为true的路由</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    path: &apos;admin&apos;,</div><div class="line">    loadChildren: &apos;app/admin/admin.module#AdminModule&apos;,</div><div class="line">    data: &#123; preload: true &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>添加selective-preloading-strategy.ts,实现自定义预加载策略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import &#123; PreloadingStrategy , Route &#125; from &apos;@angular/router&apos;;</div><div class="line">@Injectable()</div><div class="line">export class SelectivePreloadingStrategy implements PreloadingStrategy &#123;</div><div class="line">    preloadModules: string[] = [];</div><div class="line">    preload(route: Route, load: () =&gt; Observable&lt;any&gt;) : Observable&lt;any&gt; &#123;</div><div class="line">        if (route.data &amp;&amp; route.data[&apos;preload&apos;]) &#123;</div><div class="line">            this.preloadModules.push(route.path);</div><div class="line">            return load();</div><div class="line">        &#125; else &#123;</div><div class="line">            return Observable.of(null);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="如果要进行预加载，返回一个靠用加载器的Observable，否则返回一个null值的Observable对象。"><a href="#如果要进行预加载，返回一个靠用加载器的Observable，否则返回一个null值的Observable对象。" class="headerlink" title="如果要进行预加载，返回一个靠用加载器的Observable，否则返回一个null值的Observable对象。"></a>如果要进行预加载，返回一个靠用加载器的Observable，否则返回一个null值的Observable对象。</h4><h3 id="重定向迁移URL"><a href="#重定向迁移URL" class="headerlink" title="重定向迁移URL"></a>重定向迁移URL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; path: &apos;heroe/:id&apos;, redirectTo: &apos;/superHero/:id&apos;&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RouterModule.forRoot(rotues, &#123; useHash: true &#125;) // 基于HashLocationStrategy</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/29/装饰器、泛型/" itemprop="url">
                  装饰器、泛型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2017-10-29T10:00:16+08:00" content="2017-10-29">
              2017-10-29
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><h3 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h3><p>LogComponent组件只为负责打印日志，通过log装饰器修饰printLog方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">export class LogComponent &#123;</div><div class="line">    @log</div><div class="line">    printLog(str) &#123;</div><div class="line">        return str;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">function log(target: Object, propertyKey: string, descriptor: TypedPropertyDescriptor&lt;any&gt;) &#123;</div><div class="line">    // descriptor is a object contains writable, enumberable, configurable, setter, getter, value;</div><div class="line">    let origin = descriptor.value;</div><div class="line">    descriptor.value = function (...args) &#123;  // apply方法</div><div class="line">        console.log(this); // LogComponent</div><div class="line">        let result = origin.apply(this, args);</div><div class="line">        console.log(&apos;Log is - &apos; + result);</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">    return descriptor;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>应用场景： 可以在其他组件内继承LogComponent，也可以封装为一个service,服务于各个组件，职责单一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">export class AppComponent extends LogComponent  implements OnInit &#123;</div><div class="line">    constructor(</div><div class="line">        private viewContainerRef: ViewContainerRef,</div><div class="line">        private renderer: Renderer2,</div><div class="line">        private elementRef: ElementRef,</div><div class="line">    ) &#123;</div><div class="line">        super();</div><div class="line">    &#125;</div><div class="line">    ngOnInit(): void &#123;</div><div class="line">        this.setupMenus();</div><div class="line">        this.printLog(&apos;test&apos;);</div><div class="line">    &#125;</div><div class="line">    printLog(str) &#123;</div><div class="line">        super.printLog(str);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Injectable()</div><div class="line">export class AppService &#123;</div><div class="line">    login( @Inject name: string) &#123; &#125;   </div><div class="line">&#125;</div><div class="line"></div><div class="line">function Inject(target: Object, propertyKey: string, parameterIndex: number) &#123;</div><div class="line">    console.log(propertyKey); // login 参数名称，注意是方法名</div><div class="line">    console.log(parameterIndex); // 0 参数索引</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="泛型（Generic）"><a href="#泛型（Generic）" class="headerlink" title="泛型（Generic）"></a>泛型（Generic）</h2><p>集合类型如果设置为any可以实现同时支持多种类型，但是放弃了原本支持的类型检查，泛型则是为了解决这一点；帮助进行后面的类型检查</p>
<pre><code>class Name&lt;T&gt;{
    sayName(name:T): void{
        console.log(&apos; hello, i&apos;m &apos; + name);
    }
}
let user1 = new Name&lt;string&gt;();
user1.sayName(&apos;lee&apos;);

let user2 = new Name&lt;number&gt;();
user2.sayName(3);
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/12/常规面试总结2017/" itemprop="url">
                  常规面试总结2017
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2017-09-12T09:59:19+08:00" content="2017-09-12">
              2017-09-12
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常规面试总结2017"><a href="#常规面试总结2017" class="headerlink" title="常规面试总结2017"></a>常规面试总结2017</h1><h4 id="导语："><a href="#导语：" class="headerlink" title="导语："></a>导语：</h4><blockquote>
<p>在2017年对前端领域内的常见的问题进行系统性的总结，说法可能会有所不妥，会综合网上资源发表自己的见解</p>
</blockquote>
<h2 id="1-前端安全的理解与防范"><a href="#1-前端安全的理解与防范" class="headerlink" title="1.前端安全的理解与防范"></a>1.前端安全的理解与防范</h2><p>开发过程中不可避免的会出现漏洞，黑客会抓住漏洞去攻击它获取利益，所以我们需要让我们的应用变的更加安全。</p>
<h3 id="前端攻击有哪些形式，如何防范"><a href="#前端攻击有哪些形式，如何防范" class="headerlink" title="前端攻击有哪些形式，如何防范"></a>前端攻击有哪些形式，如何防范</h3><h4 id="XSS攻击："><a href="#XSS攻击：" class="headerlink" title="XSS攻击："></a>XSS攻击：</h4><p>一种安全漏洞，允许代码植入到其他页面中，通过插入script标签获取用户信息</p>
<p>如何防范： 将前端输入输出数据进行转义，避免使用eval执行个人重要信息，使用httpOnly提升cookie的安全性，限制web页面浏览器端script程序读取cookie。当使用append的时候，Jquery会将元素变为fragment,接着查找其中的script标签，使用eval去执行，会造成之前的问题，所以将输入输出部分进行转义，同样使用img标签时当加载失败时会调用onError方法，此时插入攻击代码同样需要转义进行防范</p>
<h4 id="CSRF攻击："><a href="#CSRF攻击：" class="headerlink" title="CSRF攻击："></a>CSRF攻击：</h4><p>跨站请求伪造，利用一些提交行为转换到操作其他网站（在网站支付时打款被转义到黑客账户）；</p>
<p>如何防范： 遵循http协议，token即时验证，添加验证码阻止信息外泄</p>
<h4 id="控制台注入代码："><a href="#控制台注入代码：" class="headerlink" title="控制台注入代码："></a>控制台注入代码：</h4><p>不懂的人会被欺骗到某个网站在控制台通过执行某段代码暴漏个人信息从而被黑客截取。</p>
<h1 id="2-this指向与箭头函数"><a href="#2-this指向与箭头函数" class="headerlink" title="2.this指向与箭头函数"></a>2.this指向与箭头函数</h1><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p>this在函数执行时被绑定，指向为调用该函数的对象。函数调用模式的不同造就了this指向问题上的差异。<br>函数作为一个对象的方法时，this指向该对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var name = &apos;window&apos;;</div><div class="line">var obj = &#123;</div><div class="line">    name: &apos;lee&apos;,</div><div class="line">    say: function()&#123;</div><div class="line">        console.log(this.name); // lee</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>函数暴漏在全局作用域下，this指向为window<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var name = &apos;window&apos;;</div><div class="line">function say()&#123;</div><div class="line">    console.log(this.name) // lee</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>构造函数内部this指向为构造函数实例对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function Obj()&#123;</div><div class="line">    this.name = &apos;lee&apos;;</div><div class="line">&#125;</div><div class="line">var obj = new Obj();</div><div class="line">obj.name // lee;</div></pre></td></tr></table></figure></p>
<p>改变this指向的方法： apply、call、bind, call与apply的区别在于第二部分参数前者为多个参数，后者为一个参数数组，bind与它们的差异在于只是返回一个改变了this指向的新函数，需要调用，而apply与call在改变了this指向后立即执行了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var name = &quot;window&quot;;</div><div class="line">var person = &#123;</div><div class="line">    name: &quot;lee&quot;</div><div class="line">&#125;;</div><div class="line">function say() &#123;</div><div class="line">    console.log(this.name);</div><div class="line">&#125;</div><div class="line">say();    //window</div><div class="line">say.apply(person);   //lee</div><div class="line">say.call(person);   //lee</div><div class="line">say.bind(person)();   //lee</div><div class="line">say.apply();    //window</div></pre></td></tr></table></figure></p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>es6新增的特性之一，简化了函数定义.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x =&gt; (&#123;</div><div class="line">    foo: x    // 单纯的返回一个表达式对象，注意需要加（）</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>箭头函数内部this是词法作用域，由上下文确定；而函数中的this指向则在函数执行时根据调用模式确定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">    birth: 1990,</div><div class="line">    getAge: function () &#123;</div><div class="line">        var b = this.birth; // 1990</div><div class="line">        var fn = function () &#123;</div><div class="line">            return new Date().getFullYear() - this.birth; // 匿名函数this指向window</div><div class="line">        &#125;;</div><div class="line">        var fn = () =&gt;  new Date().getFullYear() - this.birth; // this指向obj对象</div><div class="line">        </div><div class="line">        return fn();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="3-var-let-const-之间的区别"><a href="#3-var-let-const-之间的区别" class="headerlink" title="3.var let const 之间的区别"></a>3.var let const 之间的区别</h1><p>var定义的变量是该变量作用域的局部变量，可以定义全局变量，但是会污染全局环境不容易维护，不推荐。<br>const定义常量，且不可重新赋值，但是如果定义的变量是一个对象的话，对象内部变量是可以改变的。<br>let声明块级作用域，块作用域内的变量在包含它们的块或for循环之外是不能访问的，否定变量声明提升，对var的一种增强。<br>es6里面不建议使用var，因为其没有块级作用域，非严格模式下会有变量声明提升的情况，会产生意想不到的错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for(var i = 0; i &lt;5; i++)&#123;</div><div class="line">    setTimeout(function()&#123;</div><div class="line">        console.log(i)</div><div class="line">    &#125;,10)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果会是 5 5 5 5 5; 为什么呢，怎么能打印出想要的 0，1,2,3,4,呢？</p>
<p>setTimeout事件在for循环结束后触发，此时i的值为5，解决方法；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for(var i = 0; i&lt;5; i++)&#123;</div><div class="line">    (function(i)&#123;</div><div class="line">        setTimeout(function() &#123; console.log(i); &#125;, 10);</div><div class="line">    &#125;)(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>利用立即执行函数迭代i的值；如果利用块级作用域呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for(let i = 0; i &lt;5; i++)&#123;</div><div class="line">    setTimeout(function()&#123;</div><div class="line">        console.log(i)</div><div class="line">    &#125;,10)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>每次for循环都会产生对应的作用域</p>
<h1 id="4-深拷贝与浅拷贝"><a href="#4-深拷贝与浅拷贝" class="headerlink" title="4.深拷贝与浅拷贝"></a>4.深拷贝与浅拷贝</h1><p>浅拷贝只是复制了对象的指针，不会赋值对象本身，公用一块内存，所以改变一个对象的属性值都会变化，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var a = &#123;</div><div class="line">    name: &apos;john&apos;</div><div class="line">&#125;</div><div class="line">var b = a;</div><div class="line">b.name = &apos;jeff&apos;;</div><div class="line"></div><div class="line">a // &#123; name: &apos;jeff&#125;;</div><div class="line">b // &#123; name: &apos;jeff&#125;;</div></pre></td></tr></table></figure></p>
<p>深拷贝则复制了对象，不会共享内存与指针，修改一个不会影响到另一个；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var a = &#123;</div><div class="line">    name: &apos;john&apos;</div><div class="line">&#125;</div><div class="line">var b = Object.assign(&#123;&#125;, a);</div><div class="line">b.name = &apos;jeff&apos;;</div><div class="line"></div><div class="line">a // &#123; name: &apos;john&#125;;</div><div class="line">b // &#123; name: &apos;jeff&#125;;</div></pre></td></tr></table></figure></p>
<p>但是由于javascript中存储对象都是存地址的，Object.assign的局限性存在于它只是相对浅拷贝深入了一层，换句话就是如果对象的属性值是一个指向对象的引用，它只拷贝那个引用值，可以利用对象字符串的转换（JSON.parse(JSON.stringify(obj)）与递归实现真正的深拷贝。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var obj = &#123; a:1, arr: [2,3] &#125;;</div><div class="line">var shadowObj = Object.assign(&#123;&#125;, obj);</div><div class="line">obj.arr[0] = 22;</div><div class="line">obj.a = 11;</div><div class="line">// obj      &#123; a: 11, arr: [22,3]&#125;</div><div class="line">// shadObj  &#123; a: 1,  arr: [22,3]&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/13/Subject/" itemprop="url">
                  Subject
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2017-04-13T15:28:16+08:00" content="2017-04-13">
              2017-04-13
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Rxjs-Subject-源码片段"><a href="#Rxjs-Subject-源码片段" class="headerlink" title="Rxjs Subject 源码片段"></a>Rxjs Subject 源码片段</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Subject继承于Observable </div><div class="line"> */</div><div class="line">export class Subject extends Observable &#123;</div><div class="line">    constructor() &#123;</div><div class="line">        super();</div><div class="line">        this.observers = []; // 观察者列表  </div><div class="line">        this.closed = false;</div><div class="line">        this.isStopped = false;</div><div class="line">        this.hasError = false;</div><div class="line">        this.thrownError = null;</div><div class="line">    &#125;</div><div class="line">    next(value) &#123;</div><div class="line">        if (this.closed) &#123;</div><div class="line">            throw new ObjectUnsubscribedError();</div><div class="line">        &#125;</div><div class="line">        if (!this.isStopped) &#123;</div><div class="line">            const &#123; observers &#125; = this;</div><div class="line">            const len = observers.length;</div><div class="line">            const copy = observers.slice();</div><div class="line">            for (let i = 0; i &lt; len; i++) &#123; // 循环调用观察者next方法，通知观察者</div><div class="line">                copy[i].next(value);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    error(err) &#123;</div><div class="line">        if (this.closed) &#123;</div><div class="line">            throw new ObjectUnsubscribedError();</div><div class="line">        &#125;</div><div class="line">        this.hasError = true;</div><div class="line">        this.thrownError = err;</div><div class="line">        this.isStopped = true;</div><div class="line">        const &#123; observers &#125; = this;</div><div class="line">        const len = observers.length;</div><div class="line">        const copy = observers.slice();</div><div class="line">        for (let i = 0; i &lt; len; i++) &#123; // 循环调用观察者error方法</div><div class="line">            copy[i].error(err);</div><div class="line">        &#125;</div><div class="line">        this.observers.length = 0;</div><div class="line">    &#125;</div><div class="line">    complete() &#123;</div><div class="line">        if (this.closed) &#123;</div><div class="line">            throw new ObjectUnsubscribedError();</div><div class="line">        &#125;</div><div class="line">        this.isStopped = true;</div><div class="line">        const &#123; observers &#125; = this;</div><div class="line">        const len = observers.length;</div><div class="line">        const copy = observers.slice();</div><div class="line">        for (let i = 0; i &lt; len; i++) &#123; // 循环调用观察者complete方法</div><div class="line">            copy[i].complete();</div><div class="line">        &#125;</div><div class="line">        this.observers.length = 0; // 清空内部观察者列表</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="因为-Subject-在订阅时，是把-observer-存放到观察者列表中，并在接收到新值的时候，遍历观察者列表并调用观察者上的-next-方法"><a href="#因为-Subject-在订阅时，是把-observer-存放到观察者列表中，并在接收到新值的时候，遍历观察者列表并调用观察者上的-next-方法" class="headerlink" title="因为 Subject 在订阅时，是把 observer 存放到观察者列表中，并在接收到新值的时候，遍历观察者列表并调用观察者上的 next 方法"></a>因为 Subject 在订阅时，是把 observer 存放到观察者列表中，并在接收到新值的时候，遍历观察者列表并调用观察者上的 next 方法</h3><h3 id="Subject继承自Observable-将Observable的单路推送转换为多路推送。它就是讲单路Observable转变为多路Observable的桥梁。"><a href="#Subject继承自Observable-将Observable的单路推送转换为多路推送。它就是讲单路Observable转变为多路Observable的桥梁。" class="headerlink" title="Subject继承自Observable,将Observable的单路推送转换为多路推送。它就是讲单路Observable转变为多路Observable的桥梁。"></a>Subject继承自Observable,将Observable的单路推送转换为多路推送。它就是讲单路Observable转变为多路Observable的桥梁。</h3><h2 id="Subject的几个衍生类：BehaviorSubject-ReplaySubject-AsyncSubject"><a href="#Subject的几个衍生类：BehaviorSubject-ReplaySubject-AsyncSubject" class="headerlink" title="Subject的几个衍生类：BehaviorSubject,ReplaySubject,AsyncSubject;"></a>Subject的几个衍生类：BehaviorSubject,ReplaySubject,AsyncSubject;</h2><h3 id="BehaviorSubject：保存最近向数据消费者发送的值，当一个Observer订阅后，他会立即收到最新的值；它非常适合表示随时间推移的值；BehaviorSubject-形容一个人的生日，随时间不断更新；"><a href="#BehaviorSubject：保存最近向数据消费者发送的值，当一个Observer订阅后，他会立即收到最新的值；它非常适合表示随时间推移的值；BehaviorSubject-形容一个人的生日，随时间不断更新；" class="headerlink" title="BehaviorSubject：保存最近向数据消费者发送的值，当一个Observer订阅后，他会立即收到最新的值；它非常适合表示随时间推移的值；BehaviorSubject 形容一个人的生日，随时间不断更新；"></a>BehaviorSubject：保存最近向数据消费者发送的值，当一个Observer订阅后，他会立即收到最新的值；它非常适合表示随时间推移的值；BehaviorSubject 形容一个人的生日，随时间不断更新；</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var subject = new Rx.BehaviorSubject(0) //初始值</div><div class="line">subject.subscribe(&#123;</div><div class="line">    next:(v) =&gt; &#123;</div><div class="line">        console.log(&apos;A&apos; + v )</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">subject.next(1);</div><div class="line">subject.next(2);</div><div class="line">subject.subscribe(&#123;</div><div class="line">    next:(v) =&gt; &#123;</div><div class="line">        console.log(&apos;B&apos; + v )</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">subject.next(3);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var subject = new Rx.ReplaySubject(3); /* 回放数量 */</div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">subject.next(1);</div><div class="line">subject.next(2);</div><div class="line">subject.next(3);</div><div class="line">subject.next(4);</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">subject.next(5);</div></pre></td></tr></table></figure>
<h3 id="ReplaySubject-如同于-BehaviorSubject-是-Subject-的子类。通过-ReplaySubject-可以向新的订阅者推送旧数值，就像一个录像机-ReplaySubject-可以记录Observable的一部分状态（过去时间内推送的值）-一个-ReplaySubject-可以记录Observable执行过程中推送的多个值，并向新的订阅者回放它们。"><a href="#ReplaySubject-如同于-BehaviorSubject-是-Subject-的子类。通过-ReplaySubject-可以向新的订阅者推送旧数值，就像一个录像机-ReplaySubject-可以记录Observable的一部分状态（过去时间内推送的值）-一个-ReplaySubject-可以记录Observable执行过程中推送的多个值，并向新的订阅者回放它们。" class="headerlink" title="ReplaySubject 如同于 BehaviorSubject 是 Subject 的子类。通过 ReplaySubject 可以向新的订阅者推送旧数值，就像一个录像机 ReplaySubject 可以记录Observable的一部分状态（过去时间内推送的值）;.一个 ReplaySubject 可以记录Observable执行过程中推送的多个值，并向新的订阅者回放它们。"></a>ReplaySubject 如同于 BehaviorSubject 是 Subject 的子类。通过 ReplaySubject 可以向新的订阅者推送旧数值，就像一个录像机 ReplaySubject 可以记录Observable的一部分状态（过去时间内推送的值）;.一个 ReplaySubject 可以记录Observable执行过程中推送的多个值，并向新的订阅者回放它们。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var subject = new Rx.AsyncSubject();</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">subject.next(1);</div><div class="line">subject.next(2);</div><div class="line">subject.next(3);</div><div class="line">subject.next(4);</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">subject.next(5);</div><div class="line">subject.complete();</div></pre></td></tr></table></figure>
<h3 id="AsyncSubject是Subject的另外一个衍生类，Observable仅会在执行完成后-complete-，推送执行环境中的最后一个值。业务上很少用"><a href="#AsyncSubject是Subject的另外一个衍生类，Observable仅会在执行完成后-complete-，推送执行环境中的最后一个值。业务上很少用" class="headerlink" title="AsyncSubject是Subject的另外一个衍生类，Observable仅会在执行完成后(complete)，推送执行环境中的最后一个值。业务上很少用"></a>AsyncSubject是Subject的另外一个衍生类，Observable仅会在执行完成后(complete)，推送执行环境中的最后一个值。业务上很少用</h3><h3 id="既然Subject是一个Observer，你可以把它作为subscribe（订阅）普通Observable时的参数"><a href="#既然Subject是一个Observer，你可以把它作为subscribe（订阅）普通Observable时的参数" class="headerlink" title="既然Subject是一个Observer，你可以把它作为subscribe（订阅）普通Observable时的参数"></a>既然Subject是一个Observer，你可以把它作为subscribe（订阅）普通Observable时的参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var subject = new Rx.Subject();</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</div><div class="line">&#125;);</div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var observable = Rx.Observable.from([1, 2, 3]);</div><div class="line"></div><div class="line">observable.subscribe(subject); // 你可以传递Subject来订阅observable</div></pre></td></tr></table></figure>
<h3 id="通过添加两个Observer到Observer列表中，之后Observable直接订阅Observer列表将普通的单路推送转换为多路推送"><a href="#通过添加两个Observer到Observer列表中，之后Observable直接订阅Observer列表将普通的单路推送转换为多路推送" class="headerlink" title="通过添加两个Observer到Observer列表中，之后Observable直接订阅Observer列表将普通的单路推送转换为多路推送"></a>通过添加两个Observer到Observer列表中，之后Observable直接订阅Observer列表将普通的单路推送转换为多路推送</h3><h2 id="Cold-amp-HOT"><a href="#Cold-amp-HOT" class="headerlink" title="Cold  &amp;  HOT"></a>Cold  &amp;  HOT</h2><h3 id="observable-is-default-cold-cold-表示只有-subscribe-出现-observer-才会被激活-当有多个subscribe时，每一个都是一条独立的链；hot-每个subscirbe共享一个链，不管什么时间插入subscribe-都不会重新开始。如何把一个cold-变成-hot？Subject则可以充当中介。multicast、refCount、publish、share则是通过Subject完成将cold转变为hot的方法。"><a href="#observable-is-default-cold-cold-表示只有-subscribe-出现-observer-才会被激活-当有多个subscribe时，每一个都是一条独立的链；hot-每个subscirbe共享一个链，不管什么时间插入subscribe-都不会重新开始。如何把一个cold-变成-hot？Subject则可以充当中介。multicast、refCount、publish、share则是通过Subject完成将cold转变为hot的方法。" class="headerlink" title="observable is default cold; cold: 表示只有 subscribe 出现 observer 才会被激活; 当有多个subscribe时，每一个都是一条独立的链；hot: 每个subscirbe共享一个链，不管什么时间插入subscribe,都不会重新开始。如何把一个cold 变成 hot？Subject则可以充当中介。multicast、refCount、publish、share则是通过Subject完成将cold转变为hot的方法。"></a>observable is default cold; cold: 表示只有 subscribe 出现 observer 才会被激活; 当有多个subscribe时，每一个都是一条独立的链；hot: 每个subscirbe共享一个链，不管什么时间插入subscribe,都不会重新开始。如何把一个cold 变成 hot？Subject则可以充当中介。multicast、refCount、publish、share则是通过Subject完成将cold转变为hot的方法。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let sub = new Subject();</div><div class="line">let obs = sub.map(v =&gt; &#123;</div><div class="line">    console.log(&quot;ajax call&quot;); </div><div class="line">&#125;);</div><div class="line">obs.subscribe(v =&gt; console.log(&quot;subscribe 1&quot;));</div><div class="line">obs.subscribe(v =&gt; console.log(&quot;subscribe 2&quot;));         </div><div class="line">sub.next(&quot;value&quot;); </div><div class="line">// ajax call</div><div class="line">// subscribe 1</div><div class="line">// ajax call</div><div class="line">// subscribe 2</div></pre></td></tr></table></figure>
<h3 id="模拟异步请求数据的业务场景，如果有更多的subscribe的时候，则会对请求服务器多次，造成服务器负载严重，此时一般解决方法为以下两种"><a href="#模拟异步请求数据的业务场景，如果有更多的subscribe的时候，则会对请求服务器多次，造成服务器负载严重，此时一般解决方法为以下两种" class="headerlink" title="模拟异步请求数据的业务场景，如果有更多的subscribe的时候，则会对请求服务器多次，造成服务器负载严重，此时一般解决方法为以下两种"></a>模拟异步请求数据的业务场景，如果有更多的subscribe的时候，则会对请求服务器多次，造成服务器负载严重，此时一般解决方法为以下两种</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let obs = sub.map(v =&gt; &#123;</div><div class="line">    console.log(&quot;ajax call&quot;); </div><div class="line">&#125;).share();</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let obs = sub.map(v =&gt; &#123;</div><div class="line">    console.log(&quot;ajax call&quot;); </div><div class="line">&#125;).publish().refCount();</div></pre></td></tr></table></figure>
<h3 id="引入multicast（组播）的概念，通过中介者订阅源序列在由它推送出去-下面是它的运作方式"><a href="#引入multicast（组播）的概念，通过中介者订阅源序列在由它推送出去-下面是它的运作方式" class="headerlink" title="引入multicast（组播）的概念，通过中介者订阅源序列在由它推送出去,下面是它的运作方式"></a>引入multicast（组播）的概念，通过中介者订阅源序列在由它推送出去,下面是它的运作方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">var source = Rx.Observable.interval(1000).take(3);</div><div class="line"></div><div class="line">var observerA = &#123;</div><div class="line">    next: value =&gt; console.log(&apos;A next: &apos; + value),</div><div class="line">    error: error =&gt; console.log(&apos;A error: &apos; + error),</div><div class="line">    complete: () =&gt; console.log(&apos;A complete!&apos;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">var observerB = &#123;</div><div class="line">    next: value =&gt; console.log(&apos;B next: &apos; + value),</div><div class="line">    error: error =&gt; console.log(&apos;B error: &apos; + error),</div><div class="line">    complete: () =&gt; console.log(&apos;B complete!&apos;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">var subject = &#123;</div><div class="line">    observers: [],</div><div class="line">    subscribe: function(observer) &#123;   //addObserver</div><div class="line">        this.observers.push(observer)</div><div class="line">    &#125;,</div><div class="line">    next: function(value) &#123;</div><div class="line">        this.observers.forEach(o =&gt; o.next(value))    </div><div class="line">    &#125;,</div><div class="line">    error: function(error)&#123;</div><div class="line">        this.observers.forEach(o =&gt; o.error(error))</div><div class="line">    &#125;,</div><div class="line">    complete: function() &#123;</div><div class="line">        this.observers.forEach(o =&gt; o.complete())</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">subject.subscribe(observerA)</div><div class="line"></div><div class="line">source.subscribe(subject);</div><div class="line"></div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">    subject.subscribe(observerB);</div><div class="line">&#125;, 1000);</div></pre></td></tr></table></figure>
<h3 id="换一种形式，用multicast方法来实现"><a href="#换一种形式，用multicast方法来实现" class="headerlink" title="换一种形式，用multicast方法来实现"></a>换一种形式，用multicast方法来实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">var source = Rx.Observable.interval(1000)</div><div class="line">             .take(3)</div><div class="line">             .multicast(new Rx.Subject());</div><div class="line"></div><div class="line">var observerA = &#123;</div><div class="line">    next: value =&gt; console.log(&apos;A next: &apos; + value),</div><div class="line">    error: error =&gt; console.log(&apos;A error: &apos; + error),</div><div class="line">    complete: () =&gt; console.log(&apos;A complete!&apos;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">var observerB = &#123;</div><div class="line">    next: value =&gt; console.log(&apos;B next: &apos; + value),</div><div class="line">    error: error =&gt; console.log(&apos;B error: &apos; + error),</div><div class="line">    complete: () =&gt; console.log(&apos;B complete!&apos;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">source.subscribe(observerA); // subject.subscribe(observerA)</div><div class="line"></div><div class="line">source.connect();    // source.subscribe(subject)  //开始推送 </div><div class="line"></div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">    source.subscribe(observerB); // subject.subscribe(observerA)</div><div class="line">&#125;, 1000);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var result = Observable.interval(1000).take(6)  //执行两次</div><div class="line">             .map(x =&gt; Math.random())</div><div class="line">            //  .share()    //不会因为订阅者数量而执行多次</div><div class="line">            //  .publish().refCount()</div><div class="line"></div><div class="line">     var subA = result.subscribe(x =&gt; console.log(&apos;A: &apos; + x));</div><div class="line">     var subB = result.subscribe(x =&gt; console.log(&apos;B: &apos; + x));</div></pre></td></tr></table></figure>
<h3 id="常用应用场景"><a href="#常用应用场景" class="headerlink" title="常用应用场景"></a>常用应用场景</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let sub = new Subject();</div><div class="line">let obs = sub.map(v =&gt; &#123;</div><div class="line">    console.log(&quot;ajax call&quot;);  //请求接口</div><div class="line">&#125;);</div><div class="line">obs.subscribe(v =&gt; console.log(&quot;subscribe 1&quot;));  //分发</div><div class="line">obs.subscribe(v =&gt; console.log(&quot;subscribe 2&quot;));         </div><div class="line">sub.next(&quot;value&quot;);</div></pre></td></tr></table></figure>
<h3 id="ajax会打印两次，增加服务器端负载；-调用share-方法；其中angular2中的http也是not-share的，在类似场景中同样的问题；"><a href="#ajax会打印两次，增加服务器端负载；-调用share-方法；其中angular2中的http也是not-share的，在类似场景中同样的问题；" class="headerlink" title="ajax会打印两次，增加服务器端负载； 调用share()方法；其中angular2中的http也是not share的，在类似场景中同样的问题；"></a>ajax会打印两次，增加服务器端负载； 调用share()方法；其中angular2中的http也是not share的，在类似场景中同样的问题；</h3><h3 id="建立一個-subject-先拿去訂閱-observable-source-，再把我們真正的-observer-加到-subject-中，這樣一來就能完成訂閱，而每個加到-subject-中的-observer-都能整組的接收到相同的元素。"><a href="#建立一個-subject-先拿去訂閱-observable-source-，再把我們真正的-observer-加到-subject-中，這樣一來就能完成訂閱，而每個加到-subject-中的-observer-都能整組的接收到相同的元素。" class="headerlink" title="建立一個 subject 先拿去訂閱 observable(source)，再把我們真正的 observer 加到 subject 中，這樣一來就能完成訂閱，而每個加到 subject 中的 observer 都能整組的接收到相同的元素。"></a>建立一個 subject 先拿去訂閱 observable(source)，再把我們真正的 observer 加到 subject 中，這樣一來就能完成訂閱，而每個加到 subject 中的 observer 都能整組的接收到相同的元素。</h3><h3 id="Observable-multicast-new-Rx-Subject-Observable-publish-对于Subject三种衍生形式，publishReplay-1-、publishBehavior-0-、publishLast"><a href="#Observable-multicast-new-Rx-Subject-Observable-publish-对于Subject三种衍生形式，publishReplay-1-、publishBehavior-0-、publishLast" class="headerlink" title="Observable.multicast(new Rx.Subject()) == Observable.publish();对于Subject三种衍生形式，publishReplay(1)、publishBehavior(0)、publishLast()"></a>Observable.multicast(new Rx.Subject()) == Observable.publish();对于Subject三种衍生形式，publishReplay(1)、publishBehavior(0)、publishLast()</h3><h3 id="另外-Observable-publish-refCount-Observable-share"><a href="#另外-Observable-publish-refCount-Observable-share" class="headerlink" title="另外   Observable.publish().refCount() == Observable.share()"></a>另外   Observable.publish().refCount() == Observable.share()</h3><h2 id="总结Subject！"><a href="#总结Subject！" class="headerlink" title="总结Subject！"></a>总结Subject！</h2><ul>
<li>既是Observable又是Observer</li>
<li>对内部的observers进行组播</li>
<li>observer default is cold and not share.(cold 表示只有 subscribe 出现 observer 才会被激活.    not share 表示每一个 subscribe 都会激活 observer 链)</li>
</ul>
<h3 id="业务场景：窗口a接收到A-b接收到B-c接受到C，本窗口d则需要异步的捕获a和b窗口的值并乘c窗口的值，d-a-b-c"><a href="#业务场景：窗口a接收到A-b接收到B-c接受到C，本窗口d则需要异步的捕获a和b窗口的值并乘c窗口的值，d-a-b-c" class="headerlink" title="业务场景：窗口a接收到A,b接收到B,c接受到C，本窗口d则需要异步的捕获a和b窗口的值并乘c窗口的值，d = (a+b)*c;"></a>业务场景：窗口a接收到A,b接收到B,c接受到C，本窗口d则需要异步的捕获a和b窗口的值并乘c窗口的值，d = (a+b)*c;</h3><h3 id="我们可以把每个数据的变更定义成流，然后定义出这些流的组合关系"><a href="#我们可以把每个数据的变更定义成流，然后定义出这些流的组合关系" class="headerlink" title="我们可以把每个数据的变更定义成流，然后定义出这些流的组合关系"></a>我们可以把每个数据的变更定义成流，然后定义出这些流的组合关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">const A = new Rx.Subject()</div><div class="line">const B = new Rx.Subject()</div><div class="line">const C = new Rx.Subject()</div><div class="line"></div><div class="line">const D = Rx.Observable</div><div class="line">  .combineLatest(A, B, C)</div><div class="line">  .map(data =&gt; &#123;</div><div class="line">    let [a, b, c] = data</div><div class="line">    return (a + b) * c</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">D.subscribe(result =&gt; console.log(result))</div><div class="line"></div><div class="line">setTimeout(() =&gt; A.next(2), 3000)</div><div class="line">setTimeout(() =&gt; B.next(3), 5000)</div><div class="line">setTimeout(() =&gt; C.next(5), 2000)</div><div class="line"></div><div class="line">setTimeout(() =&gt; C.next(11), 10000)</div></pre></td></tr></table></figure>
<h3 id="为了简单，我们用定时器来模拟异步消息。实际业务中，对每个Subject的赋值是可以跟AJAX或者WebSocket结合起来，而且对D的那段实现毫无影响。我们可以看到，在整个这个过程中，最大的便利性在于，一旦定义完整个规则，变动整个表达式树上任意一个点，整个过程都会重跑一遍，以确保最终得到正确结果。无论中间环节上哪个东西变了，它只要更新自己就可以了，别人怎么用它的，不必关心。而且，我们从D的角度看，他只关心自己的数据来源是如何组织的，这些来源最终形成了一棵树，从各叶子汇聚到树根，也就是我们的订阅者这里，树上每个节点变更，都会自动触发从它往下到树根的所有数据变动，这个过程是最精确的，不会触发无效的数据更新。"><a href="#为了简单，我们用定时器来模拟异步消息。实际业务中，对每个Subject的赋值是可以跟AJAX或者WebSocket结合起来，而且对D的那段实现毫无影响。我们可以看到，在整个这个过程中，最大的便利性在于，一旦定义完整个规则，变动整个表达式树上任意一个点，整个过程都会重跑一遍，以确保最终得到正确结果。无论中间环节上哪个东西变了，它只要更新自己就可以了，别人怎么用它的，不必关心。而且，我们从D的角度看，他只关心自己的数据来源是如何组织的，这些来源最终形成了一棵树，从各叶子汇聚到树根，也就是我们的订阅者这里，树上每个节点变更，都会自动触发从它往下到树根的所有数据变动，这个过程是最精确的，不会触发无效的数据更新。" class="headerlink" title="为了简单，我们用定时器来模拟异步消息。实际业务中，对每个Subject的赋值是可以跟AJAX或者WebSocket结合起来，而且对D的那段实现毫无影响。我们可以看到，在整个这个过程中，最大的便利性在于，一旦定义完整个规则，变动整个表达式树上任意一个点，整个过程都会重跑一遍，以确保最终得到正确结果。无论中间环节上哪个东西变了，它只要更新自己就可以了，别人怎么用它的，不必关心。而且，我们从D的角度看，他只关心自己的数据来源是如何组织的，这些来源最终形成了一棵树，从各叶子汇聚到树根，也就是我们的订阅者这里，树上每个节点变更，都会自动触发从它往下到树根的所有数据变动，这个过程是最精确的，不会触发无效的数据更新。"></a>为了简单，我们用定时器来模拟异步消息。实际业务中，对每个Subject的赋值是可以跟AJAX或者WebSocket结合起来，而且对D的那段实现毫无影响。我们可以看到，在整个这个过程中，最大的便利性在于，一旦定义完整个规则，变动整个表达式树上任意一个点，整个过程都会重跑一遍，以确保最终得到正确结果。无论中间环节上哪个东西变了，它只要更新自己就可以了，别人怎么用它的，不必关心。而且，我们从D的角度看，他只关心自己的数据来源是如何组织的，这些来源最终形成了一棵树，从各叶子汇聚到树根，也就是我们的订阅者这里，树上每个节点变更，都会自动触发从它往下到树根的所有数据变动，这个过程是最精确的，不会触发无效的数据更新。</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://github.com/vernvn/hexoBlog/blob/master/avator/github.jpg?raw=true"
               alt="Lee" />
          <p class="site-author-name" itemprop="name">Lee</p>
          <p class="site-description motion-element" itemprop="description">my blog</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">18</span>
              <span class="site-state-item-name">Artikel</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">Tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lee</span>
</div>

<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lee/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lee/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lee/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lee/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lee/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lee/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

  


</body>
</html>
