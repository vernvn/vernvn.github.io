<!doctype html>



  


<html class="theme-next muse use-motion">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lee/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lee/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2">






<meta name="description" content="首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。最好的Rxjs中文文档RXJS全名Reactive Extensions for JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。RxJS所能解决的问题：时刻保持响">
<meta property="og:type" content="article">
<meta property="og:title" content="RxJS:万物皆为流">
<meta property="og:url" content="http://vernvn.github.io/2017/02/28/rxjs/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。最好的Rxjs中文文档RXJS全名Reactive Extensions for JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。RxJS所能解决的问题：时刻保持响">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-02-08T02:09:02.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RxJS:万物皆为流">
<meta name="twitter:description" content="首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。最好的Rxjs中文文档RXJS全名Reactive Extensions for JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。RxJS所能解决的问题：时刻保持响">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://vernvn.github.io/2017/02/28/rxjs/">


  <title> RxJS:万物皆为流 | Hexo </title>
</head>

<body itemscope="" itemtype="//schema.org/WebPage" lang="zh-CN">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Hexo</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule" rel="section">
            
            Schedule
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                RxJS:万物皆为流
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-02-28T13:54:14+08:00" content="2017-02-28">
              2017-02-28
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。最好的Rxjs中文文档"><a href="#首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。最好的Rxjs中文文档" class="headerlink" title="首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。最好的Rxjs中文文档"></a>首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。<a href="https://www.gitbook.com/book/buctwbzs/rxjs/details" target="_blank" rel="noopener">最好的Rxjs中文文档</a></h2><h3 id="RXJS全名Reactive-Extensions-for-JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。"><a href="#RXJS全名Reactive-Extensions-for-JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。" class="headerlink" title="RXJS全名Reactive Extensions for JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。"></a>RXJS全名Reactive Extensions for JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。</h3><h3 id="RxJS所能解决的问题："><a href="#RxJS所能解决的问题：" class="headerlink" title="RxJS所能解决的问题："></a>RxJS所能解决的问题：</h3><h4 id="时刻保持响应。这对于一个应用来说意味着当他处理用户的输入或者凭借AJAX从服务器接受一些数据时停止是一件不可能接受的事情。在JavaScript中解决问题的方案始终是大量运用回调函数来进行一些运行的处理。但回调的使用使内容丰富的大型应用变得凌乱，一旦你需要多块数据时你就陷入了回调地狱。Angular2中，组件间通讯-Output对应的EventEmitter实际上就是一个Subject-主题：同时为Observable和Observer-Http模块中Observable作为大部分API的交互对象使用。但是这只是官方的外部扩展，并不必须，也可以使用-toPromise的方式转换为Promise来使用或第三方扩展库或Fetch-API-传统Ajax已死，Fetch永生。"><a href="#时刻保持响应。这对于一个应用来说意味着当他处理用户的输入或者凭借AJAX从服务器接受一些数据时停止是一件不可能接受的事情。在JavaScript中解决问题的方案始终是大量运用回调函数来进行一些运行的处理。但回调的使用使内容丰富的大型应用变得凌乱，一旦你需要多块数据时你就陷入了回调地狱。Angular2中，组件间通讯-Output对应的EventEmitter实际上就是一个Subject-主题：同时为Observable和Observer-Http模块中Observable作为大部分API的交互对象使用。但是这只是官方的外部扩展，并不必须，也可以使用-toPromise的方式转换为Promise来使用或第三方扩展库或Fetch-API-传统Ajax已死，Fetch永生。" class="headerlink" title="时刻保持响应。这对于一个应用来说意味着当他处理用户的输入或者凭借AJAX从服务器接受一些数据时停止是一件不可能接受的事情。在JavaScript中解决问题的方案始终是大量运用回调函数来进行一些运行的处理。但回调的使用使内容丰富的大型应用变得凌乱，一旦你需要多块数据时你就陷入了回调地狱。Angular2中，组件间通讯@Output对应的EventEmitter实际上就是一个Subject(主题：同时为Observable和Observer);Http模块中Observable作为大部分API的交互对象使用。但是这只是官方的外部扩展，并不必须，也可以使用.toPromise的方式转换为Promise来使用或第三方扩展库或Fetch API 传统Ajax已死，Fetch永生。"></a>时刻保持响应。这对于一个应用来说意味着当他处理用户的输入或者凭借AJAX从服务器接受一些数据时停止是一件不可能接受的事情。在JavaScript中解决问题的方案始终是大量运用回调函数来进行一些运行的处理。但回调的使用使内容丰富的大型应用变得凌乱，一旦你需要多块数据时你就陷入了回调地狱。Angular2中，组件间通讯@Output对应的EventEmitter实际上就是一个Subject(主题：同时为Observable和Observer);Http模块中Observable作为大部分API的交互对象使用。但是这只是官方的外部扩展，并不必须，也可以使用.toPromise的方式转换为Promise来使用或第三方扩展库或Fetch API <a href="https://segmentfault.com/a/1190000003810652" target="_blank" rel="noopener">传统Ajax已死，Fetch永生</a>。</h4><p><br></p>
<h3 id="RxJS初探："><a href="#RxJS初探：" class="headerlink" title="RxJS初探："></a>RxJS初探：</h3><h4 id="RxJS是一个解决异步问题的JS开发库-它带来了观察者模式和函数式编程的相结合的最佳实践。-观察者模式是一个被实践证明的模式，基于生产者（事件的创建者）和消费者（事件的监听者）的逻辑分离关系-况且函数式编程方式的引入，如说明性编程，不可变数据结构，链式方法调用会使你极大的简化代码量。RxJS-引入了一个重要的数据类型——流（stream）。流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下，等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。"><a href="#RxJS是一个解决异步问题的JS开发库-它带来了观察者模式和函数式编程的相结合的最佳实践。-观察者模式是一个被实践证明的模式，基于生产者（事件的创建者）和消费者（事件的监听者）的逻辑分离关系-况且函数式编程方式的引入，如说明性编程，不可变数据结构，链式方法调用会使你极大的简化代码量。RxJS-引入了一个重要的数据类型——流（stream）。流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下，等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。" class="headerlink" title="RxJS是一个解决异步问题的JS开发库.它带来了观察者模式和函数式编程的相结合的最佳实践。 观察者模式是一个被实践证明的模式，基于生产者（事件的创建者）和消费者（事件的监听者）的逻辑分离关系.况且函数式编程方式的引入，如说明性编程，不可变数据结构，链式方法调用会使你极大的简化代码量。RxJS 引入了一个重要的数据类型——流（stream）。流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下，等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。"></a>RxJS是一个解决异步问题的JS开发库.它带来了观察者模式和函数式编程的相结合的最佳实践。 观察者模式是一个被实践证明的模式，基于生产者（事件的创建者）和消费者（事件的监听者）的逻辑分离关系.况且函数式编程方式的引入，如说明性编程，不可变数据结构，链式方法调用会使你极大的简化代码量。RxJS 引入了一个重要的数据类型——流（stream）。流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下，等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。</h4><p><br></p>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><h4 id="流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。"><a href="#流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。" class="headerlink" title="流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。"></a>流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 2;</span><br><span class="line">var b = 4;</span><br><span class="line">var c = a + b;</span><br><span class="line">console.log(c); //-&gt; 6</span><br><span class="line">a = 10;  // reassign a</span><br><span class="line">console.log(c); //-&gt; still 6</span><br></pre></td></tr></table></figure>
<h4 id="事件引发的改变总是从事件源（生产者）-向下传递到所有事件监听方（消费者）。如果变量看做流呢，又是什么结果呢？"><a href="#事件引发的改变总是从事件源（生产者）-向下传递到所有事件监听方（消费者）。如果变量看做流呢，又是什么结果呢？" class="headerlink" title="事件引发的改变总是从事件源（生产者）,向下传递到所有事件监听方（消费者）。如果变量看做流呢，又是什么结果呢？"></a>事件引发的改变总是从事件源（生产者）,向下传递到所有事件监听方（消费者）。如果变量看做流呢，又是什么结果呢？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var A$ = 2;</span><br><span class="line">var B$ = 4;</span><br><span class="line">var C$ = A$ + B$;</span><br><span class="line">console.log(C$); //-&gt; 6</span><br><span class="line">A$ = 10;  </span><br><span class="line">console.log(C$); //-&gt;  16</span><br></pre></td></tr></table></figure>
<h4 id="流的方式重新定义的变量值的动态行为-换句话说，C-是把两个流变量A-和B-进行合并操作。当一个新值被推进了A-，C-立刻响应式的变更为16。"><a href="#流的方式重新定义的变量值的动态行为-换句话说，C-是把两个流变量A-和B-进行合并操作。当一个新值被推进了A-，C-立刻响应式的变更为16。" class="headerlink" title="流的方式重新定义的变量值的动态行为.换句话说，C$是把两个流变量A$和B$进行合并操作。当一个新值被推进了A$，C$立刻响应式的变更为16。"></a>流的方式重新定义的变量值的动态行为.换句话说，C$是把两个流变量A$和B$进行合并操作。当一个新值被推进了A$，C$立刻响应式的变更为16。</h4><h3 id="开始了解RxJS中的几个重要成员"><a href="#开始了解RxJS中的几个重要成员" class="headerlink" title="开始了解RxJS中的几个重要成员"></a>开始了解RxJS中的几个重要成员</h3><ul>
<li>Observable可观察对象：表示一个可调用的未来值或者事件的集合。</li>
<li>Observer观察者：一个回调函数集合,它知道怎样去监听被Observable发送的值</li>
<li>Subscription订阅： 表示一个可观察对象的执行，主要用于取消执行。</li>
<li>Operators操作符： 纯粹的函数，使得以函数编程的方式处理集合比如:map,filter,contact,flatmap。</li>
<li>Subject(主题)：等同于一个事件驱动器，是将一个值或者事件广播到多个观察者的唯一途径。</li>
<li>Schedulers(调度者)： 用来控制并发，当计算发生的时候允许我们协调，比如setTimeout,requestAnimationFrame。<h3 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h3><h4 id="使用RxJS创建一个可观察对象："><a href="#使用RxJS创建一个可观察对象：" class="headerlink" title="使用RxJS创建一个可观察对象："></a>使用RxJS创建一个可观察对象：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var button = document.querySelector(&apos;button&apos;);</span><br><span class="line">Rx.Observable.fromEvent(button, &apos;click&apos;)</span><br><span class="line">.throttleTime(1000)</span><br><span class="line">.scan(count =&gt; count + 1, 0)   </span><br><span class="line">.subscribe(count =&gt; console.log(`Clicked $&#123;count&#125; times`));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="observable可观察对象，以惰性的方式推送多值的集合"><a href="#observable可观察对象，以惰性的方式推送多值的集合" class="headerlink" title="observable可观察对象，以惰性的方式推送多值的集合"></a>observable可观察对象，以惰性的方式推送多值的集合</h3><h4 id="下面的例子是一个推送1-2，3-4数值的可观察对象，一旦它被订阅1-2，3-就会被推送，4则会在订阅发生一秒之后被推送，紧接着完成推送"><a href="#下面的例子是一个推送1-2，3-4数值的可观察对象，一旦它被订阅1-2，3-就会被推送，4则会在订阅发生一秒之后被推送，紧接着完成推送" class="headerlink" title="下面的例子是一个推送1,2，3,4数值的可观察对象，一旦它被订阅1,2，3,就会被推送，4则会在订阅发生一秒之后被推送，紧接着完成推送"></a>下面的例子是一个推送1,2，3,4数值的可观察对象，一旦它被订阅1,2，3,就会被推送，4则会在订阅发生一秒之后被推送，紧接着完成推送</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var observable = Rx.Observable.create(observer=&gt;&#123;</span><br><span class="line">    observer.next(1);</span><br><span class="line">    observer.next(2);</span><br><span class="line">    observer.next(3);</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        observer.next(4);</span><br><span class="line">        observer.complete();</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Pull拉取-VS-Push推送"><a href="#Pull拉取-VS-Push推送" class="headerlink" title="Pull拉取 VS Push推送"></a>Pull拉取 VS Push推送</h3><h4 id="拉和推是数据生产者和数据的消费者两种不同的交流协议-方式"><a href="#拉和推是数据生产者和数据的消费者两种不同的交流协议-方式" class="headerlink" title="拉和推是数据生产者和数据的消费者两种不同的交流协议(方式);"></a>拉和推是数据生产者和数据的消费者两种不同的交流协议(方式);</h4><p><br></p>
<h4 id="什么是”Pull拉”？在”拉”体系中，数据的消费者决定何时从数据生产者那里获取数据，而生产者自身并不会意识到什么时候数据将会被发送给消费者。"><a href="#什么是”Pull拉”？在”拉”体系中，数据的消费者决定何时从数据生产者那里获取数据，而生产者自身并不会意识到什么时候数据将会被发送给消费者。" class="headerlink" title="什么是”Pull拉”？在”拉”体系中，数据的消费者决定何时从数据生产者那里获取数据，而生产者自身并不会意识到什么时候数据将会被发送给消费者。"></a>什么是”Pull拉”？在”拉”体系中，数据的消费者决定何时从数据生产者那里获取数据，而生产者自身并不会意识到什么时候数据将会被发送给消费者。</h4><h4 id="每一个JS函数都是一个“拉”体系，函数是数据的生产者，调用函数的代码通过“拉出”一个单一的返回值来消费该数据-return-语句-。"><a href="#每一个JS函数都是一个“拉”体系，函数是数据的生产者，调用函数的代码通过“拉出”一个单一的返回值来消费该数据-return-语句-。" class="headerlink" title="每一个JS函数都是一个“拉”体系，函数是数据的生产者，调用函数的代码通过“拉出”一个单一的返回值来消费该数据(return 语句)。"></a>每一个JS函数都是一个“拉”体系，函数是数据的生产者，调用函数的代码通过“拉出”一个单一的返回值来消费该数据(return 语句)。</h4><h4 id="什么是”Push推”？在推体系中，数据的生产者决定何时发送数据给消费者，消费者不会在接收数据之前意识到它将要接收这个数据。"><a href="#什么是”Push推”？在推体系中，数据的生产者决定何时发送数据给消费者，消费者不会在接收数据之前意识到它将要接收这个数据。" class="headerlink" title="什么是”Push推”？在推体系中，数据的生产者决定何时发送数据给消费者，消费者不会在接收数据之前意识到它将要接收这个数据。"></a>什么是”Push推”？在推体系中，数据的生产者决定何时发送数据给消费者，消费者不会在接收数据之前意识到它将要接收这个数据。</h4><h4 id="Promise-承诺-是当今JS中最常见的Push推体系，一个Promise-数据的生产者-发送一个resolved-value-成功状态的值-来注册一个回调-数据消费者-，但是不同于函数的地方的是：Promise决定着何时数据才被推送至这个回调函数。"><a href="#Promise-承诺-是当今JS中最常见的Push推体系，一个Promise-数据的生产者-发送一个resolved-value-成功状态的值-来注册一个回调-数据消费者-，但是不同于函数的地方的是：Promise决定着何时数据才被推送至这个回调函数。" class="headerlink" title="Promise(承诺))是当今JS中最常见的Push推体系，一个Promise(数据的生产者)发送一个resolved value(成功状态的值)来注册一个回调(数据消费者)，但是不同于函数的地方的是：Promise决定着何时数据才被推送至这个回调函数。"></a>Promise(承诺))是当今JS中最常见的Push推体系，一个Promise(数据的生产者)发送一个resolved value(成功状态的值)来注册一个回调(数据消费者)，但是不同于函数的地方的是：Promise决定着何时数据才被推送至这个回调函数。</h4><h4 id="RxJS引入了Observables-可观察对象-，一个全新的”推体系”。一个可观察对象是一个产生多值的生产者，并”推送给”Observer-观察者-。"><a href="#RxJS引入了Observables-可观察对象-，一个全新的”推体系”。一个可观察对象是一个产生多值的生产者，并”推送给”Observer-观察者-。" class="headerlink" title="RxJS引入了Observables(可观察对象)，一个全新的”推体系”。一个可观察对象是一个产生多值的生产者，并”推送给”Observer(观察者)。"></a>RxJS引入了Observables(可观察对象)，一个全新的”推体系”。一个可观察对象是一个产生多值的生产者，并”推送给”Observer(观察者)。</h4><h3 id="RxJS-VS-Promise—3个最重要的不同点"><a href="#RxJS-VS-Promise—3个最重要的不同点" class="headerlink" title="RxJS VS Promise—3个最重要的不同点"></a>RxJS VS Promise—3个最重要的不同点</h3><!--| 不同点               | RxJS     | Promise  |

| --------------------|:---------:|---------:|

| 动作是否可以取消？    | 是        | 否       |

| 是否可以发射多个值？  | 是        | 否       |

| 各种工具函数？        | 是        | 否       |-->
<table>
<thead>
<tr>
<th>不同点</th>
<th style="text-align:center">Rxjs</th>
<th style="text-align:right">Promise</th>
</tr>
</thead>
<tbody>
<tr>
<td>动作是否可以取消？</td>
<td style="text-align:center">是</td>
<td style="text-align:right">否</td>
</tr>
<tr>
<td>是否可以发射多个值？</td>
<td style="text-align:center">是</td>
<td style="text-align:right">否</td>
</tr>
<tr>
<td>各种工具函数？</td>
<td style="text-align:center">是</td>
<td style="text-align:right">否</td>
</tr>
</tbody>
</table>
<h2 id="Operators操作符"><a href="#Operators操作符" class="headerlink" title="Operators操作符"></a>Operators操作符</h2><h3 id="create-创建一个可观察序列，参数为一个封装数据生成逻辑的函数，该函数的参数为观察者"><a href="#create-创建一个可观察序列，参数为一个封装数据生成逻辑的函数，该函数的参数为观察者" class="headerlink" title="create()  创建一个可观察序列，参数为一个封装数据生成逻辑的函数，该函数的参数为观察者"></a>create()  创建一个可观察序列，参数为一个封装数据生成逻辑的函数，该函数的参数为观察者</h3><h3 id="empty-不需要传递参数，创建一个空序列并立即结束"><a href="#empty-不需要传递参数，创建一个空序列并立即结束" class="headerlink" title="empty()  不需要传递参数，创建一个空序列并立即结束"></a>empty()  不需要传递参数，创建一个空序列并立即结束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.empty()  =  Rx.Observable.create((o)=&gt;&#123;</span><br><span class="line">    o.onCompleted()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="never-不需要传递参数，创建一个空序列，并永远不结束"><a href="#never-不需要传递参数，创建一个空序列，并永远不结束" class="headerlink" title="never() 不需要传递参数，创建一个空序列，并永远不结束"></a>never() 不需要传递参数，创建一个空序列，并永远不结束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.never()  =  Rx.Observable.create((o)=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="throw-创建一个空序列，参数来声明错误并立即抛出错误"><a href="#throw-创建一个空序列，参数来声明错误并立即抛出错误" class="headerlink" title="throw() 创建一个空序列，参数来声明错误并立即抛出错误"></a>throw() 创建一个空序列，参数来声明错误并立即抛出错误</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.throw(&apos;error&apos;)  =  Rx.Observable.create((o)=&gt;&#123;</span><br><span class="line">    0.onError(&apos;error&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="range-创建一个有线长度的整数序列，两个参数，第一个起始值，第二个元素数量"><a href="#range-创建一个有线长度的整数序列，两个参数，第一个起始值，第二个元素数量" class="headerlink" title="range() 创建一个有线长度的整数序列，两个参数，第一个起始值，第二个元素数量"></a>range() 创建一个有线长度的整数序列，两个参数，第一个起始值，第二个元素数量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.range(30,4)  //输出:30,31,32,33</span><br></pre></td></tr></table></figure>
<h3 id="interval-创建一个无限长度的周期性序列"><a href="#interval-创建一个无限长度的周期性序列" class="headerlink" title="interval() 创建一个无限长度的周期性序列"></a>interval() 创建一个无限长度的周期性序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.interval(1000) //输出:0,1,2...</span><br></pre></td></tr></table></figure>
<h3 id="timer-指定一个额外的参数来调节第一值的静默时长，第二个参数可选，若无则仅仅在规定的静默时长后输出一个值，然后结束序列"><a href="#timer-指定一个额外的参数来调节第一值的静默时长，第二个参数可选，若无则仅仅在规定的静默时长后输出一个值，然后结束序列" class="headerlink" title="timer() 指定一个额外的参数来调节第一值的静默时长，第二个参数可选，若无则仅仅在规定的静默时长后输出一个值，然后结束序列"></a>timer() 指定一个额外的参数来调节第一值的静默时长，第二个参数可选，若无则仅仅在规定的静默时长后输出一个值，然后结束序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.timer(0,1000) //输出:0,1,2...</span><br></pre></td></tr></table></figure>
<h3 id="from-可以将已有的数据转化为Observable-参数为iterable数据集对象-常见Array-String"><a href="#from-可以将已有的数据转化为Observable-参数为iterable数据集对象-常见Array-String" class="headerlink" title="from() 可以将已有的数据转化为Observable,参数为iterable数据集对象,常见Array,String"></a>from() 可以将已有的数据转化为Observable,参数为iterable数据集对象,常见Array,String</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.from(iterable)</span><br></pre></td></tr></table></figure>
<h3 id="of-不在同一个数据集中的多个来源的数据，使用of-方法直接构造："><a href="#of-不在同一个数据集中的多个来源的数据，使用of-方法直接构造：" class="headerlink" title="of()  不在同一个数据集中的多个来源的数据，使用of()方法直接构造："></a>of()  不在同一个数据集中的多个来源的数据，使用of()方法直接构造：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.of([1,2,3])    //    [1,2,3]</span><br><span class="line">Rx.Observable.from([1,2,3])  //    1,2,3</span><br></pre></td></tr></table></figure>
<h3 id="just-将任何数据转化为一个单值输出的Observable"><a href="#just-将任何数据转化为一个单值输出的Observable" class="headerlink" title="just()  将任何数据转化为一个单值输出的Observable"></a>just()  将任何数据转化为一个单值输出的Observable</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.just([1,2,3])    //    [1,2,3]</span><br></pre></td></tr></table></figure>
<h3 id="repeat-创建一个重复值序列-par1-值，par2：次数"><a href="#repeat-创建一个重复值序列-par1-值，par2：次数" class="headerlink" title="repeat() 创建一个重复值序列  par1:值，par2：次数"></a>repeat() 创建一个重复值序列  par1:值，par2：次数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.repeat(&apos;a&apos;,2)    //   a a</span><br></pre></td></tr></table></figure>
<h3 id="fromEvent-将事件流转化为Observable"><a href="#fromEvent-将事件流转化为Observable" class="headerlink" title="fromEvent() 将事件流转化为Observable,"></a>fromEvent() 将事件流转化为Observable,</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var el = document.getElementById(&quot;btn&quot;); //DOM对象作为事件源</span><br><span class="line">Rx.Observable.fromEvent(el,&quot;click&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="toArray-将序列还原为数组对象-只有在订阅后才还原为数组"><a href="#toArray-将序列还原为数组对象-只有在订阅后才还原为数组" class="headerlink" title="toArray() 将序列还原为数组对象,只有在订阅后才还原为数组"></a>toArray() 将序列还原为数组对象,只有在订阅后才还原为数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,3,4);    //序列：1 2 3 4 </span><br><span class="line">var target = source.toArray();     //序列：[1,2,3,4]</span><br><span class="line">target.subscribe(function(d)&#123;</span><br><span class="line">    console.log(d);             //d： [1,2,3,4]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="delay-推迟-参数为数字或Date对象"><a href="#delay-推迟-参数为数字或Date对象" class="headerlink" title="delay() 推迟   参数为数字或Date对象"></a>delay() 推迟   参数为数字或Date对象</h3><h3 id="delaySubscription-延迟订阅-参数同理"><a href="#delaySubscription-延迟订阅-参数同理" class="headerlink" title="delaySubscription() 延迟订阅  参数同理"></a>delaySubscription() 延迟订阅  参数同理</h3><h3 id="startWith-可以在源序列之前添加额外的元素"><a href="#startWith-可以在源序列之前添加额外的元素" class="headerlink" title="startWith() 可以在源序列之前添加额外的元素"></a>startWith() 可以在源序列之前添加额外的元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,3); //序列：1 2 3</span><br><span class="line">var target = source.startWith(7,8,9); //序列：7 8 9 1 2 3</span><br></pre></td></tr></table></figure>
<h3 id="map-对源序列进行变换，并返回新的序列-改变了源"><a href="#map-对源序列进行变换，并返回新的序列-改变了源" class="headerlink" title="map() 对源序列进行变换，并返回新的序列(改变了源)"></a>map() 对源序列进行变换，并返回新的序列(改变了源)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var trandform = function(item)&#123;</span><br><span class="line">    return item*2;</span><br><span class="line">&#125;</span><br><span class="line">var source = Rx.Observable.of(1,2,3); //输出： 1 2 3</span><br><span class="line">var target = source.map(trandform);   //输出： 2 4 6</span><br></pre></td></tr></table></figure>
<h1 id="concat-有序拼接-merge-无序"><a href="#concat-有序拼接-merge-无序" class="headerlink" title="concat() 有序拼接   merge()无序"></a>concat() 有序拼接   merge()无序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,3); //序列：1 2 3</span><br><span class="line">var target = source.concat(</span><br><span class="line">    Rx.Observable.of(4,5,6),</span><br><span class="line">    Rx.Observable.of(7,8,9)</span><br><span class="line">); //序列：1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>
<h3 id="concatAll-如果源序列的元素也是序列-——-序列的序列，那么可以使用concatAll-方法将各元素序列按顺序拼接起来"><a href="#concatAll-如果源序列的元素也是序列-——-序列的序列，那么可以使用concatAll-方法将各元素序列按顺序拼接起来" class="headerlink" title="concatAll()  如果源序列的元素也是序列 —— 序列的序列，那么可以使用concatAll() 方法将各元素序列按顺序拼接起来"></a>concatAll()  如果源序列的元素也是序列 —— 序列的序列，那么可以使用concatAll() 方法将各元素序列按顺序拼接起来</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(10,20,30)</span><br><span class="line">    .map(function(item)&#123;</span><br><span class="line">        return Rx.Observable.range(item,3);</span><br><span class="line">    &#125;); //序列： Observable&#123;10,11,12&#125; Observable&#123;20,21,22&#125; Observable&#123;30,31,32&#125;</span><br><span class="line">var target = source.concatAll(); //序列：10 10 12 20 21 22 30 31 32</span><br></pre></td></tr></table></figure>
<h3 id="catch-捕捉源序列错误，返回新序列"><a href="#catch-捕捉源序列错误，返回新序列" class="headerlink" title="catch()  捕捉源序列错误，返回新序列"></a>catch()  捕捉源序列错误，返回新序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.create(function(o)&#123;</span><br><span class="line">    o.onNext(1);</span><br><span class="line">    o.onNext(2);</span><br><span class="line">    o.onError(new Error(&quot;fake error&quot;));</span><br><span class="line">    o.onNext(4);</span><br><span class="line">&#125;); //序列： 1 2 &lt;ERROR&gt; 4</span><br><span class="line">var target = source.catch(Rx.Observable.from(&quot;abc&quot;)); //序列： 1 2 a b c</span><br></pre></td></tr></table></figure>
<h3 id="pluck-针对元素为json对象的源序列，返回指定属性的值的序列"><a href="#pluck-针对元素为json对象的源序列，返回指定属性的值的序列" class="headerlink" title="pluck()  针对元素为json对象的源序列，返回指定属性的值的序列"></a>pluck()  针对元素为json对象的源序列，返回指定属性的值的序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(&#123;name:&apos;john&apos;,age:33&#125;,&#123;name:&apos;lee&apos;,age:22&#125;);</span><br><span class="line">var target = source.pluck(&apos;name&apos;);  //序列 john lee</span><br></pre></td></tr></table></figure>
<h3 id="flatMap-平坦化映射-首先将一个序列的各元素映射为序列，然后将各序列融合-参数是一个映射函数，返回值为序列"><a href="#flatMap-平坦化映射-首先将一个序列的各元素映射为序列，然后将各序列融合-参数是一个映射函数，返回值为序列" class="headerlink" title="flatMap()  平坦化映射:首先将一个序列的各元素映射为序列，然后将各序列融合  参数是一个映射函数，返回值为序列"></a>flatMap()  平坦化映射:首先将一个序列的各元素映射为序列，然后将各序列融合  参数是一个映射函数，返回值为序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(10,20);</span><br><span class="line">var mf = function(item)&#123;</span><br><span class="line">    return Rx.Observable.range(item,3)</span><br><span class="line">&#125;</span><br><span class="line">var target = source.flatMap(mf)  // 序列：10,11,20,12,21,22</span><br></pre></td></tr></table></figure>
<h3 id="flatMapLatest-与flatMap-的区别在于将最新的序列中的元素输出"><a href="#flatMapLatest-与flatMap-的区别在于将最新的序列中的元素输出" class="headerlink" title="flatMapLatest()  与flatMap()的区别在于将最新的序列中的元素输出"></a>flatMapLatest()  与flatMap()的区别在于将最新的序列中的元素输出</h3><h3 id="concatMap-将源序列各元素映射为序列，然后按顺序拼接-与flatMap的区别所在"><a href="#concatMap-将源序列各元素映射为序列，然后按顺序拼接-与flatMap的区别所在" class="headerlink" title="concatMap()  将源序列各元素映射为序列，然后按顺序拼接 (与flatMap的区别所在)"></a>concatMap()  将源序列各元素映射为序列，然后按顺序拼接 (与flatMap的区别所在)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,3);</span><br><span class="line">var mf = function(item)&#123;</span><br><span class="line">    return Rx.Observable.range(item,3);</span><br><span class="line">&#125;</span><br><span class="line">var target = source.concatMap(mf)  //序列：1,2,3,2,3,4,3,4,5</span><br></pre></td></tr></table></figure>
<h2 id="flatMap与map异同点"><a href="#flatMap与map异同点" class="headerlink" title="flatMap与map异同点"></a>flatMap与map异同点</h2><h3 id="Map用于对自身对象数值进行映射，将发射对象转换成另一个发射对象发射，返回一个包含映射结果的Observable对象。而flatMap是把自身对象里的数值进行映射并转换成一个新的Observable对象-当从其他类型对象中构建Observable对象时，需要使用flatMap方法"><a href="#Map用于对自身对象数值进行映射，将发射对象转换成另一个发射对象发射，返回一个包含映射结果的Observable对象。而flatMap是把自身对象里的数值进行映射并转换成一个新的Observable对象-当从其他类型对象中构建Observable对象时，需要使用flatMap方法" class="headerlink" title="Map用于对自身对象数值进行映射，将发射对象转换成另一个发射对象发射，返回一个包含映射结果的Observable对象。而flatMap是把自身对象里的数值进行映射并转换成一个新的Observable对象.当从其他类型对象中构建Observable对象时，需要使用flatMap方法"></a>Map用于对自身对象数值进行映射，将发射对象转换成另一个发射对象发射，返回一个包含映射结果的Observable对象。而flatMap是把自身对象里的数值进行映射并转换成一个新的Observable对象.当从其他类型对象中构建Observable对象时，需要使用flatMap方法</h3><h2 id="flatMap与concatMap异同点"><a href="#flatMap与concatMap异同点" class="headerlink" title="flatMap与concatMap异同点"></a>flatMap与concatMap异同点</h2><h3 id="merge和map结合与concat和map结合的区别，归根结底为merge与concat的区别，一个无序一个有序"><a href="#merge和map结合与concat和map结合的区别，归根结底为merge与concat的区别，一个无序一个有序" class="headerlink" title="merge和map结合与concat和map结合的区别，归根结底为merge与concat的区别，一个无序一个有序"></a>merge和map结合与concat和map结合的区别，归根结底为merge与concat的区别，一个无序一个有序</h3><h3 id="filter-筛选源序列中满足条件的元素，并返回新的序列"><a href="#filter-筛选源序列中满足条件的元素，并返回新的序列" class="headerlink" title="filter() 筛选源序列中满足条件的元素，并返回新的序列"></a>filter() 筛选源序列中满足条件的元素，并返回新的序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,3,4,5); //序列： 1 2 3 4 5</span><br><span class="line">var target = source.filter(x =&gt; x&lt;4)  //序列： 1 2 3</span><br></pre></td></tr></table></figure>
<h3 id="skip-num-抑制序列头部元素数量输出-skipLast-num-尾部-skipWhile-if-指定一个条件"><a href="#skip-num-抑制序列头部元素数量输出-skipLast-num-尾部-skipWhile-if-指定一个条件" class="headerlink" title="skip(num) 抑制序列头部元素数量输出   skipLast(num)尾部   skipWhile(if)指定一个条件"></a>skip(num) 抑制序列头部元素数量输出   skipLast(num)尾部   skipWhile(if)指定一个条件</h3><h3 id="take-num-截取序列头部元素数量输出-takeLast-num-尾部-takeWhile-if-指定一个条件"><a href="#take-num-截取序列头部元素数量输出-takeLast-num-尾部-takeWhile-if-指定一个条件" class="headerlink" title="take(num) 截取序列头部元素数量输出   takeLast(num)尾部   takeWhile(if)指定一个条件"></a>take(num) 截取序列头部元素数量输出   takeLast(num)尾部   takeWhile(if)指定一个条件</h3><h3 id="distinct-去重-并返回一个新序列"><a href="#distinct-去重-并返回一个新序列" class="headerlink" title="distinct 去重,并返回一个新序列"></a>distinct 去重,并返回一个新序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,3,4,2,1); //序列： 1 2 3 4 2 1</span><br><span class="line">var target = source.distinct(); //序列：1 2 3 4</span><br></pre></td></tr></table></figure>
<h3 id="distinctUntilChanged-去重-并返回一个新序列"><a href="#distinctUntilChanged-去重-并返回一个新序列" class="headerlink" title="distinctUntilChanged 去重,并返回一个新序列"></a>distinctUntilChanged 去重,并返回一个新序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,2,3,4,2,1); //序列： 1 2 3 4 2 1</span><br><span class="line">var target = source.distinctUntilChanged(); //序列：1 2 3 4 2 1</span><br></pre></td></tr></table></figure>
<h3 id="debounce-去抖动-一段时间内只取最新数据作为一次发射数据，其他数据取消发射"><a href="#debounce-去抖动-一段时间内只取最新数据作为一次发射数据，其他数据取消发射" class="headerlink" title="debounce  去抖动,一段时间内只取最新数据作为一次发射数据，其他数据取消发射"></a>debounce  去抖动,一段时间内只取最新数据作为一次发射数据，其他数据取消发射</h3><h3 id="throttle-和debounce唯一区别是debounce取一段时间内最新的，而throttle忽略这段时间后，发现新值才发送-通俗讲，都设定一个时间周期，持续触发事件，throttle为每到时间周期便会触发一次，bebounce为触发周期小于设定时间周期不予事件触发）"><a href="#throttle-和debounce唯一区别是debounce取一段时间内最新的，而throttle忽略这段时间后，发现新值才发送-通俗讲，都设定一个时间周期，持续触发事件，throttle为每到时间周期便会触发一次，bebounce为触发周期小于设定时间周期不予事件触发）" class="headerlink" title="throttle(和debounce唯一区别是debounce取一段时间内最新的，而throttle忽略这段时间后，发现新值才发送, 通俗讲，都设定一个时间周期，持续触发事件，throttle为每到时间周期便会触发一次，bebounce为触发周期小于设定时间周期不予事件触发）"></a>throttle(和debounce唯一区别是debounce取一段时间内最新的，而throttle忽略这段时间后，发现新值才发送, 通俗讲，都设定一个时间周期，持续触发事件，throttle为每到时间周期便会触发一次，bebounce为触发周期小于设定时间周期不予事件触发）</h3><h3 id="buffer-使用第二个序列触发源序列中多个元素的打包"><a href="#buffer-使用第二个序列触发源序列中多个元素的打包" class="headerlink" title="buffer() 使用第二个序列触发源序列中多个元素的打包"></a>buffer() 使用第二个序列触发源序列中多个元素的打包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.timer(0,1000);    //序列：0 1 2 3 ...</span><br><span class="line">var boundaries = Rx.Observable.timer(2500); //延时2500ms触发</span><br><span class="line">var target = source.buffer(boundaries); //序列： [0,1,2]</span><br></pre></td></tr></table></figure>
<h3 id="bufferWithTime-按固定时间间隔对源序列进行打包"><a href="#bufferWithTime-按固定时间间隔对源序列进行打包" class="headerlink" title="bufferWithTime() 按固定时间间隔对源序列进行打包"></a>bufferWithTime() 按固定时间间隔对源序列进行打包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.timer(0,1000); //序列：0 1 2 3 ...</span><br><span class="line">var target = source.bufferWithTime(2500); //序列：[0,1,2] [3,4] ...</span><br></pre></td></tr></table></figure>
<h3 id="zip-支持可变数量的序列作为参数，最后一个参数应当是一个组合函数，-其返回值将作为目标序列的元素"><a href="#zip-支持可变数量的序列作为参数，最后一个参数应当是一个组合函数，-其返回值将作为目标序列的元素" class="headerlink" title="zip()  支持可变数量的序列作为参数，最后一个参数应当是一个组合函数， 其返回值将作为目标序列的元素"></a>zip()  支持可变数量的序列作为参数，最后一个参数应当是一个组合函数， 其返回值将作为目标序列的元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var source1 = Rx.Observable.of(1,2,3); //序列： 1 2 3</span><br><span class="line">var source2 = Rx.Observable.of(4,5,6); //序列：4 5 6</span><br><span class="line">var cf = function(d1,d2)&#123; return d1 + &apos;-&apos; + d2;&#125;;</span><br><span class="line">var target = Rx.Observable.zip(source1,source2,cf); //序列： 1-4 2-5 3-6</span><br></pre></td></tr></table></figure>
<h3 id="forkJoin-将多个序列的最后一个元素组合为一个数组后，作为目标序列的唯一元素"><a href="#forkJoin-将多个序列的最后一个元素组合为一个数组后，作为目标序列的唯一元素" class="headerlink" title="forkJoin()  将多个序列的最后一个元素组合为一个数组后，作为目标序列的唯一元素"></a>forkJoin()  将多个序列的最后一个元素组合为一个数组后，作为目标序列的唯一元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var source1 = Rx.Observable.of(1,2,3); //序列： 1 2 3</span><br><span class="line">var source2 = Rx.Observable.of(4,5,6); //序列： 4 5 6</span><br><span class="line">var target = Rz.Observable.forkJoin(source1,source2); //序列：[3,6]</span><br></pre></td></tr></table></figure>
<h3 id="combineLatest-将多个序列的最后一个元素，使用组合函数构成目标序列的一个新元素"><a href="#combineLatest-将多个序列的最后一个元素，使用组合函数构成目标序列的一个新元素" class="headerlink" title="combineLatest() 将多个序列的最后一个元素，使用组合函数构成目标序列的一个新元素"></a>combineLatest() 将多个序列的最后一个元素，使用组合函数构成目标序列的一个新元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var source1 = Rx.Observable.interval(200).map(x =&gt; &apos;First:&apos; + x)</span><br><span class="line">var source2 = Rx.Observable.interval(100).map(x =&gt; &apos;Second:&apos; + x)</span><br><span class="line">var source = Rx.Observable.combineLatest(</span><br><span class="line">    source1,</span><br><span class="line">    source2</span><br><span class="line">).take(4);   // [&quot;First:0&quot;, &quot;Second:0&quot;]  [&quot;First:0&quot;, &quot;Second:1&quot;]  [&quot;First:0&quot;, &quot;Second:2&quot;]   [&quot;First:1&quot;, &quot;Second:2&quot;]</span><br></pre></td></tr></table></figure>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/11/21/ng1与ng2依赖注入的比较/" rel="next" title="依赖注入">
                <i class="fa fa-chevron-left"></i> 依赖注入
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/04/13/Subject/" rel="prev" title="Subject">
                Subject <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image" src="https://github.com/vernvn/hexoBlog/blob/master/avator/github.jpg?raw=true" alt="Lee">
          <p class="site-author-name" itemprop="name">Lee</p>
          <p class="site-description motion-element" itemprop="description">my blog</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">23</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。最好的Rxjs中文文档"><span class="nav-number">1.</span> <span class="nav-text">首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。最好的Rxjs中文文档</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RXJS全名Reactive-Extensions-for-JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。"><span class="nav-number">1.1.</span> <span class="nav-text">RXJS全名Reactive Extensions for JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RxJS所能解决的问题："><span class="nav-number">1.2.</span> <span class="nav-text">RxJS所能解决的问题：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时刻保持响应。这对于一个应用来说意味着当他处理用户的输入或者凭借AJAX从服务器接受一些数据时停止是一件不可能接受的事情。在JavaScript中解决问题的方案始终是大量运用回调函数来进行一些运行的处理。但回调的使用使内容丰富的大型应用变得凌乱，一旦你需要多块数据时你就陷入了回调地狱。Angular2中，组件间通讯-Output对应的EventEmitter实际上就是一个Subject-主题：同时为Observable和Observer-Http模块中Observable作为大部分API的交互对象使用。但是这只是官方的外部扩展，并不必须，也可以使用-toPromise的方式转换为Promise来使用或第三方扩展库或Fetch-API-传统Ajax已死，Fetch永生。"><span class="nav-number">1.2.1.</span> <span class="nav-text">时刻保持响应。这对于一个应用来说意味着当他处理用户的输入或者凭借AJAX从服务器接受一些数据时停止是一件不可能接受的事情。在JavaScript中解决问题的方案始终是大量运用回调函数来进行一些运行的处理。但回调的使用使内容丰富的大型应用变得凌乱，一旦你需要多块数据时你就陷入了回调地狱。Angular2中，组件间通讯@Output对应的EventEmitter实际上就是一个Subject(主题：同时为Observable和Observer);Http模块中Observable作为大部分API的交互对象使用。但是这只是官方的外部扩展，并不必须，也可以使用.toPromise的方式转换为Promise来使用或第三方扩展库或Fetch API 传统Ajax已死，Fetch永生。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RxJS初探："><span class="nav-number">1.3.</span> <span class="nav-text">RxJS初探：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RxJS是一个解决异步问题的JS开发库-它带来了观察者模式和函数式编程的相结合的最佳实践。-观察者模式是一个被实践证明的模式，基于生产者（事件的创建者）和消费者（事件的监听者）的逻辑分离关系-况且函数式编程方式的引入，如说明性编程，不可变数据结构，链式方法调用会使你极大的简化代码量。RxJS-引入了一个重要的数据类型——流（stream）。流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下，等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。"><span class="nav-number">1.3.1.</span> <span class="nav-text">RxJS是一个解决异步问题的JS开发库.它带来了观察者模式和函数式编程的相结合的最佳实践。 观察者模式是一个被实践证明的模式，基于生产者（事件的创建者）和消费者（事件的监听者）的逻辑分离关系.况且函数式编程方式的引入，如说明性编程，不可变数据结构，链式方法调用会使你极大的简化代码量。RxJS 引入了一个重要的数据类型——流（stream）。流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下，等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream"><span class="nav-number">1.4.</span> <span class="nav-text">Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。"><span class="nav-number">1.4.1.</span> <span class="nav-text">流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事件引发的改变总是从事件源（生产者）-向下传递到所有事件监听方（消费者）。如果变量看做流呢，又是什么结果呢？"><span class="nav-number">1.4.2.</span> <span class="nav-text">事件引发的改变总是从事件源（生产者）,向下传递到所有事件监听方（消费者）。如果变量看做流呢，又是什么结果呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#流的方式重新定义的变量值的动态行为-换句话说，C-是把两个流变量A-和B-进行合并操作。当一个新值被推进了A-，C-立刻响应式的变更为16。"><span class="nav-number">1.4.3.</span> <span class="nav-text">流的方式重新定义的变量值的动态行为.换句话说，C$是把两个流变量A$和B$进行合并操作。当一个新值被推进了A$，C$立刻响应式的变更为16。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开始了解RxJS中的几个重要成员"><span class="nav-number">1.5.</span> <span class="nav-text">开始了解RxJS中的几个重要成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第一个例子"><span class="nav-number">1.6.</span> <span class="nav-text">第一个例子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用RxJS创建一个可观察对象："><span class="nav-number">1.6.1.</span> <span class="nav-text">使用RxJS创建一个可观察对象：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#observable可观察对象，以惰性的方式推送多值的集合"><span class="nav-number">1.7.</span> <span class="nav-text">observable可观察对象，以惰性的方式推送多值的集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#下面的例子是一个推送1-2，3-4数值的可观察对象，一旦它被订阅1-2，3-就会被推送，4则会在订阅发生一秒之后被推送，紧接着完成推送"><span class="nav-number">1.7.1.</span> <span class="nav-text">下面的例子是一个推送1,2，3,4数值的可观察对象，一旦它被订阅1,2，3,就会被推送，4则会在订阅发生一秒之后被推送，紧接着完成推送</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pull拉取-VS-Push推送"><span class="nav-number">1.8.</span> <span class="nav-text">Pull拉取 VS Push推送</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#拉和推是数据生产者和数据的消费者两种不同的交流协议-方式"><span class="nav-number">1.8.1.</span> <span class="nav-text">拉和推是数据生产者和数据的消费者两种不同的交流协议(方式);</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是”Pull拉”？在”拉”体系中，数据的消费者决定何时从数据生产者那里获取数据，而生产者自身并不会意识到什么时候数据将会被发送给消费者。"><span class="nav-number">1.8.2.</span> <span class="nav-text">什么是”Pull拉”？在”拉”体系中，数据的消费者决定何时从数据生产者那里获取数据，而生产者自身并不会意识到什么时候数据将会被发送给消费者。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#每一个JS函数都是一个“拉”体系，函数是数据的生产者，调用函数的代码通过“拉出”一个单一的返回值来消费该数据-return-语句-。"><span class="nav-number">1.8.3.</span> <span class="nav-text">每一个JS函数都是一个“拉”体系，函数是数据的生产者，调用函数的代码通过“拉出”一个单一的返回值来消费该数据(return 语句)。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是”Push推”？在推体系中，数据的生产者决定何时发送数据给消费者，消费者不会在接收数据之前意识到它将要接收这个数据。"><span class="nav-number">1.8.4.</span> <span class="nav-text">什么是”Push推”？在推体系中，数据的生产者决定何时发送数据给消费者，消费者不会在接收数据之前意识到它将要接收这个数据。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-承诺-是当今JS中最常见的Push推体系，一个Promise-数据的生产者-发送一个resolved-value-成功状态的值-来注册一个回调-数据消费者-，但是不同于函数的地方的是：Promise决定着何时数据才被推送至这个回调函数。"><span class="nav-number">1.8.5.</span> <span class="nav-text">Promise(承诺))是当今JS中最常见的Push推体系，一个Promise(数据的生产者)发送一个resolved value(成功状态的值)来注册一个回调(数据消费者)，但是不同于函数的地方的是：Promise决定着何时数据才被推送至这个回调函数。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RxJS引入了Observables-可观察对象-，一个全新的”推体系”。一个可观察对象是一个产生多值的生产者，并”推送给”Observer-观察者-。"><span class="nav-number">1.8.6.</span> <span class="nav-text">RxJS引入了Observables(可观察对象)，一个全新的”推体系”。一个可观察对象是一个产生多值的生产者，并”推送给”Observer(观察者)。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RxJS-VS-Promise—3个最重要的不同点"><span class="nav-number">1.9.</span> <span class="nav-text">RxJS VS Promise—3个最重要的不同点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Operators操作符"><span class="nav-number">2.</span> <span class="nav-text">Operators操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#create-创建一个可观察序列，参数为一个封装数据生成逻辑的函数，该函数的参数为观察者"><span class="nav-number">2.1.</span> <span class="nav-text">create()  创建一个可观察序列，参数为一个封装数据生成逻辑的函数，该函数的参数为观察者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#empty-不需要传递参数，创建一个空序列并立即结束"><span class="nav-number">2.2.</span> <span class="nav-text">empty()  不需要传递参数，创建一个空序列并立即结束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#never-不需要传递参数，创建一个空序列，并永远不结束"><span class="nav-number">2.3.</span> <span class="nav-text">never() 不需要传递参数，创建一个空序列，并永远不结束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#throw-创建一个空序列，参数来声明错误并立即抛出错误"><span class="nav-number">2.4.</span> <span class="nav-text">throw() 创建一个空序列，参数来声明错误并立即抛出错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#range-创建一个有线长度的整数序列，两个参数，第一个起始值，第二个元素数量"><span class="nav-number">2.5.</span> <span class="nav-text">range() 创建一个有线长度的整数序列，两个参数，第一个起始值，第二个元素数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#interval-创建一个无限长度的周期性序列"><span class="nav-number">2.6.</span> <span class="nav-text">interval() 创建一个无限长度的周期性序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#timer-指定一个额外的参数来调节第一值的静默时长，第二个参数可选，若无则仅仅在规定的静默时长后输出一个值，然后结束序列"><span class="nav-number">2.7.</span> <span class="nav-text">timer() 指定一个额外的参数来调节第一值的静默时长，第二个参数可选，若无则仅仅在规定的静默时长后输出一个值，然后结束序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#from-可以将已有的数据转化为Observable-参数为iterable数据集对象-常见Array-String"><span class="nav-number">2.8.</span> <span class="nav-text">from() 可以将已有的数据转化为Observable,参数为iterable数据集对象,常见Array,String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#of-不在同一个数据集中的多个来源的数据，使用of-方法直接构造："><span class="nav-number">2.9.</span> <span class="nav-text">of()  不在同一个数据集中的多个来源的数据，使用of()方法直接构造：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#just-将任何数据转化为一个单值输出的Observable"><span class="nav-number">2.10.</span> <span class="nav-text">just()  将任何数据转化为一个单值输出的Observable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#repeat-创建一个重复值序列-par1-值，par2：次数"><span class="nav-number">2.11.</span> <span class="nav-text">repeat() 创建一个重复值序列  par1:值，par2：次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fromEvent-将事件流转化为Observable"><span class="nav-number">2.12.</span> <span class="nav-text">fromEvent() 将事件流转化为Observable,</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#toArray-将序列还原为数组对象-只有在订阅后才还原为数组"><span class="nav-number">2.13.</span> <span class="nav-text">toArray() 将序列还原为数组对象,只有在订阅后才还原为数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#delay-推迟-参数为数字或Date对象"><span class="nav-number">2.14.</span> <span class="nav-text">delay() 推迟   参数为数字或Date对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#delaySubscription-延迟订阅-参数同理"><span class="nav-number">2.15.</span> <span class="nav-text">delaySubscription() 延迟订阅  参数同理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#startWith-可以在源序列之前添加额外的元素"><span class="nav-number">2.16.</span> <span class="nav-text">startWith() 可以在源序列之前添加额外的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-对源序列进行变换，并返回新的序列-改变了源"><span class="nav-number">2.17.</span> <span class="nav-text">map() 对源序列进行变换，并返回新的序列(改变了源)</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#concat-有序拼接-merge-无序"><span class="nav-number"></span> <span class="nav-text">concat() 有序拼接   merge()无序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#concatAll-如果源序列的元素也是序列-——-序列的序列，那么可以使用concatAll-方法将各元素序列按顺序拼接起来"><span class="nav-number">0.1.</span> <span class="nav-text">concatAll()  如果源序列的元素也是序列 —— 序列的序列，那么可以使用concatAll() 方法将各元素序列按顺序拼接起来</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#catch-捕捉源序列错误，返回新序列"><span class="nav-number">0.2.</span> <span class="nav-text">catch()  捕捉源序列错误，返回新序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pluck-针对元素为json对象的源序列，返回指定属性的值的序列"><span class="nav-number">0.3.</span> <span class="nav-text">pluck()  针对元素为json对象的源序列，返回指定属性的值的序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flatMap-平坦化映射-首先将一个序列的各元素映射为序列，然后将各序列融合-参数是一个映射函数，返回值为序列"><span class="nav-number">0.4.</span> <span class="nav-text">flatMap()  平坦化映射:首先将一个序列的各元素映射为序列，然后将各序列融合  参数是一个映射函数，返回值为序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flatMapLatest-与flatMap-的区别在于将最新的序列中的元素输出"><span class="nav-number">0.5.</span> <span class="nav-text">flatMapLatest()  与flatMap()的区别在于将最新的序列中的元素输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#concatMap-将源序列各元素映射为序列，然后按顺序拼接-与flatMap的区别所在"><span class="nav-number">0.6.</span> <span class="nav-text">concatMap()  将源序列各元素映射为序列，然后按顺序拼接 (与flatMap的区别所在)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#flatMap与map异同点"><span class="nav-number">1.</span> <span class="nav-text">flatMap与map异同点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Map用于对自身对象数值进行映射，将发射对象转换成另一个发射对象发射，返回一个包含映射结果的Observable对象。而flatMap是把自身对象里的数值进行映射并转换成一个新的Observable对象-当从其他类型对象中构建Observable对象时，需要使用flatMap方法"><span class="nav-number">1.1.</span> <span class="nav-text">Map用于对自身对象数值进行映射，将发射对象转换成另一个发射对象发射，返回一个包含映射结果的Observable对象。而flatMap是把自身对象里的数值进行映射并转换成一个新的Observable对象.当从其他类型对象中构建Observable对象时，需要使用flatMap方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#flatMap与concatMap异同点"><span class="nav-number">2.</span> <span class="nav-text">flatMap与concatMap异同点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#merge和map结合与concat和map结合的区别，归根结底为merge与concat的区别，一个无序一个有序"><span class="nav-number">2.1.</span> <span class="nav-text">merge和map结合与concat和map结合的区别，归根结底为merge与concat的区别，一个无序一个有序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#filter-筛选源序列中满足条件的元素，并返回新的序列"><span class="nav-number">2.2.</span> <span class="nav-text">filter() 筛选源序列中满足条件的元素，并返回新的序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#skip-num-抑制序列头部元素数量输出-skipLast-num-尾部-skipWhile-if-指定一个条件"><span class="nav-number">2.3.</span> <span class="nav-text">skip(num) 抑制序列头部元素数量输出   skipLast(num)尾部   skipWhile(if)指定一个条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#take-num-截取序列头部元素数量输出-takeLast-num-尾部-takeWhile-if-指定一个条件"><span class="nav-number">2.4.</span> <span class="nav-text">take(num) 截取序列头部元素数量输出   takeLast(num)尾部   takeWhile(if)指定一个条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#distinct-去重-并返回一个新序列"><span class="nav-number">2.5.</span> <span class="nav-text">distinct 去重,并返回一个新序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#distinctUntilChanged-去重-并返回一个新序列"><span class="nav-number">2.6.</span> <span class="nav-text">distinctUntilChanged 去重,并返回一个新序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#debounce-去抖动-一段时间内只取最新数据作为一次发射数据，其他数据取消发射"><span class="nav-number">2.7.</span> <span class="nav-text">debounce  去抖动,一段时间内只取最新数据作为一次发射数据，其他数据取消发射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#throttle-和debounce唯一区别是debounce取一段时间内最新的，而throttle忽略这段时间后，发现新值才发送-通俗讲，都设定一个时间周期，持续触发事件，throttle为每到时间周期便会触发一次，bebounce为触发周期小于设定时间周期不予事件触发）"><span class="nav-number">2.8.</span> <span class="nav-text">throttle(和debounce唯一区别是debounce取一段时间内最新的，而throttle忽略这段时间后，发现新值才发送, 通俗讲，都设定一个时间周期，持续触发事件，throttle为每到时间周期便会触发一次，bebounce为触发周期小于设定时间周期不予事件触发）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buffer-使用第二个序列触发源序列中多个元素的打包"><span class="nav-number">2.9.</span> <span class="nav-text">buffer() 使用第二个序列触发源序列中多个元素的打包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bufferWithTime-按固定时间间隔对源序列进行打包"><span class="nav-number">2.10.</span> <span class="nav-text">bufferWithTime() 按固定时间间隔对源序列进行打包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zip-支持可变数量的序列作为参数，最后一个参数应当是一个组合函数，-其返回值将作为目标序列的元素"><span class="nav-number">2.11.</span> <span class="nav-text">zip()  支持可变数量的序列作为参数，最后一个参数应当是一个组合函数， 其返回值将作为目标序列的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#forkJoin-将多个序列的最后一个元素组合为一个数组后，作为目标序列的唯一元素"><span class="nav-number">2.12.</span> <span class="nav-text">forkJoin()  将多个序列的最后一个元素组合为一个数组后，作为目标序列的唯一元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#combineLatest-将多个序列的最后一个元素，使用组合函数构成目标序列的一个新元素"><span class="nav-number">2.13.</span> <span class="nav-text">combineLatest() 将多个序列的最后一个元素，使用组合函数构成目标序列的一个新元素</span></a></li></ol></li></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lee</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lee/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lee/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lee/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lee/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lee/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lee/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

  


</body>
</html>
