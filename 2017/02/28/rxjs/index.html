<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://vernvn.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。最好的Rxjs中文文档RXJS全名Reactive Extensions for JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。RxJS所能解决的问题：时刻保持响">
<meta property="og:type" content="article">
<meta property="og:title" content="RxJS:万物皆为流">
<meta property="og:url" content="http:&#x2F;&#x2F;vernvn.github.io&#x2F;2017&#x2F;02&#x2F;28&#x2F;rxjs&#x2F;index.html">
<meta property="og:site_name" content="努力混迹江湖的前端小白">
<meta property="og:description" content="首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。最好的Rxjs中文文档RXJS全名Reactive Extensions for JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。RxJS所能解决的问题：时刻保持响">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-02-08T02:09:02.000Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://vernvn.github.io/2017/02/28/rxjs/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>RxJS:万物皆为流 | 努力混迹江湖的前端小白</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="努力混迹江湖的前端小白" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">努力混迹江湖的前端小白</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">25</span></a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vernvn.github.io/2017/02/28/rxjs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/17755520?s=400&u=9f444bfe70cd719b9bf43ed5fedac2f1d005ff5a&v=4">
      <meta itemprop="name" content="Lee_Ran">
      <meta itemprop="description" content="保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力混迹江湖的前端小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RxJS:万物皆为流
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-02-28 13:54:14" itemprop="dateCreated datePublished" datetime="2017-02-28T13:54:14+08:00">2017-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-02-08 10:09:02" itemprop="dateModified" datetime="2018-02-08T10:09:02+08:00">2018-02-08</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/02/28/rxjs/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2017/02/28/rxjs/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。最好的Rxjs中文文档"><a href="#首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。最好的Rxjs中文文档" class="headerlink" title="首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。最好的Rxjs中文文档"></a>首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。<a href="https://www.gitbook.com/book/buctwbzs/rxjs/details" target="_blank" rel="noopener">最好的Rxjs中文文档</a></h2><h3 id="RXJS全名Reactive-Extensions-for-JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。"><a href="#RXJS全名Reactive-Extensions-for-JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。" class="headerlink" title="RXJS全名Reactive Extensions for JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。"></a>RXJS全名Reactive Extensions for JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。</h3><h3 id="RxJS所能解决的问题："><a href="#RxJS所能解决的问题：" class="headerlink" title="RxJS所能解决的问题："></a>RxJS所能解决的问题：</h3><h4 id="时刻保持响应。这对于一个应用来说意味着当他处理用户的输入或者凭借AJAX从服务器接受一些数据时停止是一件不可能接受的事情。在JavaScript中解决问题的方案始终是大量运用回调函数来进行一些运行的处理。但回调的使用使内容丰富的大型应用变得凌乱，一旦你需要多块数据时你就陷入了回调地狱。Angular2中，组件间通讯-Output对应的EventEmitter实际上就是一个Subject-主题：同时为Observable和Observer-Http模块中Observable作为大部分API的交互对象使用。但是这只是官方的外部扩展，并不必须，也可以使用-toPromise的方式转换为Promise来使用或第三方扩展库或Fetch-API-传统Ajax已死，Fetch永生。"><a href="#时刻保持响应。这对于一个应用来说意味着当他处理用户的输入或者凭借AJAX从服务器接受一些数据时停止是一件不可能接受的事情。在JavaScript中解决问题的方案始终是大量运用回调函数来进行一些运行的处理。但回调的使用使内容丰富的大型应用变得凌乱，一旦你需要多块数据时你就陷入了回调地狱。Angular2中，组件间通讯-Output对应的EventEmitter实际上就是一个Subject-主题：同时为Observable和Observer-Http模块中Observable作为大部分API的交互对象使用。但是这只是官方的外部扩展，并不必须，也可以使用-toPromise的方式转换为Promise来使用或第三方扩展库或Fetch-API-传统Ajax已死，Fetch永生。" class="headerlink" title="时刻保持响应。这对于一个应用来说意味着当他处理用户的输入或者凭借AJAX从服务器接受一些数据时停止是一件不可能接受的事情。在JavaScript中解决问题的方案始终是大量运用回调函数来进行一些运行的处理。但回调的使用使内容丰富的大型应用变得凌乱，一旦你需要多块数据时你就陷入了回调地狱。Angular2中，组件间通讯@Output对应的EventEmitter实际上就是一个Subject(主题：同时为Observable和Observer);Http模块中Observable作为大部分API的交互对象使用。但是这只是官方的外部扩展，并不必须，也可以使用.toPromise的方式转换为Promise来使用或第三方扩展库或Fetch API 传统Ajax已死，Fetch永生。"></a>时刻保持响应。这对于一个应用来说意味着当他处理用户的输入或者凭借AJAX从服务器接受一些数据时停止是一件不可能接受的事情。在JavaScript中解决问题的方案始终是大量运用回调函数来进行一些运行的处理。但回调的使用使内容丰富的大型应用变得凌乱，一旦你需要多块数据时你就陷入了回调地狱。Angular2中，组件间通讯@Output对应的EventEmitter实际上就是一个Subject(主题：同时为Observable和Observer);Http模块中Observable作为大部分API的交互对象使用。但是这只是官方的外部扩展，并不必须，也可以使用.toPromise的方式转换为Promise来使用或第三方扩展库或Fetch API <a href="https://segmentfault.com/a/1190000003810652" target="_blank" rel="noopener">传统Ajax已死，Fetch永生</a>。</h4><p><br></p>
<h3 id="RxJS初探："><a href="#RxJS初探：" class="headerlink" title="RxJS初探："></a>RxJS初探：</h3><h4 id="RxJS是一个解决异步问题的JS开发库-它带来了观察者模式和函数式编程的相结合的最佳实践。-观察者模式是一个被实践证明的模式，基于生产者（事件的创建者）和消费者（事件的监听者）的逻辑分离关系-况且函数式编程方式的引入，如说明性编程，不可变数据结构，链式方法调用会使你极大的简化代码量。RxJS-引入了一个重要的数据类型——流（stream）。流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下，等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。"><a href="#RxJS是一个解决异步问题的JS开发库-它带来了观察者模式和函数式编程的相结合的最佳实践。-观察者模式是一个被实践证明的模式，基于生产者（事件的创建者）和消费者（事件的监听者）的逻辑分离关系-况且函数式编程方式的引入，如说明性编程，不可变数据结构，链式方法调用会使你极大的简化代码量。RxJS-引入了一个重要的数据类型——流（stream）。流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下，等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。" class="headerlink" title="RxJS是一个解决异步问题的JS开发库.它带来了观察者模式和函数式编程的相结合的最佳实践。 观察者模式是一个被实践证明的模式，基于生产者（事件的创建者）和消费者（事件的监听者）的逻辑分离关系.况且函数式编程方式的引入，如说明性编程，不可变数据结构，链式方法调用会使你极大的简化代码量。RxJS 引入了一个重要的数据类型——流（stream）。流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下，等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。"></a>RxJS是一个解决异步问题的JS开发库.它带来了观察者模式和函数式编程的相结合的最佳实践。 观察者模式是一个被实践证明的模式，基于生产者（事件的创建者）和消费者（事件的监听者）的逻辑分离关系.况且函数式编程方式的引入，如说明性编程，不可变数据结构，链式方法调用会使你极大的简化代码量。RxJS 引入了一个重要的数据类型——流（stream）。流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下，等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。</h4><p><br></p>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><h4 id="流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。"><a href="#流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。" class="headerlink" title="流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。"></a>流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 2;</span><br><span class="line">var b = 4;</span><br><span class="line">var c = a + b;</span><br><span class="line">console.log(c); //-&gt; 6</span><br><span class="line">a = 10;  // reassign a</span><br><span class="line">console.log(c); //-&gt; still 6</span><br></pre></td></tr></table></figure>
<h4 id="事件引发的改变总是从事件源（生产者）-向下传递到所有事件监听方（消费者）。如果变量看做流呢，又是什么结果呢？"><a href="#事件引发的改变总是从事件源（生产者）-向下传递到所有事件监听方（消费者）。如果变量看做流呢，又是什么结果呢？" class="headerlink" title="事件引发的改变总是从事件源（生产者）,向下传递到所有事件监听方（消费者）。如果变量看做流呢，又是什么结果呢？"></a>事件引发的改变总是从事件源（生产者）,向下传递到所有事件监听方（消费者）。如果变量看做流呢，又是什么结果呢？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var A$ = 2;</span><br><span class="line">var B$ = 4;</span><br><span class="line">var C$ = A$ + B$;</span><br><span class="line">console.log(C$); //-&gt; 6</span><br><span class="line">A$ = 10;  </span><br><span class="line">console.log(C$); //-&gt;  16</span><br></pre></td></tr></table></figure>
<h4 id="流的方式重新定义的变量值的动态行为-换句话说，C-是把两个流变量A-和B-进行合并操作。当一个新值被推进了A-，C-立刻响应式的变更为16。"><a href="#流的方式重新定义的变量值的动态行为-换句话说，C-是把两个流变量A-和B-进行合并操作。当一个新值被推进了A-，C-立刻响应式的变更为16。" class="headerlink" title="流的方式重新定义的变量值的动态行为.换句话说，C$是把两个流变量A$和B$进行合并操作。当一个新值被推进了A$，C$立刻响应式的变更为16。"></a>流的方式重新定义的变量值的动态行为.换句话说，C$是把两个流变量A$和B$进行合并操作。当一个新值被推进了A$，C$立刻响应式的变更为16。</h4><h3 id="开始了解RxJS中的几个重要成员"><a href="#开始了解RxJS中的几个重要成员" class="headerlink" title="开始了解RxJS中的几个重要成员"></a>开始了解RxJS中的几个重要成员</h3><ul>
<li>Observable可观察对象：表示一个可调用的未来值或者事件的集合。</li>
<li>Observer观察者：一个回调函数集合,它知道怎样去监听被Observable发送的值</li>
<li>Subscription订阅： 表示一个可观察对象的执行，主要用于取消执行。</li>
<li>Operators操作符： 纯粹的函数，使得以函数编程的方式处理集合比如:map,filter,contact,flatmap。</li>
<li>Subject(主题)：等同于一个事件驱动器，是将一个值或者事件广播到多个观察者的唯一途径。</li>
<li>Schedulers(调度者)： 用来控制并发，当计算发生的时候允许我们协调，比如setTimeout,requestAnimationFrame。<h3 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h3><h4 id="使用RxJS创建一个可观察对象："><a href="#使用RxJS创建一个可观察对象：" class="headerlink" title="使用RxJS创建一个可观察对象："></a>使用RxJS创建一个可观察对象：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var button = document.querySelector(&apos;button&apos;);</span><br><span class="line">Rx.Observable.fromEvent(button, &apos;click&apos;)</span><br><span class="line">.throttleTime(1000)</span><br><span class="line">.scan(count =&gt; count + 1, 0)   </span><br><span class="line">.subscribe(count =&gt; console.log(`Clicked $&#123;count&#125; times`));</span><br></pre></td></tr></table></figure>
<h3 id="observable可观察对象，以惰性的方式推送多值的集合"><a href="#observable可观察对象，以惰性的方式推送多值的集合" class="headerlink" title="observable可观察对象，以惰性的方式推送多值的集合"></a>observable可观察对象，以惰性的方式推送多值的集合</h3><h4 id="下面的例子是一个推送1-2，3-4数值的可观察对象，一旦它被订阅1-2，3-就会被推送，4则会在订阅发生一秒之后被推送，紧接着完成推送"><a href="#下面的例子是一个推送1-2，3-4数值的可观察对象，一旦它被订阅1-2，3-就会被推送，4则会在订阅发生一秒之后被推送，紧接着完成推送" class="headerlink" title="下面的例子是一个推送1,2，3,4数值的可观察对象，一旦它被订阅1,2，3,就会被推送，4则会在订阅发生一秒之后被推送，紧接着完成推送"></a>下面的例子是一个推送1,2，3,4数值的可观察对象，一旦它被订阅1,2，3,就会被推送，4则会在订阅发生一秒之后被推送，紧接着完成推送</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var observable = Rx.Observable.create(observer=&gt;&#123;</span><br><span class="line">    observer.next(1);</span><br><span class="line">    observer.next(2);</span><br><span class="line">    observer.next(3);</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        observer.next(4);</span><br><span class="line">        observer.complete();</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Pull拉取-VS-Push推送"><a href="#Pull拉取-VS-Push推送" class="headerlink" title="Pull拉取 VS Push推送"></a>Pull拉取 VS Push推送</h3><h4 id="拉和推是数据生产者和数据的消费者两种不同的交流协议-方式"><a href="#拉和推是数据生产者和数据的消费者两种不同的交流协议-方式" class="headerlink" title="拉和推是数据生产者和数据的消费者两种不同的交流协议(方式);"></a>拉和推是数据生产者和数据的消费者两种不同的交流协议(方式);</h4><br><h4 id="什么是”Pull拉”？在”拉”体系中，数据的消费者决定何时从数据生产者那里获取数据，而生产者自身并不会意识到什么时候数据将会被发送给消费者。"><a href="#什么是”Pull拉”？在”拉”体系中，数据的消费者决定何时从数据生产者那里获取数据，而生产者自身并不会意识到什么时候数据将会被发送给消费者。" class="headerlink" title="什么是”Pull拉”？在”拉”体系中，数据的消费者决定何时从数据生产者那里获取数据，而生产者自身并不会意识到什么时候数据将会被发送给消费者。"></a>什么是”Pull拉”？在”拉”体系中，数据的消费者决定何时从数据生产者那里获取数据，而生产者自身并不会意识到什么时候数据将会被发送给消费者。</h4><h4 id="每一个JS函数都是一个“拉”体系，函数是数据的生产者，调用函数的代码通过“拉出”一个单一的返回值来消费该数据-return-语句-。"><a href="#每一个JS函数都是一个“拉”体系，函数是数据的生产者，调用函数的代码通过“拉出”一个单一的返回值来消费该数据-return-语句-。" class="headerlink" title="每一个JS函数都是一个“拉”体系，函数是数据的生产者，调用函数的代码通过“拉出”一个单一的返回值来消费该数据(return 语句)。"></a>每一个JS函数都是一个“拉”体系，函数是数据的生产者，调用函数的代码通过“拉出”一个单一的返回值来消费该数据(return 语句)。</h4></li>
</ul>
<h4 id="什么是”Push推”？在推体系中，数据的生产者决定何时发送数据给消费者，消费者不会在接收数据之前意识到它将要接收这个数据。"><a href="#什么是”Push推”？在推体系中，数据的生产者决定何时发送数据给消费者，消费者不会在接收数据之前意识到它将要接收这个数据。" class="headerlink" title="什么是”Push推”？在推体系中，数据的生产者决定何时发送数据给消费者，消费者不会在接收数据之前意识到它将要接收这个数据。"></a>什么是”Push推”？在推体系中，数据的生产者决定何时发送数据给消费者，消费者不会在接收数据之前意识到它将要接收这个数据。</h4><h4 id="Promise-承诺-是当今JS中最常见的Push推体系，一个Promise-数据的生产者-发送一个resolved-value-成功状态的值-来注册一个回调-数据消费者-，但是不同于函数的地方的是：Promise决定着何时数据才被推送至这个回调函数。"><a href="#Promise-承诺-是当今JS中最常见的Push推体系，一个Promise-数据的生产者-发送一个resolved-value-成功状态的值-来注册一个回调-数据消费者-，但是不同于函数的地方的是：Promise决定着何时数据才被推送至这个回调函数。" class="headerlink" title="Promise(承诺))是当今JS中最常见的Push推体系，一个Promise(数据的生产者)发送一个resolved value(成功状态的值)来注册一个回调(数据消费者)，但是不同于函数的地方的是：Promise决定着何时数据才被推送至这个回调函数。"></a>Promise(承诺))是当今JS中最常见的Push推体系，一个Promise(数据的生产者)发送一个resolved value(成功状态的值)来注册一个回调(数据消费者)，但是不同于函数的地方的是：Promise决定着何时数据才被推送至这个回调函数。</h4><h4 id="RxJS引入了Observables-可观察对象-，一个全新的”推体系”。一个可观察对象是一个产生多值的生产者，并”推送给”Observer-观察者-。"><a href="#RxJS引入了Observables-可观察对象-，一个全新的”推体系”。一个可观察对象是一个产生多值的生产者，并”推送给”Observer-观察者-。" class="headerlink" title="RxJS引入了Observables(可观察对象)，一个全新的”推体系”。一个可观察对象是一个产生多值的生产者，并”推送给”Observer(观察者)。"></a>RxJS引入了Observables(可观察对象)，一个全新的”推体系”。一个可观察对象是一个产生多值的生产者，并”推送给”Observer(观察者)。</h4><h3 id="RxJS-VS-Promise—3个最重要的不同点"><a href="#RxJS-VS-Promise—3个最重要的不同点" class="headerlink" title="RxJS VS Promise—3个最重要的不同点"></a>RxJS VS Promise—3个最重要的不同点</h3><!--| 不同点               | RxJS     | Promise  |

| --------------------|:---------:|---------:|

| 动作是否可以取消？    | 是        | 否       |

| 是否可以发射多个值？  | 是        | 否       |

| 各种工具函数？        | 是        | 否       |-->
<table>
<thead>
<tr>
<th>不同点</th>
<th style="text-align:center">Rxjs</th>
<th style="text-align:right">Promise</th>
</tr>
</thead>
<tbody>
<tr>
<td>动作是否可以取消？</td>
<td style="text-align:center">是</td>
<td style="text-align:right">否</td>
</tr>
<tr>
<td>是否可以发射多个值？</td>
<td style="text-align:center">是</td>
<td style="text-align:right">否</td>
</tr>
<tr>
<td>各种工具函数？</td>
<td style="text-align:center">是</td>
<td style="text-align:right">否</td>
</tr>
</tbody>
</table>
<h2 id="Operators操作符"><a href="#Operators操作符" class="headerlink" title="Operators操作符"></a>Operators操作符</h2><h3 id="create-创建一个可观察序列，参数为一个封装数据生成逻辑的函数，该函数的参数为观察者"><a href="#create-创建一个可观察序列，参数为一个封装数据生成逻辑的函数，该函数的参数为观察者" class="headerlink" title="create()  创建一个可观察序列，参数为一个封装数据生成逻辑的函数，该函数的参数为观察者"></a>create()  创建一个可观察序列，参数为一个封装数据生成逻辑的函数，该函数的参数为观察者</h3><h3 id="empty-不需要传递参数，创建一个空序列并立即结束"><a href="#empty-不需要传递参数，创建一个空序列并立即结束" class="headerlink" title="empty()  不需要传递参数，创建一个空序列并立即结束"></a>empty()  不需要传递参数，创建一个空序列并立即结束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.empty()  =  Rx.Observable.create((o)=&gt;&#123;</span><br><span class="line">    o.onCompleted()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="never-不需要传递参数，创建一个空序列，并永远不结束"><a href="#never-不需要传递参数，创建一个空序列，并永远不结束" class="headerlink" title="never() 不需要传递参数，创建一个空序列，并永远不结束"></a>never() 不需要传递参数，创建一个空序列，并永远不结束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.never()  =  Rx.Observable.create((o)=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="throw-创建一个空序列，参数来声明错误并立即抛出错误"><a href="#throw-创建一个空序列，参数来声明错误并立即抛出错误" class="headerlink" title="throw() 创建一个空序列，参数来声明错误并立即抛出错误"></a>throw() 创建一个空序列，参数来声明错误并立即抛出错误</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.throw(&apos;error&apos;)  =  Rx.Observable.create((o)=&gt;&#123;</span><br><span class="line">    0.onError(&apos;error&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="range-创建一个有线长度的整数序列，两个参数，第一个起始值，第二个元素数量"><a href="#range-创建一个有线长度的整数序列，两个参数，第一个起始值，第二个元素数量" class="headerlink" title="range() 创建一个有线长度的整数序列，两个参数，第一个起始值，第二个元素数量"></a>range() 创建一个有线长度的整数序列，两个参数，第一个起始值，第二个元素数量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.range(30,4)  //输出:30,31,32,33</span><br></pre></td></tr></table></figure>
<h3 id="interval-创建一个无限长度的周期性序列"><a href="#interval-创建一个无限长度的周期性序列" class="headerlink" title="interval() 创建一个无限长度的周期性序列"></a>interval() 创建一个无限长度的周期性序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.interval(1000) //输出:0,1,2...</span><br></pre></td></tr></table></figure>
<h3 id="timer-指定一个额外的参数来调节第一值的静默时长，第二个参数可选，若无则仅仅在规定的静默时长后输出一个值，然后结束序列"><a href="#timer-指定一个额外的参数来调节第一值的静默时长，第二个参数可选，若无则仅仅在规定的静默时长后输出一个值，然后结束序列" class="headerlink" title="timer() 指定一个额外的参数来调节第一值的静默时长，第二个参数可选，若无则仅仅在规定的静默时长后输出一个值，然后结束序列"></a>timer() 指定一个额外的参数来调节第一值的静默时长，第二个参数可选，若无则仅仅在规定的静默时长后输出一个值，然后结束序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.timer(0,1000) //输出:0,1,2...</span><br></pre></td></tr></table></figure>
<h3 id="from-可以将已有的数据转化为Observable-参数为iterable数据集对象-常见Array-String"><a href="#from-可以将已有的数据转化为Observable-参数为iterable数据集对象-常见Array-String" class="headerlink" title="from() 可以将已有的数据转化为Observable,参数为iterable数据集对象,常见Array,String"></a>from() 可以将已有的数据转化为Observable,参数为iterable数据集对象,常见Array,String</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.from(iterable)</span><br></pre></td></tr></table></figure>
<h3 id="of-不在同一个数据集中的多个来源的数据，使用of-方法直接构造："><a href="#of-不在同一个数据集中的多个来源的数据，使用of-方法直接构造：" class="headerlink" title="of()  不在同一个数据集中的多个来源的数据，使用of()方法直接构造："></a>of()  不在同一个数据集中的多个来源的数据，使用of()方法直接构造：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.of([1,2,3])    //    [1,2,3]</span><br><span class="line">Rx.Observable.from([1,2,3])  //    1,2,3</span><br></pre></td></tr></table></figure>
<h3 id="just-将任何数据转化为一个单值输出的Observable"><a href="#just-将任何数据转化为一个单值输出的Observable" class="headerlink" title="just()  将任何数据转化为一个单值输出的Observable"></a>just()  将任何数据转化为一个单值输出的Observable</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.just([1,2,3])    //    [1,2,3]</span><br></pre></td></tr></table></figure>
<h3 id="repeat-创建一个重复值序列-par1-值，par2：次数"><a href="#repeat-创建一个重复值序列-par1-值，par2：次数" class="headerlink" title="repeat() 创建一个重复值序列  par1:值，par2：次数"></a>repeat() 创建一个重复值序列  par1:值，par2：次数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.repeat(&apos;a&apos;,2)    //   a a</span><br></pre></td></tr></table></figure>
<h3 id="fromEvent-将事件流转化为Observable"><a href="#fromEvent-将事件流转化为Observable" class="headerlink" title="fromEvent() 将事件流转化为Observable,"></a>fromEvent() 将事件流转化为Observable,</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var el = document.getElementById(&quot;btn&quot;); //DOM对象作为事件源</span><br><span class="line">Rx.Observable.fromEvent(el,&quot;click&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="toArray-将序列还原为数组对象-只有在订阅后才还原为数组"><a href="#toArray-将序列还原为数组对象-只有在订阅后才还原为数组" class="headerlink" title="toArray() 将序列还原为数组对象,只有在订阅后才还原为数组"></a>toArray() 将序列还原为数组对象,只有在订阅后才还原为数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,3,4);    //序列：1 2 3 4 </span><br><span class="line">var target = source.toArray();     //序列：[1,2,3,4]</span><br><span class="line">target.subscribe(function(d)&#123;</span><br><span class="line">    console.log(d);             //d： [1,2,3,4]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="delay-推迟-参数为数字或Date对象"><a href="#delay-推迟-参数为数字或Date对象" class="headerlink" title="delay() 推迟   参数为数字或Date对象"></a>delay() 推迟   参数为数字或Date对象</h3><h3 id="delaySubscription-延迟订阅-参数同理"><a href="#delaySubscription-延迟订阅-参数同理" class="headerlink" title="delaySubscription() 延迟订阅  参数同理"></a>delaySubscription() 延迟订阅  参数同理</h3><h3 id="startWith-可以在源序列之前添加额外的元素"><a href="#startWith-可以在源序列之前添加额外的元素" class="headerlink" title="startWith() 可以在源序列之前添加额外的元素"></a>startWith() 可以在源序列之前添加额外的元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,3); //序列：1 2 3</span><br><span class="line">var target = source.startWith(7,8,9); //序列：7 8 9 1 2 3</span><br></pre></td></tr></table></figure>
<h3 id="map-对源序列进行变换，并返回新的序列-改变了源"><a href="#map-对源序列进行变换，并返回新的序列-改变了源" class="headerlink" title="map() 对源序列进行变换，并返回新的序列(改变了源)"></a>map() 对源序列进行变换，并返回新的序列(改变了源)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var trandform = function(item)&#123;</span><br><span class="line">    return item*2;</span><br><span class="line">&#125;</span><br><span class="line">var source = Rx.Observable.of(1,2,3); //输出： 1 2 3</span><br><span class="line">var target = source.map(trandform);   //输出： 2 4 6</span><br></pre></td></tr></table></figure>
<h1 id="concat-有序拼接-merge-无序"><a href="#concat-有序拼接-merge-无序" class="headerlink" title="concat() 有序拼接   merge()无序"></a>concat() 有序拼接   merge()无序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,3); //序列：1 2 3</span><br><span class="line">var target = source.concat(</span><br><span class="line">    Rx.Observable.of(4,5,6),</span><br><span class="line">    Rx.Observable.of(7,8,9)</span><br><span class="line">); //序列：1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>
<h3 id="concatAll-如果源序列的元素也是序列-——-序列的序列，那么可以使用concatAll-方法将各元素序列按顺序拼接起来"><a href="#concatAll-如果源序列的元素也是序列-——-序列的序列，那么可以使用concatAll-方法将各元素序列按顺序拼接起来" class="headerlink" title="concatAll()  如果源序列的元素也是序列 —— 序列的序列，那么可以使用concatAll() 方法将各元素序列按顺序拼接起来"></a>concatAll()  如果源序列的元素也是序列 —— 序列的序列，那么可以使用concatAll() 方法将各元素序列按顺序拼接起来</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(10,20,30)</span><br><span class="line">    .map(function(item)&#123;</span><br><span class="line">        return Rx.Observable.range(item,3);</span><br><span class="line">    &#125;); //序列： Observable&#123;10,11,12&#125; Observable&#123;20,21,22&#125; Observable&#123;30,31,32&#125;</span><br><span class="line">var target = source.concatAll(); //序列：10 10 12 20 21 22 30 31 32</span><br></pre></td></tr></table></figure>
<h3 id="catch-捕捉源序列错误，返回新序列"><a href="#catch-捕捉源序列错误，返回新序列" class="headerlink" title="catch()  捕捉源序列错误，返回新序列"></a>catch()  捕捉源序列错误，返回新序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.create(function(o)&#123;</span><br><span class="line">    o.onNext(1);</span><br><span class="line">    o.onNext(2);</span><br><span class="line">    o.onError(new Error(&quot;fake error&quot;));</span><br><span class="line">    o.onNext(4);</span><br><span class="line">&#125;); //序列： 1 2 &lt;ERROR&gt; 4</span><br><span class="line">var target = source.catch(Rx.Observable.from(&quot;abc&quot;)); //序列： 1 2 a b c</span><br></pre></td></tr></table></figure>
<h3 id="pluck-针对元素为json对象的源序列，返回指定属性的值的序列"><a href="#pluck-针对元素为json对象的源序列，返回指定属性的值的序列" class="headerlink" title="pluck()  针对元素为json对象的源序列，返回指定属性的值的序列"></a>pluck()  针对元素为json对象的源序列，返回指定属性的值的序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(&#123;name:&apos;john&apos;,age:33&#125;,&#123;name:&apos;lee&apos;,age:22&#125;);</span><br><span class="line">var target = source.pluck(&apos;name&apos;);  //序列 john lee</span><br></pre></td></tr></table></figure>
<h3 id="flatMap-平坦化映射-首先将一个序列的各元素映射为序列，然后将各序列融合-参数是一个映射函数，返回值为序列"><a href="#flatMap-平坦化映射-首先将一个序列的各元素映射为序列，然后将各序列融合-参数是一个映射函数，返回值为序列" class="headerlink" title="flatMap()  平坦化映射:首先将一个序列的各元素映射为序列，然后将各序列融合  参数是一个映射函数，返回值为序列"></a>flatMap()  平坦化映射:首先将一个序列的各元素映射为序列，然后将各序列融合  参数是一个映射函数，返回值为序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(10,20);</span><br><span class="line">var mf = function(item)&#123;</span><br><span class="line">    return Rx.Observable.range(item,3)</span><br><span class="line">&#125;</span><br><span class="line">var target = source.flatMap(mf)  // 序列：10,11,20,12,21,22</span><br></pre></td></tr></table></figure>
<h3 id="flatMapLatest-与flatMap-的区别在于将最新的序列中的元素输出"><a href="#flatMapLatest-与flatMap-的区别在于将最新的序列中的元素输出" class="headerlink" title="flatMapLatest()  与flatMap()的区别在于将最新的序列中的元素输出"></a>flatMapLatest()  与flatMap()的区别在于将最新的序列中的元素输出</h3><h3 id="concatMap-将源序列各元素映射为序列，然后按顺序拼接-与flatMap的区别所在"><a href="#concatMap-将源序列各元素映射为序列，然后按顺序拼接-与flatMap的区别所在" class="headerlink" title="concatMap()  将源序列各元素映射为序列，然后按顺序拼接 (与flatMap的区别所在)"></a>concatMap()  将源序列各元素映射为序列，然后按顺序拼接 (与flatMap的区别所在)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,3);</span><br><span class="line">var mf = function(item)&#123;</span><br><span class="line">    return Rx.Observable.range(item,3);</span><br><span class="line">&#125;</span><br><span class="line">var target = source.concatMap(mf)  //序列：1,2,3,2,3,4,3,4,5</span><br></pre></td></tr></table></figure>
<h2 id="flatMap与map异同点"><a href="#flatMap与map异同点" class="headerlink" title="flatMap与map异同点"></a>flatMap与map异同点</h2><h3 id="Map用于对自身对象数值进行映射，将发射对象转换成另一个发射对象发射，返回一个包含映射结果的Observable对象。而flatMap是把自身对象里的数值进行映射并转换成一个新的Observable对象-当从其他类型对象中构建Observable对象时，需要使用flatMap方法"><a href="#Map用于对自身对象数值进行映射，将发射对象转换成另一个发射对象发射，返回一个包含映射结果的Observable对象。而flatMap是把自身对象里的数值进行映射并转换成一个新的Observable对象-当从其他类型对象中构建Observable对象时，需要使用flatMap方法" class="headerlink" title="Map用于对自身对象数值进行映射，将发射对象转换成另一个发射对象发射，返回一个包含映射结果的Observable对象。而flatMap是把自身对象里的数值进行映射并转换成一个新的Observable对象.当从其他类型对象中构建Observable对象时，需要使用flatMap方法"></a>Map用于对自身对象数值进行映射，将发射对象转换成另一个发射对象发射，返回一个包含映射结果的Observable对象。而flatMap是把自身对象里的数值进行映射并转换成一个新的Observable对象.当从其他类型对象中构建Observable对象时，需要使用flatMap方法</h3><h2 id="flatMap与concatMap异同点"><a href="#flatMap与concatMap异同点" class="headerlink" title="flatMap与concatMap异同点"></a>flatMap与concatMap异同点</h2><h3 id="merge和map结合与concat和map结合的区别，归根结底为merge与concat的区别，一个无序一个有序"><a href="#merge和map结合与concat和map结合的区别，归根结底为merge与concat的区别，一个无序一个有序" class="headerlink" title="merge和map结合与concat和map结合的区别，归根结底为merge与concat的区别，一个无序一个有序"></a>merge和map结合与concat和map结合的区别，归根结底为merge与concat的区别，一个无序一个有序</h3><h3 id="filter-筛选源序列中满足条件的元素，并返回新的序列"><a href="#filter-筛选源序列中满足条件的元素，并返回新的序列" class="headerlink" title="filter() 筛选源序列中满足条件的元素，并返回新的序列"></a>filter() 筛选源序列中满足条件的元素，并返回新的序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,3,4,5); //序列： 1 2 3 4 5</span><br><span class="line">var target = source.filter(x =&gt; x&lt;4)  //序列： 1 2 3</span><br></pre></td></tr></table></figure>
<h3 id="skip-num-抑制序列头部元素数量输出-skipLast-num-尾部-skipWhile-if-指定一个条件"><a href="#skip-num-抑制序列头部元素数量输出-skipLast-num-尾部-skipWhile-if-指定一个条件" class="headerlink" title="skip(num) 抑制序列头部元素数量输出   skipLast(num)尾部   skipWhile(if)指定一个条件"></a>skip(num) 抑制序列头部元素数量输出   skipLast(num)尾部   skipWhile(if)指定一个条件</h3><h3 id="take-num-截取序列头部元素数量输出-takeLast-num-尾部-takeWhile-if-指定一个条件"><a href="#take-num-截取序列头部元素数量输出-takeLast-num-尾部-takeWhile-if-指定一个条件" class="headerlink" title="take(num) 截取序列头部元素数量输出   takeLast(num)尾部   takeWhile(if)指定一个条件"></a>take(num) 截取序列头部元素数量输出   takeLast(num)尾部   takeWhile(if)指定一个条件</h3><h3 id="distinct-去重-并返回一个新序列"><a href="#distinct-去重-并返回一个新序列" class="headerlink" title="distinct 去重,并返回一个新序列"></a>distinct 去重,并返回一个新序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,3,4,2,1); //序列： 1 2 3 4 2 1</span><br><span class="line">var target = source.distinct(); //序列：1 2 3 4</span><br></pre></td></tr></table></figure>
<h3 id="distinctUntilChanged-去重-并返回一个新序列"><a href="#distinctUntilChanged-去重-并返回一个新序列" class="headerlink" title="distinctUntilChanged 去重,并返回一个新序列"></a>distinctUntilChanged 去重,并返回一个新序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(1,2,2,3,4,2,1); //序列： 1 2 3 4 2 1</span><br><span class="line">var target = source.distinctUntilChanged(); //序列：1 2 3 4 2 1</span><br></pre></td></tr></table></figure>
<h3 id="debounce-去抖动-一段时间内只取最新数据作为一次发射数据，其他数据取消发射"><a href="#debounce-去抖动-一段时间内只取最新数据作为一次发射数据，其他数据取消发射" class="headerlink" title="debounce  去抖动,一段时间内只取最新数据作为一次发射数据，其他数据取消发射"></a>debounce  去抖动,一段时间内只取最新数据作为一次发射数据，其他数据取消发射</h3><h3 id="throttle-和debounce唯一区别是debounce取一段时间内最新的，而throttle忽略这段时间后，发现新值才发送-通俗讲，都设定一个时间周期，持续触发事件，throttle为每到时间周期便会触发一次，bebounce为触发周期小于设定时间周期不予事件触发）"><a href="#throttle-和debounce唯一区别是debounce取一段时间内最新的，而throttle忽略这段时间后，发现新值才发送-通俗讲，都设定一个时间周期，持续触发事件，throttle为每到时间周期便会触发一次，bebounce为触发周期小于设定时间周期不予事件触发）" class="headerlink" title="throttle(和debounce唯一区别是debounce取一段时间内最新的，而throttle忽略这段时间后，发现新值才发送, 通俗讲，都设定一个时间周期，持续触发事件，throttle为每到时间周期便会触发一次，bebounce为触发周期小于设定时间周期不予事件触发）"></a>throttle(和debounce唯一区别是debounce取一段时间内最新的，而throttle忽略这段时间后，发现新值才发送, 通俗讲，都设定一个时间周期，持续触发事件，throttle为每到时间周期便会触发一次，bebounce为触发周期小于设定时间周期不予事件触发）</h3><h3 id="buffer-使用第二个序列触发源序列中多个元素的打包"><a href="#buffer-使用第二个序列触发源序列中多个元素的打包" class="headerlink" title="buffer() 使用第二个序列触发源序列中多个元素的打包"></a>buffer() 使用第二个序列触发源序列中多个元素的打包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.timer(0,1000);    //序列：0 1 2 3 ...</span><br><span class="line">var boundaries = Rx.Observable.timer(2500); //延时2500ms触发</span><br><span class="line">var target = source.buffer(boundaries); //序列： [0,1,2]</span><br></pre></td></tr></table></figure>
<h3 id="bufferWithTime-按固定时间间隔对源序列进行打包"><a href="#bufferWithTime-按固定时间间隔对源序列进行打包" class="headerlink" title="bufferWithTime() 按固定时间间隔对源序列进行打包"></a>bufferWithTime() 按固定时间间隔对源序列进行打包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.timer(0,1000); //序列：0 1 2 3 ...</span><br><span class="line">var target = source.bufferWithTime(2500); //序列：[0,1,2] [3,4] ...</span><br></pre></td></tr></table></figure>
<h3 id="zip-支持可变数量的序列作为参数，最后一个参数应当是一个组合函数，-其返回值将作为目标序列的元素"><a href="#zip-支持可变数量的序列作为参数，最后一个参数应当是一个组合函数，-其返回值将作为目标序列的元素" class="headerlink" title="zip()  支持可变数量的序列作为参数，最后一个参数应当是一个组合函数， 其返回值将作为目标序列的元素"></a>zip()  支持可变数量的序列作为参数，最后一个参数应当是一个组合函数， 其返回值将作为目标序列的元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var source1 = Rx.Observable.of(1,2,3); //序列： 1 2 3</span><br><span class="line">var source2 = Rx.Observable.of(4,5,6); //序列：4 5 6</span><br><span class="line">var cf = function(d1,d2)&#123; return d1 + &apos;-&apos; + d2;&#125;;</span><br><span class="line">var target = Rx.Observable.zip(source1,source2,cf); //序列： 1-4 2-5 3-6</span><br></pre></td></tr></table></figure>
<h3 id="forkJoin-将多个序列的最后一个元素组合为一个数组后，作为目标序列的唯一元素"><a href="#forkJoin-将多个序列的最后一个元素组合为一个数组后，作为目标序列的唯一元素" class="headerlink" title="forkJoin()  将多个序列的最后一个元素组合为一个数组后，作为目标序列的唯一元素"></a>forkJoin()  将多个序列的最后一个元素组合为一个数组后，作为目标序列的唯一元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var source1 = Rx.Observable.of(1,2,3); //序列： 1 2 3</span><br><span class="line">var source2 = Rx.Observable.of(4,5,6); //序列： 4 5 6</span><br><span class="line">var target = Rz.Observable.forkJoin(source1,source2); //序列：[3,6]</span><br></pre></td></tr></table></figure>
<h3 id="combineLatest-将多个序列的最后一个元素，使用组合函数构成目标序列的一个新元素"><a href="#combineLatest-将多个序列的最后一个元素，使用组合函数构成目标序列的一个新元素" class="headerlink" title="combineLatest() 将多个序列的最后一个元素，使用组合函数构成目标序列的一个新元素"></a>combineLatest() 将多个序列的最后一个元素，使用组合函数构成目标序列的一个新元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var source1 = Rx.Observable.interval(200).map(x =&gt; &apos;First:&apos; + x)</span><br><span class="line">var source2 = Rx.Observable.interval(100).map(x =&gt; &apos;Second:&apos; + x)</span><br><span class="line">var source = Rx.Observable.combineLatest(</span><br><span class="line">    source1,</span><br><span class="line">    source2</span><br><span class="line">).take(4);   // [&quot;First:0&quot;, &quot;Second:0&quot;]  [&quot;First:0&quot;, &quot;Second:1&quot;]  [&quot;First:0&quot;, &quot;Second:2&quot;]   [&quot;First:1&quot;, &quot;Second:2&quot;]</span><br></pre></td></tr></table></figure>
    </div>

    
    
    
      

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Lee_Ran
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://vernvn.github.io/2017/02/28/rxjs/" title="RxJS:万物皆为流">http://vernvn.github.io/2017/02/28/rxjs/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/null" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2016/11/21/ng1%E4%B8%8Eng2%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E6%AF%94%E8%BE%83/" rel="prev" title="依赖注入">
      <i class="fa fa-chevron-left"></i> 依赖注入
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/04/13/Subject/" rel="next" title="Subject">
      Subject <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。最好的Rxjs中文文档"><span class="nav-number">1.</span> <span class="nav-text">首先贴上一个中文Rxjs文档链接，从官网被人直译下来的，也是比较全面的介绍rxjs了。最好的Rxjs中文文档</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RXJS全名Reactive-Extensions-for-JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。"><span class="nav-number">1.1.</span> <span class="nav-text">RXJS全名Reactive Extensions for JavaScript，JavaScript的响应式扩展。什么是响应式？响应式就是跟随时间不断变化的数据、状态、事件等转换成可被观察的序列，然后订阅那些变化，一旦变化则会执行业务逻辑。适用于异步场景。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RxJS所能解决的问题："><span class="nav-number">1.2.</span> <span class="nav-text">RxJS所能解决的问题：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时刻保持响应。这对于一个应用来说意味着当他处理用户的输入或者凭借AJAX从服务器接受一些数据时停止是一件不可能接受的事情。在JavaScript中解决问题的方案始终是大量运用回调函数来进行一些运行的处理。但回调的使用使内容丰富的大型应用变得凌乱，一旦你需要多块数据时你就陷入了回调地狱。Angular2中，组件间通讯-Output对应的EventEmitter实际上就是一个Subject-主题：同时为Observable和Observer-Http模块中Observable作为大部分API的交互对象使用。但是这只是官方的外部扩展，并不必须，也可以使用-toPromise的方式转换为Promise来使用或第三方扩展库或Fetch-API-传统Ajax已死，Fetch永生。"><span class="nav-number">1.2.1.</span> <span class="nav-text">时刻保持响应。这对于一个应用来说意味着当他处理用户的输入或者凭借AJAX从服务器接受一些数据时停止是一件不可能接受的事情。在JavaScript中解决问题的方案始终是大量运用回调函数来进行一些运行的处理。但回调的使用使内容丰富的大型应用变得凌乱，一旦你需要多块数据时你就陷入了回调地狱。Angular2中，组件间通讯@Output对应的EventEmitter实际上就是一个Subject(主题：同时为Observable和Observer);Http模块中Observable作为大部分API的交互对象使用。但是这只是官方的外部扩展，并不必须，也可以使用.toPromise的方式转换为Promise来使用或第三方扩展库或Fetch API 传统Ajax已死，Fetch永生。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RxJS初探："><span class="nav-number">1.3.</span> <span class="nav-text">RxJS初探：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RxJS是一个解决异步问题的JS开发库-它带来了观察者模式和函数式编程的相结合的最佳实践。-观察者模式是一个被实践证明的模式，基于生产者（事件的创建者）和消费者（事件的监听者）的逻辑分离关系-况且函数式编程方式的引入，如说明性编程，不可变数据结构，链式方法调用会使你极大的简化代码量。RxJS-引入了一个重要的数据类型——流（stream）。流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下，等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。"><span class="nav-number">1.3.1.</span> <span class="nav-text">RxJS是一个解决异步问题的JS开发库.它带来了观察者模式和函数式编程的相结合的最佳实践。 观察者模式是一个被实践证明的模式，基于生产者（事件的创建者）和消费者（事件的监听者）的逻辑分离关系.况且函数式编程方式的引入，如说明性编程，不可变数据结构，链式方法调用会使你极大的简化代码量。RxJS 引入了一个重要的数据类型——流（stream）。流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下，等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream"><span class="nav-number">1.4.</span> <span class="nav-text">Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。"><span class="nav-number">1.4.1.</span> <span class="nav-text">流（Streams）无非是随时间流逝的一系列事件。流（Streams）可以用来处理任何类型的事件，如：鼠标点击，键盘按下等等。你可以把流作为变量，它有能力从数据角度对发生的改变做出反应。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事件引发的改变总是从事件源（生产者）-向下传递到所有事件监听方（消费者）。如果变量看做流呢，又是什么结果呢？"><span class="nav-number">1.4.2.</span> <span class="nav-text">事件引发的改变总是从事件源（生产者）,向下传递到所有事件监听方（消费者）。如果变量看做流呢，又是什么结果呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#流的方式重新定义的变量值的动态行为-换句话说，C-是把两个流变量A-和B-进行合并操作。当一个新值被推进了A-，C-立刻响应式的变更为16。"><span class="nav-number">1.4.3.</span> <span class="nav-text">流的方式重新定义的变量值的动态行为.换句话说，C$是把两个流变量A$和B$进行合并操作。当一个新值被推进了A$，C$立刻响应式的变更为16。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开始了解RxJS中的几个重要成员"><span class="nav-number">1.5.</span> <span class="nav-text">开始了解RxJS中的几个重要成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第一个例子"><span class="nav-number">1.6.</span> <span class="nav-text">第一个例子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用RxJS创建一个可观察对象："><span class="nav-number">1.6.1.</span> <span class="nav-text">使用RxJS创建一个可观察对象：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#observable可观察对象，以惰性的方式推送多值的集合"><span class="nav-number">1.7.</span> <span class="nav-text">observable可观察对象，以惰性的方式推送多值的集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#下面的例子是一个推送1-2，3-4数值的可观察对象，一旦它被订阅1-2，3-就会被推送，4则会在订阅发生一秒之后被推送，紧接着完成推送"><span class="nav-number">1.7.1.</span> <span class="nav-text">下面的例子是一个推送1,2，3,4数值的可观察对象，一旦它被订阅1,2，3,就会被推送，4则会在订阅发生一秒之后被推送，紧接着完成推送</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pull拉取-VS-Push推送"><span class="nav-number">1.8.</span> <span class="nav-text">Pull拉取 VS Push推送</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#拉和推是数据生产者和数据的消费者两种不同的交流协议-方式"><span class="nav-number">1.8.1.</span> <span class="nav-text">拉和推是数据生产者和数据的消费者两种不同的交流协议(方式);</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是”Pull拉”？在”拉”体系中，数据的消费者决定何时从数据生产者那里获取数据，而生产者自身并不会意识到什么时候数据将会被发送给消费者。"><span class="nav-number">1.8.2.</span> <span class="nav-text">什么是”Pull拉”？在”拉”体系中，数据的消费者决定何时从数据生产者那里获取数据，而生产者自身并不会意识到什么时候数据将会被发送给消费者。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#每一个JS函数都是一个“拉”体系，函数是数据的生产者，调用函数的代码通过“拉出”一个单一的返回值来消费该数据-return-语句-。"><span class="nav-number">1.8.3.</span> <span class="nav-text">每一个JS函数都是一个“拉”体系，函数是数据的生产者，调用函数的代码通过“拉出”一个单一的返回值来消费该数据(return 语句)。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是”Push推”？在推体系中，数据的生产者决定何时发送数据给消费者，消费者不会在接收数据之前意识到它将要接收这个数据。"><span class="nav-number">1.8.4.</span> <span class="nav-text">什么是”Push推”？在推体系中，数据的生产者决定何时发送数据给消费者，消费者不会在接收数据之前意识到它将要接收这个数据。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-承诺-是当今JS中最常见的Push推体系，一个Promise-数据的生产者-发送一个resolved-value-成功状态的值-来注册一个回调-数据消费者-，但是不同于函数的地方的是：Promise决定着何时数据才被推送至这个回调函数。"><span class="nav-number">1.8.5.</span> <span class="nav-text">Promise(承诺))是当今JS中最常见的Push推体系，一个Promise(数据的生产者)发送一个resolved value(成功状态的值)来注册一个回调(数据消费者)，但是不同于函数的地方的是：Promise决定着何时数据才被推送至这个回调函数。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RxJS引入了Observables-可观察对象-，一个全新的”推体系”。一个可观察对象是一个产生多值的生产者，并”推送给”Observer-观察者-。"><span class="nav-number">1.8.6.</span> <span class="nav-text">RxJS引入了Observables(可观察对象)，一个全新的”推体系”。一个可观察对象是一个产生多值的生产者，并”推送给”Observer(观察者)。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RxJS-VS-Promise—3个最重要的不同点"><span class="nav-number">1.9.</span> <span class="nav-text">RxJS VS Promise—3个最重要的不同点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Operators操作符"><span class="nav-number">2.</span> <span class="nav-text">Operators操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#create-创建一个可观察序列，参数为一个封装数据生成逻辑的函数，该函数的参数为观察者"><span class="nav-number">2.1.</span> <span class="nav-text">create()  创建一个可观察序列，参数为一个封装数据生成逻辑的函数，该函数的参数为观察者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#empty-不需要传递参数，创建一个空序列并立即结束"><span class="nav-number">2.2.</span> <span class="nav-text">empty()  不需要传递参数，创建一个空序列并立即结束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#never-不需要传递参数，创建一个空序列，并永远不结束"><span class="nav-number">2.3.</span> <span class="nav-text">never() 不需要传递参数，创建一个空序列，并永远不结束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#throw-创建一个空序列，参数来声明错误并立即抛出错误"><span class="nav-number">2.4.</span> <span class="nav-text">throw() 创建一个空序列，参数来声明错误并立即抛出错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#range-创建一个有线长度的整数序列，两个参数，第一个起始值，第二个元素数量"><span class="nav-number">2.5.</span> <span class="nav-text">range() 创建一个有线长度的整数序列，两个参数，第一个起始值，第二个元素数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#interval-创建一个无限长度的周期性序列"><span class="nav-number">2.6.</span> <span class="nav-text">interval() 创建一个无限长度的周期性序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#timer-指定一个额外的参数来调节第一值的静默时长，第二个参数可选，若无则仅仅在规定的静默时长后输出一个值，然后结束序列"><span class="nav-number">2.7.</span> <span class="nav-text">timer() 指定一个额外的参数来调节第一值的静默时长，第二个参数可选，若无则仅仅在规定的静默时长后输出一个值，然后结束序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#from-可以将已有的数据转化为Observable-参数为iterable数据集对象-常见Array-String"><span class="nav-number">2.8.</span> <span class="nav-text">from() 可以将已有的数据转化为Observable,参数为iterable数据集对象,常见Array,String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#of-不在同一个数据集中的多个来源的数据，使用of-方法直接构造："><span class="nav-number">2.9.</span> <span class="nav-text">of()  不在同一个数据集中的多个来源的数据，使用of()方法直接构造：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#just-将任何数据转化为一个单值输出的Observable"><span class="nav-number">2.10.</span> <span class="nav-text">just()  将任何数据转化为一个单值输出的Observable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#repeat-创建一个重复值序列-par1-值，par2：次数"><span class="nav-number">2.11.</span> <span class="nav-text">repeat() 创建一个重复值序列  par1:值，par2：次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fromEvent-将事件流转化为Observable"><span class="nav-number">2.12.</span> <span class="nav-text">fromEvent() 将事件流转化为Observable,</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#toArray-将序列还原为数组对象-只有在订阅后才还原为数组"><span class="nav-number">2.13.</span> <span class="nav-text">toArray() 将序列还原为数组对象,只有在订阅后才还原为数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#delay-推迟-参数为数字或Date对象"><span class="nav-number">2.14.</span> <span class="nav-text">delay() 推迟   参数为数字或Date对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#delaySubscription-延迟订阅-参数同理"><span class="nav-number">2.15.</span> <span class="nav-text">delaySubscription() 延迟订阅  参数同理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#startWith-可以在源序列之前添加额外的元素"><span class="nav-number">2.16.</span> <span class="nav-text">startWith() 可以在源序列之前添加额外的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-对源序列进行变换，并返回新的序列-改变了源"><span class="nav-number">2.17.</span> <span class="nav-text">map() 对源序列进行变换，并返回新的序列(改变了源)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#concat-有序拼接-merge-无序"><span class="nav-number"></span> <span class="nav-text">concat() 有序拼接   merge()无序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#concatAll-如果源序列的元素也是序列-——-序列的序列，那么可以使用concatAll-方法将各元素序列按顺序拼接起来"><span class="nav-number">0.1.</span> <span class="nav-text">concatAll()  如果源序列的元素也是序列 —— 序列的序列，那么可以使用concatAll() 方法将各元素序列按顺序拼接起来</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#catch-捕捉源序列错误，返回新序列"><span class="nav-number">0.2.</span> <span class="nav-text">catch()  捕捉源序列错误，返回新序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pluck-针对元素为json对象的源序列，返回指定属性的值的序列"><span class="nav-number">0.3.</span> <span class="nav-text">pluck()  针对元素为json对象的源序列，返回指定属性的值的序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flatMap-平坦化映射-首先将一个序列的各元素映射为序列，然后将各序列融合-参数是一个映射函数，返回值为序列"><span class="nav-number">0.4.</span> <span class="nav-text">flatMap()  平坦化映射:首先将一个序列的各元素映射为序列，然后将各序列融合  参数是一个映射函数，返回值为序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flatMapLatest-与flatMap-的区别在于将最新的序列中的元素输出"><span class="nav-number">0.5.</span> <span class="nav-text">flatMapLatest()  与flatMap()的区别在于将最新的序列中的元素输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#concatMap-将源序列各元素映射为序列，然后按顺序拼接-与flatMap的区别所在"><span class="nav-number">0.6.</span> <span class="nav-text">concatMap()  将源序列各元素映射为序列，然后按顺序拼接 (与flatMap的区别所在)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#flatMap与map异同点"><span class="nav-number">1.</span> <span class="nav-text">flatMap与map异同点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Map用于对自身对象数值进行映射，将发射对象转换成另一个发射对象发射，返回一个包含映射结果的Observable对象。而flatMap是把自身对象里的数值进行映射并转换成一个新的Observable对象-当从其他类型对象中构建Observable对象时，需要使用flatMap方法"><span class="nav-number">1.1.</span> <span class="nav-text">Map用于对自身对象数值进行映射，将发射对象转换成另一个发射对象发射，返回一个包含映射结果的Observable对象。而flatMap是把自身对象里的数值进行映射并转换成一个新的Observable对象.当从其他类型对象中构建Observable对象时，需要使用flatMap方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#flatMap与concatMap异同点"><span class="nav-number">2.</span> <span class="nav-text">flatMap与concatMap异同点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#merge和map结合与concat和map结合的区别，归根结底为merge与concat的区别，一个无序一个有序"><span class="nav-number">2.1.</span> <span class="nav-text">merge和map结合与concat和map结合的区别，归根结底为merge与concat的区别，一个无序一个有序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#filter-筛选源序列中满足条件的元素，并返回新的序列"><span class="nav-number">2.2.</span> <span class="nav-text">filter() 筛选源序列中满足条件的元素，并返回新的序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#skip-num-抑制序列头部元素数量输出-skipLast-num-尾部-skipWhile-if-指定一个条件"><span class="nav-number">2.3.</span> <span class="nav-text">skip(num) 抑制序列头部元素数量输出   skipLast(num)尾部   skipWhile(if)指定一个条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#take-num-截取序列头部元素数量输出-takeLast-num-尾部-takeWhile-if-指定一个条件"><span class="nav-number">2.4.</span> <span class="nav-text">take(num) 截取序列头部元素数量输出   takeLast(num)尾部   takeWhile(if)指定一个条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#distinct-去重-并返回一个新序列"><span class="nav-number">2.5.</span> <span class="nav-text">distinct 去重,并返回一个新序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#distinctUntilChanged-去重-并返回一个新序列"><span class="nav-number">2.6.</span> <span class="nav-text">distinctUntilChanged 去重,并返回一个新序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#debounce-去抖动-一段时间内只取最新数据作为一次发射数据，其他数据取消发射"><span class="nav-number">2.7.</span> <span class="nav-text">debounce  去抖动,一段时间内只取最新数据作为一次发射数据，其他数据取消发射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#throttle-和debounce唯一区别是debounce取一段时间内最新的，而throttle忽略这段时间后，发现新值才发送-通俗讲，都设定一个时间周期，持续触发事件，throttle为每到时间周期便会触发一次，bebounce为触发周期小于设定时间周期不予事件触发）"><span class="nav-number">2.8.</span> <span class="nav-text">throttle(和debounce唯一区别是debounce取一段时间内最新的，而throttle忽略这段时间后，发现新值才发送, 通俗讲，都设定一个时间周期，持续触发事件，throttle为每到时间周期便会触发一次，bebounce为触发周期小于设定时间周期不予事件触发）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buffer-使用第二个序列触发源序列中多个元素的打包"><span class="nav-number">2.9.</span> <span class="nav-text">buffer() 使用第二个序列触发源序列中多个元素的打包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bufferWithTime-按固定时间间隔对源序列进行打包"><span class="nav-number">2.10.</span> <span class="nav-text">bufferWithTime() 按固定时间间隔对源序列进行打包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zip-支持可变数量的序列作为参数，最后一个参数应当是一个组合函数，-其返回值将作为目标序列的元素"><span class="nav-number">2.11.</span> <span class="nav-text">zip()  支持可变数量的序列作为参数，最后一个参数应当是一个组合函数， 其返回值将作为目标序列的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#forkJoin-将多个序列的最后一个元素组合为一个数组后，作为目标序列的唯一元素"><span class="nav-number">2.12.</span> <span class="nav-text">forkJoin()  将多个序列的最后一个元素组合为一个数组后，作为目标序列的唯一元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#combineLatest-将多个序列的最后一个元素，使用组合函数构成目标序列的一个新元素"><span class="nav-number">2.13.</span> <span class="nav-text">combineLatest() 将多个序列的最后一个元素，使用组合函数构成目标序列的一个新元素</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lee_Ran"
      src="https://avatars3.githubusercontent.com/u/17755520?s=400&u=9f444bfe70cd719b9bf43ed5fedac2f1d005ff5a&v=4">
  <p class="site-author-name" itemprop="name">Lee_Ran</p>
  <div class="site-description" itemprop="description">保持一种学习的状态，然后努力锻炼身体，身体和灵魂都在路上</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/vernvn" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;vernvn" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/LeeRan_6924" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;LeeRan_6924" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lee_Ran</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">99k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:30</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.getScript('//cdnjs.cloudflare.com/ajax/libs/valine/1.3.10/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'QfahI6cKHY3GG5yQXXolk1B0-gzGzoHsz',
    appKey: 'vSifpsCVWtIcXuyer0Axr43c',
    placeholder: "Just go go",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
